<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maples7&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maples7.com/"/>
  <updated>2021-11-19T15:40:12.684Z</updated>
  <id>http://maples7.com/</id>
  
  <author>
    <name>Maples7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>创业的准则</title>
    <link href="http://maples7.com/2021/11/19/principles-4-startups/"/>
    <id>http://maples7.com/2021/11/19/principles-4-startups/</id>
    <published>2021-11-19T14:46:24.000Z</published>
    <updated>2021-11-19T15:40:12.684Z</updated>
    
    <content type="html"><![CDATA[<p>对于普通的立志于在互联网行业有所作为的大学毕业生而言，选择去大公司还是去创业公司工作一直是一个没有标准答案的问题，不同的人适合不同的道路。而另一个更艰难的道路就是自主创业。我毕业这几年，正好集齐了在创业公司、国内中型民营公司和跨国大公司的工作经验。总的来说，在创业公司的工作是其中目前为止最长也非常可圈可点的难忘经历。这篇文章根据我在创业公司的经验和自己平时对于市场的思考总结而成，是我认为创业应当遵循的创业的准则，不一定正确也不是一个系统完整的阐述，个人观点，仅供参考。</p><a id="more"></a><ol><li><p>找最优秀的人一起工作。</p><p>这里的「优秀」不一定得是具体业务上已经最厉害的人，但一定是有潜力成为最厉害的人的人。优秀的人能给公司带来的长期价值是难以用一朝一夕来衡量的。除了完全能胜任本职工作的基本能力以外，优秀的人不仅能对整个团队的建设产生积极的影响，更重要的是，他们往往能跳出传统的思维和各种条条框框的限制来看待具体的问题，提出创造性的解决方案，给整个团队创作难以估量的价值，而这些价值很可能成为决定创业公司走向和存亡的关键核心优势。</p><p>当然，有潜力的人是需要时间和空间来培养的，而创业公司相比于中大型公司往往更容易营造这样肥沃的土壤。优秀的人能持续学习，跟随公司一起成长，互相成就，达成共赢。创业公司在人才方面存在越多这样的良性循环，就越能走得更长远。</p></li></ol><ol start="2"><li><p>宁可不做，做就要用对的方法做对的事情，不要用错误的方法做事。</p><p>明星技术创业公司 TiDB 的 CTO 黄东旭有一个观点我很赞同：Make it right before making it fast。朝着正确的方向做事永远是所有具体决策的大前提。创业公司本身所拥有资源是很有限的，只能用有限的资源发挥更大的效能才能跑赢更大型的公司。这一点其实对创业公司的领导者提出了很高的要求，这要求他们能够有足够的预见性和前瞻性，能够充分吸收外部市场上各种各样的信息做出正确的决策。</p><p>有的人可能会认为「快」比「正确」更重要，我并不这样认为，或者说，这中间需要一个平衡和取舍。有一种常见的说法是创业公司能够快速试错从而能比大公司更灵活的「转身」。这一点在已经做出错误决策的情况下是正确的，所以正确表述应该是「创业公司能够比大公司更快速的扭转错误的方向」。可是我们为什么不追求从一开始就尽量不做出错误的决策呢？用俗话说就是，不要用战术上的勤奋掩盖战略上的懒惰。创业公司领导者需要花更多的时间思考公司的战略和方向而不是整天呆在公司扣一些细枝末节（当然，并不是细枝末节不重要，而是战略方向要更重要得多）。一定要记住一个大前提，创业公司所拥有的资源是非常有限的，所以试错的机会成本其实比大公司要高得多。大公司完全可以拆出数十倍于创业公司的资源来试错不同的决策方向和选择，而创业公司失败一次就足以让团队元气大伤。优秀的团队成员可能可以给公司的效率带来很大的提升，但错误的决策方向落地执行下去不仅是对客观资源的一种浪费，也是对人才的一种伤害。</p><p>所以「正确」比「快」更重要，宁可不做，做就要做对的事情，并且用对的方法来做这件事。</p></li><li><p>在没有划时代的技术优势时，产品的成功是所有细小正确决定优势的累积。</p><p><a href="https://www.thoughtworks.com/radar" target="_blank" rel="noopener">Thoughtworks 有一个广为流传的技术雷达的观点</a>，但真正能划时代的技术其实是极其稀少的，而每一个关键技术的突破，都可以带来一波技术红利的浪潮，持续数年。现如今，上一波移动互联网的浪潮早已远去，下一个能来带技术爆炸的计算平台到底是啥还未可知，可能是实现完全无人驾驶技术的新能源汽车，也可能是 Facebook 刚提出的所谓「元宇宙」虚拟网络空间，总之还没有确定性的答案，而过早涉足这些技术的创业公司大概率也会成为时代的炮灰。然而在已经成熟的技术领域里挣扎似乎又早已没有可以创新的空间。</p><p>我上一段在创业公司的工作经历所做的产品就是在很传统的领域，很难打破传统行业的桎梏做出颠覆式的创新。所以产品想要在公开市场上取得成功几乎只能取决于所有细小正确决定优势的累积。就好比你在 2021 年的今天做一个手机 App，你已经很难找到无人想到的新的创意来填补市场上的空白，存量竞争的时代只能靠产品上累积的细节和局部的优势来来取得竞争优势。这些优势可能是更少的 bug、更好看好用的 UI/UX、更人性化的布局和设计、抑或是能支撑产品决策的更成熟深刻的理论基础。关注细节、关注每一个微小的决定，在这种技术周期的浪潮下是重要的。</p></li><li><p>用产品和技术而不是营销手段说服用户。</p><p>在产品没有打磨好之前，不要使用任何刻意的营销手段。这样做只会提前消耗掉未来可能成为优质长期用户的市场耐心。真正的好产品，靠自然流量和口碑传播也终能被市场认可，但在市场快速变化的今天，在产品打磨好之后，使用营销手段可以加速从 1 到 N 的过程，快速占领市场份额，建立自己在这方面的护城河。</p></li><li><p>建立制度，然后让更多的人自己做决定。</p><p>有团队的地方就需要有制度，制度是团队文化的具体化，文化通常可能带有创始人强烈的个人色彩。但不管怎样，因为人的差异性，制度是需要的，而在制度建立之后，具体的与每个团队成员相关的决定让成员们自己做选择（尤其是小团队的时候，吸纳优秀的人进团队，再充分信任每一个团队成员）。只有这样，才能真正在团队范围内做到文化与行为的一致性。比如，现在很多互联网公司都会实行弹性工作制，如果这真的是创始人所认同的工作制，那么我们可以建立弹性工作的制度，同时要求每天基础的工作时长，那么具体每天的工作时间段则交给团队成员自由选择；如果创始人并不真的认同这样的制度，即便口头上声明你们是弹性工作制，长期下来的言行不统一也会让团队成员逐渐丧失对这个团队的信任，相互之间变得不再坦诚；而如果创始人认为就应该是白天固定时间段的工作制更符合团队工作效率的要求，那么制度就是固定工作时间制，而不要声明的与实际的有出入。修补制度上的漏洞，直到让大多数人尤其是创始人达到一个舒服的状态，而把具体事项的决定权交给充分被信任的每个人。</p><p>本质上，这其实是约束与放任的平衡哲学，建立制度就是建立约束，而让每个人做与自己相关的决定就是给予成员选择的自由。这样充分打磨下来的团队才能稳定持续走得长久。</p><p>文化上尽量开放包容，奖惩的原则要事先声明并遵照执行，合作靠透明的制度而不是依赖于默契（短暂的依赖于具体个体之间的默契不是可以长远依靠的事情）。</p></li><li><p>不放过任何一个细小的直觉上能感知到的问题。</p><p>在一片迷雾中行走，很多时候都是依靠直觉的。而创始人往往拥有对团队、对产品方向最敏锐的直觉。当有某方面敏锐的感知时，不要犹豫，不要怀疑，立马去验证自己的直觉。这种直觉的感知往往是有所苗头的，而越早行动越能避免更多更大的问题的产生。</p></li><li><p>流程优化永远比赶进度更重要。</p><p>对流程上的优化<strong>永远</strong>（记住是「永远」）比赶进度更重要。只要发现了流程上影响效率的地方，立马启动优化。对于 to B 类型的项目，存在这样一种情况，客户要求的时间很紧，项目进度很赶，而流程上也有很多亟待优化的地方，那么就引入更多的人力资源来优化流程上需要改进的地方，不管是从外部招更多的人还是从内部调其他的人来处理。效率是创业团队的生命线，失去了效率也就基本失去与大公司竞争的很大一方面的优势，所以永远要优化流程，当一个低效的流程反复被执行，浪费的不仅是这个流程上所有人的时间，更是对这个流程线上人的主观能动性的脱敏式折磨（这类似于中大型企业虽然有很多常年低效的流程制度，但因为早已形成惯性无人进行优化，员工们也逐渐就不再觉得那是可以被改变或优化的地方，慢慢的越来越多的人开始人浮于事，用打工人的心态各扫门前雪，这往往就是中大型企业开始体制僵化走向衰败的开始）。</p></li></ol><p>差不多暂时能想到的点就这些，如果以后有新的想法可以总结成文也会写一些新的东西。创业是一个十分艰难的过程，三年在创业公司的经历见证了一个小团队的起起伏伏，对于方向和未来的迷茫，感受到真实世界里创业的艰辛和残酷。不禁让人想起十年前左右「大众创新」所引发的在校大学生的创业热潮，大部分都是极其幼稚的（当然不可否认当时成功的创业项目也很多，那个时代有那个时代的红利）。当面对真实的现金流压力的时候，你的所有产品决策和公司走向还能不忘初心吗？无论成败与否，所有的创业者都会需要想明白这个现实的问题，并找到自己的答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于普通的立志于在互联网行业有所作为的大学毕业生而言，选择去大公司还是去创业公司工作一直是一个没有标准答案的问题，不同的人适合不同的道路。而另一个更艰难的道路就是自主创业。我毕业这几年，正好集齐了在创业公司、国内中型民营公司和跨国大公司的工作经验。总的来说，在创业公司的工作是其中目前为止最长也非常可圈可点的难忘经历。这篇文章根据我在创业公司的经验和自己平时对于市场的思考总结而成，是我认为创业应当遵循的创业的准则，不一定正确也不是一个系统完整的阐述，个人观点，仅供参考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浮生散记" scheme="http://maples7.com/categories/%E6%B5%AE%E7%94%9F%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="创业" scheme="http://maples7.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
      <category term="产品" scheme="http://maples7.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>2020 年书单</title>
    <link href="http://maples7.com/2020/12/31/2020-booklist/"/>
    <id>http://maples7.com/2020/12/31/2020-booklist/</id>
    <published>2020-12-30T18:06:45.000Z</published>
    <updated>2021-11-13T04:56:40.085Z</updated>
    
    <content type="html"><![CDATA[<p>2020 年，是一个太魔幻的一年（什么？你不知道为什么会这么说？好吧，如果你来自未来，本文末尾有一期推荐的播客可以听一下），甚至很有可能还是「魔幻元年」。那句话怎么说的来着：今年是过去十年最差的一年，却可能是未来十年最好的一年。当然，认真地讲，我并不完全赞同。不过要是说世界的节奏和变化速度越来越快，我是要默然颔首的。</p><p>其实这一篇本质上有标题党的嫌疑，因为今年看的书实在太少太少，当然后面我也会解释今年看书少的<del>借口</del>原因。不过，看过<a href="http://maples7.com/tags/书单/">我前几年「书单」</a>的你肯定也知道了，我的书单系列只是用「书单」作为切入口，以此为契机来定期来聊聊我对这个世界的看法而已。虽然我也有要时常更新我的博客的想法，但事实就是总有一些手头上新奇的、或者我认为更重要的事情占据着我的时间，以致于目前这里几乎成了一个年更博客，这确实很不应该。但好在我依然还有年更「书单」这个保留节目。</p><p>Anyway，这依然首先还是一个「书单」，所以我们还是会从正题开始。</p><a id="more"></a><ol><li><p><a href="https://book.douban.com/subject/34838232/" target="_blank" rel="noopener">新婚之夜</a>：★★★★☆</p><p>不得不说，我很喜欢这几个中短篇故事，我觉得这才是真正给现代人看的文学作品。作者把细腻的情绪和世界的真实都潜藏在故事情节里，「给残酷的内核外面涂一层奶油」，以至于我会觉得在北京这样的城市路上遇到的每一个人背后都可能有一段类似书里描绘的故事。推理和悬疑的要素也大大增强了故事的可读性。</p><p>第二篇《模特》也看过 2019 年扩展的中篇电子版，故事叙述方式和人物刻画都比出版的这一版明显更好。</p><p>很喜欢作者讲故事的风格，如果长期坚持写作，应该很有潜力能写出更优秀的作品。</p></li></ol><ol start="2"><li><p><a href="https://book.douban.com/subject/5354957/" target="_blank" rel="noopener">扶桑</a>：★★★★</p><p>整个故事的结构和完整性都还不错，也比较有新意。从叙事人的视角来讲这个故事我觉得是个加分项，给了这个故事更多的现实寓意和文化内涵。整个读下来，前面部分会感觉略微零碎而不够畅快，但后面慢慢把拼图拼起来之后会觉得这确实还是一个好故事。</p></li><li><p><a href="https://docs.python.org/3/tutorial/index.html" target="_blank" rel="noopener">The Python Tutorial</a>：★★★★☆</p><p>自从大学期间看完《Dive into Django》和《Learn Python the Hard Way》之后，中间间隔了很长一段时间没有再使用 Python，几乎已经忘得差不多了。尽管在近两三年的工作中又有几个 Python 数据处理相关的项目，但总感觉自己在 Python 方面的理解还不够系统，所以打算再系统的学习学习，同时也看看一些新特性。任何编程语言的官方文档总不会太差，如此大众的 Python 自然也不让人失望，任何想入门的人都可以且应当从这篇文档开始作为学习的内容之一。</p><p>BTW，大体上我不赞同 learn something the hard way 的学习方式。</p></li><li><p><a href="https://book.douban.com/subject/26752026/" target="_blank" rel="noopener">聪明的投资者</a>：★★★★</p><p>堪称价投宝典，虽然很多具体的事例都已经过时，但投资的大道却永远不过时（主要是第 1、8、20 章），同时这个版本的点评章节也很好的弥补了这方面的不足。投资的确是个体认知能力和认知水平的直接变现行为。</p></li><li><p><a href="https://book.douban.com/subject/27614523/" target="_blank" rel="noopener">刷新：重新发现商业与未来</a>：★★★☆</p><p>入职微软之前看完了这本书，写得很朴实。从个人经历来说，并没有过分强调自己的努力和付出，也准确表达了顺应趋势在对的时间出现对的地方的重要，同时家庭经历的曲折带给了他更多对于同理心的思考；从公司的层面来说，坦诚微软在当时需要一次文化变革，重新刷新自己，目前看来确实正在扭转颓势；最后谈了谈对未来技术的认识，跨国企业应当是有全球视野和使命感的。</p></li><li><p><a href="https://book.douban.com/subject/25910559/" target="_blank" rel="noopener">剑指Offer：名企面试官精讲典型编程题</a>：★★★★</p><p>根据我面试别人和被面试的经验来看，这本书包含了一个合格程序员应该掌握的容易被总结和教材化的基础知识和技巧，针对很多公司已经套路化的面试流程而言的确是有效的。但它依然只是《骗分导论》一般试图突击走捷径的存在，不能作为修炼编程内功和计算机科学素养的考纲。仅对于找工作来说，是必要不充分条件。</p></li><li><p><a href="https://msl.overdrivechina.cn/media/5690793" target="_blank" rel="noopener">Learn .Net Core: .NET Core Tutorial</a>：★★★</p><p>一本非常短小的小册子，适合有其他语言编程经验的人熟悉 .NET 世界的 basics and fundamentals，以图一两天快速建立一个整全观。基本没有什么更深入的细节。</p></li></ol><p>没了。</p><p>如前面提到的，今年看书时间不多的<del>借口</del>原因大概来自于这样几个方面：</p><ol><li><p>换工作和城市，入职微软中国（苏州）。</p><p>从更新简历开始，到投递面试、确认 Offer、从北京离职，最后跨城市搬家、入职、新员工培训、自学一些相关的技术等等，这其中每一个步骤都需要耗费大量的时间和精力。而且微软是我目前为止遇到的入职流程最漫长的公司，毕竟其中的背景调查就耗费了三周到一个月的时间，处处显示着跨国大公司的规范与严谨。如果以后有机会，我也可以在博客或其他社交平台上分享更多在微软的经历。</p><p>舍弃旧的环境和已经熟知的工作流程、技术规格和项目，从零开始投入到一个全新的体系里，有太多的新东西需要学习，这不仅仅包括作为开发者所必须掌握的技术相关的知识（在微软 C# / .NET 对于大多数开发者都是必须的，而在此之前我接触得并不多），还有一些事关企业文化、规范、工作流程和团队协作上的软技能的准备。而在像微软这样一个历史悠久的跨国企业里，项目和用户规模都十分庞大（意味着对项目稳定性要求格外高而无法快速变化），项目历史也十分悠久（十几二十年的代码，legacy code 不少），对于这些已经世界级的产品，想要短时间内掌握清楚基本不现实。我的 manager 就曾告诉我，新入职员工基本都需要经过一年到一年半的时间才能对项目上手，这本身就是一个不小的挑战。</p><p>所以更多的时间还是放在了跟工作内容相关的知识的学习上，这不是几本书就可以简单概括的。</p></li><li><p>东航「周末随心飞」。</p><p>一场突如其来的传染性肺炎疫情让所有人都猝不及防，航空公司们为了自救而推出了「随心飞」这样的产品，首先从东航的「周末随心飞」开始。在今年这样的情形下，对于航空公司来说这确实是一招不错的棋，而对于大部分产品购买者来说其实也并不亏。所以借着这样的契机，同时得益于微软讲究 work-life balance 的工作节奏和假期福利，今年我也着实好好<del>在国内到处蹦跶了一下</del>领略了一把祖国的大好河山。最值得一提的当属十一假期前后去了西北一线，包括银川、兰州、青海大环线的南半边、可可西里，确实看到了极其壮阔瑰丽的大漠景观。除此之外，还去了潮汕、长沙（两次）、西安、三亚、济南，也是一年难得的经历。</p><p>为了不辜负路上的美景，今年还购入了无人机和微单来作为拍摄器材，<a href="https://maples7.tuchong.com/" target="_blank" rel="noopener">拍了不少照片</a>。我想，要彻底消化完我这个重燃的新兴趣点也是需要不少时间的投入的。</p><p>所谓「要么读书，要么旅行，身体和灵魂必须有一个在路上」，至少今年身体还在路上。曾经为了让自己能多出门走动、不要太宅，也制定过「希望自己周末一半的时间能出门」这样的年度计划，至少今年应该是实现了这个前几年的想法。</p></li><li><p>上完了<a href="https://cs50.harvard.edu/" target="_blank" rel="noopener">著名的 MOOC Harvard CS50x</a>。</p><p>这门课其实我在大学时期就上过一部分。虽然只是哈佛的一个计算机相关的通识基础课，但由于制作的实在太好，内容又相当丰富，我不忍心这么好的课程自己没有全部看完，于是在今年又从头到尾全部过了一遍。尽管对于我这个从业者来说没有什么新鲜的「干货」，但它却是我上过的体验最好的 MOOC。除了哈佛的明星教授 David Malan 精彩的授课讲解，也有制作得非常有层次的课后作业，最后的大作业甚至是独立开发一个完整的应用，这是少有的让我觉得参与起来非常有意思的一门课。实际上，这门课已经成为了一个独立的品牌，有一系列相关的网站、后续课程和工具集供你在 CS50 的海洋里遨游。所以也建议开发者或者对计算机知识感兴趣的人去听听这门课。</p><p><a href="http://maples7.com/2019/12/31/2019-booklist/">去年的「书单」</a>我就提到了<a href="https://github.com/Maples7/cs-roadmap" target="_blank" rel="noopener">我整理的学习 Computer Science 的资源和路径列表</a>，这门课目前就是我列在 Fundamentals 类目下第一位的课程。所以上完这门课也是我遵循去年立下的深入系统有节奏的学习世界顶尖的计算机相关课程的计划之一。这其实也比简单看完几本书需要花费更多的时间和精力。</p></li><li><p>外部环境、事件的影响，包括新冠疫情。</p><p>说 2020 年是不可能脱离新冠疫情这个大的背景调查来谈的，它已经成为了 2020 年的标签和底色。疫情在今年或多或少的影响了地球上的每一个人，外部环境的剧变需要每一个个体有更加坚定的自我才能在自己的道路上继续走下去。我以前就写过，环境对人的影响往往被低估，相信今年的情况提升了很多人对于环境影响的认知。它或许不能完全左右你的方向，但绝对可以让你的每个动作都充分扭曲变形。这历历在目的一年，相信身处其中的每个人都深有体会，无须多言。</p></li></ol><p>其实从个人角度来说，今年对于我自己算是不错的一年，因为它足够丰富，这主要来源于在微软工作我会有更多时间投入到各种各样不同的我想要投入的事情上去，比如写一些自己想写的代码，比如对新技术的学习、投资领域的深入、其他兴趣爱好的培养等等。往年的「书单」或多或少我都会夹杂着一些「湿货」，以阐述我的世界观的某个部分，但今年这篇我想就保留这样简单平实的记述风格。已经是太不容易的一年了，就给我自己和看到这篇的你留个气口吧。</p><p>另外感谢 12 月有 31 号，让我还有充分的时间来完成这篇「书单」。最后，强烈推荐看到这里的你静下来听一听声动活泼旗下的这期播客：<a href="https://mp.weixin.qq.com/s/IBp5eQ8kggFyi6Egq4VnIQ" target="_blank" rel="noopener">《请收下这枚记录2020的声音时光胶囊》</a>。</p><p>「历史就算会反复，但一定会向前走的」，2020 年是需要很多感性力量的一年，现在我们又来到了一个新的时间节点，故事还将继续，只愿世界和平。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020 年，是一个太魔幻的一年（什么？你不知道为什么会这么说？好吧，如果你来自未来，本文末尾有一期推荐的播客可以听一下），甚至很有可能还是「魔幻元年」。那句话怎么说的来着：今年是过去十年最差的一年，却可能是未来十年最好的一年。当然，认真地讲，我并不完全赞同。不过要是说世界的节奏和变化速度越来越快，我是要默然颔首的。&lt;/p&gt;&lt;p&gt;其实这一篇本质上有标题党的嫌疑，因为今年看的书实在太少太少，当然后面我也会解释今年看书少的&lt;del&gt;借口&lt;/del&gt;原因。不过，看过&lt;a href=&quot;http://maples7.com/tags/书单/&quot;&gt;我前几年「书单」&lt;/a&gt;的你肯定也知道了，我的书单系列只是用「书单」作为切入口，以此为契机来定期来聊聊我对这个世界的看法而已。虽然我也有要时常更新我的博客的想法，但事实就是总有一些手头上新奇的、或者我认为更重要的事情占据着我的时间，以致于目前这里几乎成了一个年更博客，这确实很不应该。但好在我依然还有年更「书单」这个保留节目。&lt;/p&gt;&lt;p&gt;Anyway，这依然首先还是一个「书单」，所以我们还是会从正题开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浮生散记" scheme="http://maples7.com/categories/%E6%B5%AE%E7%94%9F%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="书单" scheme="http://maples7.com/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>「必然」有多必然？</title>
    <link href="http://maples7.com/2020/05/19/how-certain-is-certain/"/>
    <id>http://maples7.com/2020/05/19/how-certain-is-certain/</id>
    <published>2020-05-19T14:10:20.000Z</published>
    <updated>2021-11-13T04:56:40.085Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看美剧《高堡奇人》（<em>The Man in the High Castle</em>）第四季，也是最终季。整个剧是基于 Philip K. Dick 的同名长篇小说改编的，也是这部作品创造了一种「架空历史」的新的科幻作品类型，剧情大致是基于纳粹德国和日本天皇打赢了二战，共同统治了世界之后的人类历史发展。值得一说的是，这部小说是 1962 年写的。作为 2020 的人类，我们早已习惯了第二次世界大战同盟国胜利之后的历史，但这部小说带给了我们这样一种思考，这种已经发生的历史是一种冥冥之中的「必然」吗？</p><p>当然，历史是经不起假设的，这个宇宙到底存不存在平行时空人类目前也不甚清楚。在这里，我并不是想讨论历史，也不是想讨论科幻，而是想讨论某个事件发生的必然性到底有多「必然」的问题。并不像大多数人以为的那样，人类的潜意识其实非常习惯于从某个结果来抽象总结出事情发生的原因，习惯于找出其中存在的一系列因果关系的逻辑链条而忽视次要因素，从而把事情化繁为简存储在自己的经验模型库之中。人性使然，已经获得成功的人也会不自觉的从自身的成功中总结经验并加以传授，告诉人们你们这样做也可以像我一样成功，这不禁也让人怀疑，成功学有必然性吗？</p><a id="more"></a><p>最近我还从<a href="https://zh.wikipedia.org/wiki/梁文道" target="_blank" rel="noopener">梁文道</a>的播客<a href="https://shop.vistopia.com.cn/detail?id=4z4Ew" target="_blank" rel="noopener">《八分》</a>的<a href="https://shop.vistopia.com.cn/article?article_id=vG_Cc" target="_blank" rel="noopener">第 203 期节目</a>中听到这样一个故事（道长的这期节目本来是在探讨人性中善良的部分的问题），长篇小说<a href="https://zh.wikipedia.org/wiki/蝇王" target="_blank" rel="noopener">《蝇王》</a>讲了一群小孩被困荒岛在没有成人引导的情况下如何建立起一个脆弱的、充斥着野蛮与暴力的文明体系的故事，基本是社会达尔文主义的荒岛实验版本，充分揭露了人性中的恶。小说是虚构的，然而<a href="https://zh.wikipedia.org/wiki/瑪格麗特·米德" target="_blank" rel="noopener">人类学家 Margaret Mead</a>在《Humankind: A Hopeful History》中却写了一个真实的有类似情境却完全不同结局的故事：六个偶然迷失在无人岛上的小孩通过合作、民主、和平的方式生存下来活了十五个月的故事。Margaret Mead 企图用这个真实的故事说明人类本性中除了有自私的天性以外同时也有一种互助友爱的天性。但以此就可以推翻虚构的小说《蝇王》所描写的那个故事的可能性吗？人类是一种相当复杂的动物，我们既能看到《蝇王》小说中的恶，也可能看到如童话般的善，真实的人类社群更是一个庞大的复杂系统。</p><p>所以已经发生的「必然」到底多必然？</p><p>有无数的历史教材告诉我们历史中某些重大事件的发生是某种趋势的必然结果，彷佛世界的发展有一张无形的手在推动着前进，我们也无数次听到「即便现在某个人/某件事不出现/发生，这样的历史时刻/趋势/潮流之下也会诞生另一个某某人/发生同样的某某事」这样类似的说法，彷佛条件到了该来的一定会来。人类自古以来就希望拥有预测未来的能力，玩狼人杀拿到预言家的身份都会精神几分，从进化心理学的角度，这本质上源于人类对不确定性的恐惧。每个人都希望生活在稳定安全的环境之中，如果能有效预测未来，则可以为即将发生的事情做好万全的准备从而获得对自己有利的条件。</p><p>不言自明，预测肯定是基于当下的现实来产生的，是基于此时此刻这一秒的全部已经发生的现实，来预测未来某个时刻将要发生的现实。首先，没有人可以同时了解到此时此刻的全部现实，即便我们假设现在可以采集到所有的现实数据，那接下来发生的事情就可以预测了吗？仔细思考，你会发现这里存在一个悖论，即未来被预测这件事情会不会影响对未来的预测。按理说，预测未来这件事同样也是当下的现实，应该也会对未来事件的发生产生影响。所以准确预测未来还可行吗？不得而知，我无法给出任何可信的答案或思考。回到现实，既然准确的未来还无法预测，那预测出事件的大致走向/趋势/潮流是不是可行呢？</p><p>各个行业中都有一些传奇励志的成功故事，互联网创投圈中更是如此，都说互联网是个年轻人的行业，有众多年轻的互联网新贵因为把握住了行业发展的潮流和趋势年纪轻轻就已经实现了很多人追求的所谓财务自由。那么，他们真的是因为提前看到了趋势和机会才成功的吗？当然，不排除真的有人有意识且主动地看到了趋势和机会，但肯定也有不少人主要是凭借运气做成了某件事情（在其他条件相同的情况下，这包括主观能动性的程度）。更进一步的问题是，能看到趋势和机会是因为什么？这其中又有多少偶然和运气呢？</p><p>当然，同样地，我们也不能陷入到一种虚无主义和怀疑论的情绪当中去。人类世界是一个混沌的复杂系统，事情之间环环交织，它们一起构成了一个已经发生的当下的「偶然」，一部分相互交织的「偶然」子集又相互作用和相互影响，为下一个「偶然」的发生提供作用和条件，而我们的主观能动性，同样也是其中的一部分「偶然」，同样对事件的发生产生影响。由于股票市场是不可预测的（这基本也反映了现实世界的不可预测性），很多价值投资者都崇尚用「概率」和「非线性」的思维方式来思考问题，从而通过更合理地布置仓位和设计操作策略来实现最终的盈利。我们在实际生活在也可以学习这种思维模型来应对不可预知的未来世界，首先要充分认识到世界的不可预测性并基于真实世界没有简单的因果关系的前提，不要用简单机械线性的思维和视角来分析问题，这样可以减少一些偶然被你感知到的噪音对你的影响，从而总是能依据自己的理性判断对不同概率下的可能的未来做出符合可能性的准备，进而做出一个当下最优的决策。</p><p>2020 年是一个太不平凡的一年，突如其来席卷全球的新冠疫情、本身已经变得脆弱的世界政治经济局势等等，人类似乎又站在了一个暴风雨的前夜，你能预测世界接下来的走势吗？</p><p>我想我是得看一些关于复杂系统理论的书了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看美剧《高堡奇人》（&lt;em&gt;The Man in the High Castle&lt;/em&gt;）第四季，也是最终季。整个剧是基于 Philip K. Dick 的同名长篇小说改编的，也是这部作品创造了一种「架空历史」的新的科幻作品类型，剧情大致是基于纳粹德国和日本天皇打赢了二战，共同统治了世界之后的人类历史发展。值得一说的是，这部小说是 1962 年写的。作为 2020 的人类，我们早已习惯了第二次世界大战同盟国胜利之后的历史，但这部小说带给了我们这样一种思考，这种已经发生的历史是一种冥冥之中的「必然」吗？&lt;/p&gt;&lt;p&gt;当然，历史是经不起假设的，这个宇宙到底存不存在平行时空人类目前也不甚清楚。在这里，我并不是想讨论历史，也不是想讨论科幻，而是想讨论某个事件发生的必然性到底有多「必然」的问题。并不像大多数人以为的那样，人类的潜意识其实非常习惯于从某个结果来抽象总结出事情发生的原因，习惯于找出其中存在的一系列因果关系的逻辑链条而忽视次要因素，从而把事情化繁为简存储在自己的经验模型库之中。人性使然，已经获得成功的人也会不自觉的从自身的成功中总结经验并加以传授，告诉人们你们这样做也可以像我一样成功，这不禁也让人怀疑，成功学有必然性吗？&lt;/p&gt;
    
    </summary>
    
    
      <category term="浮生散记" scheme="http://maples7.com/categories/%E6%B5%AE%E7%94%9F%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="人生" scheme="http://maples7.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
      <category term="必然" scheme="http://maples7.com/tags/%E5%BF%85%E7%84%B6/"/>
    
      <category term="哲学" scheme="http://maples7.com/tags/%E5%93%B2%E5%AD%A6/"/>
    
      <category term="复杂系统" scheme="http://maples7.com/tags/%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>2019 年书单</title>
    <link href="http://maples7.com/2019/12/31/2019-booklist/"/>
    <id>http://maples7.com/2019/12/31/2019-booklist/</id>
    <published>2019-12-30T17:15:33.000Z</published>
    <updated>2021-11-13T04:56:40.085Z</updated>
    
    <content type="html"><![CDATA[<p>2019 年对很多人来说似乎是艰难的一年，在这个世界愈发趋于动荡和不信任的大背景下，越来越多的疑惑、迷茫和不确定性从上至下笼罩在每一个人可以感知到的日常生活中。或许只是一种周期，或许就是一种趋势，各种事物的分化与混乱变得越来越明显。如果从热力学第二定律的角度来看，维持事物不走向无序是需要额外付出很多努力的，那说明人类社会目前做的共同有效努力还不够；如果从唯物论的发展观来看，事物总是螺旋式向上发展的，周期中同时也蕴含着一些不可逆的改变。把 2019 年放在历史的长河中，我不知道它处在世界发展周期的哪个部分，但很可能不是在「好」（大部分人认为的世俗意义上的「好」）的那一半。这可能是前些年某些事件的发生导致了现在的局面，同时也可能是未来很长一段时间不同局面的开始。</p><p>我所感知到的 2019 年，不算好，但好过 2018 年，因为在 2019 年明显可以看到一些好的发展的希望。事情多不一定会让人感觉到累，但感受不到希望是一定会让人想要逃离的。不过，希望仅仅是一种未来往好的方向发展的可能，当变化越来越快的时候，希望也是越来越脆弱的，希望远不是必然。</p><a id="more"></a><p>忽视我以上开场想当然的臆测和主观感受，这依然是一篇书单。</p><ol><li><p><a href="https://book.douban.com/subject/27006467/" target="_blank" rel="noopener">浮生六记</a>：★★★★</p><p>博客有一个分类是「浮生散记」，是出自沈复的《浮生六记》。</p><p>沈复一生困苦却用白描的方式把自己的故事一一记述下来，文采自然、平淡、真切，从中也可以看出他一介浪荡文人性格上的懦弱无能。</p><p>喜于与芸娘的几年四处游历、相濡以沫、互相扶持，悲在芸娘一生操劳、心思忧虑、英年早逝。</p></li><li><p><a href="https://book.douban.com/subject/26997048/" target="_blank" rel="noopener">撒哈拉故事</a>：★★★★</p><p>仅仅用一个略带嘲讽和贬义的「文青」来形容三毛或三毛的粉丝们是不公平的。三毛写的就是平凡的生活和真实的自我，在世界各地的每个人都有这样的生活，只是不是每个人都能够成为三毛，不是每个人都能写出这样的文字。热爱生活本身，已是足够。</p></li><li><p><a href="https://book.douban.com/subject/30455321/" target="_blank" rel="noopener">流浪地球</a>：★★★</p><p>在看电影之前先看了原著，一个短篇基本把宇宙设定和故事框架搭建了出来，但这么点文字不足以支撑整个故事宏大的背景设定，所以人物、情节和要表达的背后的东西都很符号化。不过，也许正是短小且符号化的文学作品利于被 100 分钟左右的影视化表达所改编，如果是<a href="https://book.douban.com/subject/6518605/" target="_blank" rel="noopener">《三体》</a>这样的长篇，要改编成一部（系列）成功的电影，难度会大上很多。</p></li><li><p><a href="https://book.douban.com/subject/6709783/" target="_blank" rel="noopener">浪潮之巅</a>：★★★★☆</p><p>任何计算机和互联网从业者都应该读的一本书，前后几次再版的内容变化甚至都可以看出近几年行业的变迁与发展（之快）。</p><p>关于 Stanford 和硅谷之间的关系的章节尤其赞同，可以说国内所谓的高等教育还没找到门在哪里。</p><p>从整个行业历史长河的远景角度下来看，企业宿命论的观点是有道理的，创始人的特质基本上决定公司在世事变迁之中能走到多远。</p></li><li><p><a href="https://elixirschool.com/zh-hans/" target="_blank" rel="noopener">Elixir School</a>：★★★☆</p><p>适合入门，但感觉比 Elixir 官网的 start guide 对知识的系统性和章节前后编排的组织合理性要差一些，优点是更偏项目实践，涵盖的面更广。</p><p>中文翻译有一些问题，给这个项目提了一些翻译方面的 PR。</p></li><li><p><a href="https://elixir-lang.org/getting-started/introduction.html" target="_blank" rel="noopener">Elixir: Getting started guid + Mix and OTP guide + Meta-programming guide</a>：★★★★☆</p><p>官方文档绝对是入门 Elixir 的首选材料，内容编排和话题讲解都恰到好处又直击要害，完全值得多读几遍。</p></li><li><p><a href="https://book.douban.com/subject/26910174/" target="_blank" rel="noopener">上海堡垒</a>：★★★★</p><p>中学生科幻文学，前面多半部分是移动互联网时代之前的「高三」风格（比「中二」强一点），之后部分的行文流畅真切了许多，结尾还不错。在外星人入侵的弘大灾难背景下的朴素稚嫩而又执拗的少年情愫，科幻设定不硬，人物描绘质朴，倒是带来些许恍若隔世的违和感，跟江南在《此间的少年》中营造出的猎奇轻狂的趣味感一脉相承而又截然不同。</p><p>在同名电影上映之前先看一看原著，又是一部比《三体》更适合影视化表达的作品。</p></li><li><p><a href="https://book.douban.com/subject/25816940/" target="_blank" rel="noopener">富爸爸穷爸爸</a>：★★★★</p><p>认清资产和负债的确至关重要，这能让大多数普通人避开「中产阶级陷阱」。拿到当下现实而言，纯粹从财务的角度，那些签下 30 年贷款协议买房的人买下的绝不是资产而是负债。</p><p>每个人从大学毕业开始最原始的资产就是自己的工作能力和时间，上班本质上是出卖自己的时间和工作能力来获取货币资产。而财务自由的过程实际上是不断用新的资产形式来置换出卖劳动的过程，最终目标也就是即便不受雇工作也可以靠其他资产产生的收入来负担所有的支出，接下来就只需要不断的滚雪球就可以越来越富有。</p><p>一本经典的资产管理入门书，跟之前看过的<a href="https://book.douban.com/subject/26835090/" target="_blank" rel="noopener">《软技能：代码之外的生存指南》</a>关于投资的内容遥相呼应、相得益彰。道理其实简单，但能做到的人永远寥寥。</p></li><li><p><a href="https://book.douban.com/subject/27204860/" target="_blank" rel="noopener">指数基金投资指南</a>：★★★★</p><p>简直是手把手带领小白入门指数基金定投，有简单的理论也有实践操作，事无巨细，甚至包括了一些记账习惯、健康消费、投资心理等相关的内容，实用性强，内容也很诚恳，很适合零基础开始投资理财的读者。</p></li><li><p><a href="https://book.douban.com/subject/10471333/" target="_blank" rel="noopener">叫魂</a>：★★★★</p><p>从小到大就不喜欢看历史书，觉得历史很枯燥，这大概是义务教育阶段历史教材上笼统的描述和专断的结论所熏陶出来的厌恶感。</p><p>但这本研究型作品却打破了历史的枯燥形象，看名字会以为内容是些鬼怪之谈，实际上这是一本非常严谨的学术著作。从乾隆年间的一场历史事件深度细腻的剖析了当时社会的状态和事件里各个社会群体及角色的举动和反应，最有意思的部分还是对舞台中央的君臣之间微妙关系的分析以及这背后所展现的官僚君主制的探讨。</p><p>作者作为外国学者，更是提供了一些在国内不常见的看待这段历史的视角，以及跟当时西方体制的一些对比分析，写得颇为生动精巧。一本上世纪写就的学术著作，如今看却也一点也不觉得过时。</p></li><li><p><a href="https://book.douban.com/subject/25897187/" target="_blank" rel="noopener">Elixir in Action</a>：★★★★☆</p><p>相信绝大部分人的第一门编程语言都不是 Elixir，那这本书就非常适合作为 Elixir 入门的读物。它没有陷于形式和细节，而是非常清晰的把 Elixir 核心和关键的部分由浅入深地勾勒了出来。行文逻辑和章节编排也非常合理，读起来流畅自然，体验非常舒适。简直是 Elixir 必知必会十三章。</p></li></ol><p>今年看的书并不多，但有两个我觉得比较有意思、有意义且也许会对我自己影响深远的事情值得写在这里。</p><p>其中一件是我终于汇总和总结了学习 Computer Science 的资源和路径，可以<a href="https://github.com/Maples7/cs-roadmap" target="_blank" rel="noopener">在我的 GitHub 上找到这个仓库</a>。学习本身是一件非常私人且定制化程度很高的事情，就像<a href="https://en.wikipedia.org/wiki/No_Silver_Bullet" target="_blank" rel="noopener">软件工程里没有「银弹」</a>一样，我从不觉得有适合每个人的最好的学习路径，但我把我觉得最好最合适的一些课程和书籍等资源列了出来。系统的总结出来这件事情本身在大学期间我就应该做了，这些年虽然没有在纸面上写下来，但也一直尽可能遵循这样的路径来系统的学习计算机科学的课程。不过没有纲领就容易丧失节奏，现在做这件事算是补交一下四五年前的作业，同时我自己今后也会更明确的按照这个列表来一步一个脚印的深入学习下去。这可是一个以「年」为单位来审计的大工程，我自己觉得很有意义。</p><p>另外一件其实我在<a href="http://maples7.com/2018/12/31/2018-booklist/">去年的书单总结中</a>提到了，但并没有明确说是什么事情。可今年的书单已经暴露了它是什么，那就是开始比较系统性地学习和实践个人理财和投资。大概是不到两年前的一个非常偶然的机会我开始接触并尝试投资这个事情，我才发现其实很多人（包括以前的我自己）都对个人理财和投资存在着大量的误解，这绝对是值得每一个年轻人深入研究的一个领域，而且越早越好，因为它几乎跟编程一样会以非常潜移默化的方式从根源上影响你今后的思维方式。我当然不会在这篇博客来详细说明这是为什么（或许以后会写一写），但我会在这篇年终书单来提四个现在的我认为的最重要的投资思维。投资思维并不仅仅只能用于投资，在很大程度上，它们可以用于个人参与社会生活的方方面面。在可以预见的今后一段时间内，这四个词都会成为我微信个性签名的一部分，以此来时刻提醒自己：</p><ul><li><p>价值：价值思维强调你需要深入事情的本质，这是最基础且根本的。研究一只股票，首先要看的就是它背后的企业在目前的基础上未来能产生的盈利价值。泛化来说，我们应该永远都回归事物的本源，用最根本最核心的内在逻辑来看待、思考和决策一切和我们相关的事情。能看到核心价值并不是一件简单的事情，但这必须是我们一直追求和崇尚的。放到一家公司来说，追求核心价值要求他们能持续将资源投入到能真正解决社会问题的事情上去，回归商业的本质，而尽可能不被一时的创业潮流和资本热度所左右。这个最根本的事情大多是公司为什么而创业的原因，也是一家公司存在的根本价值。在越是困难的时期，回归到真正的价值追求会显得愈发重要，因为在退潮时你才更容易看清之前水面下的到底都是些什么东西。</p></li><li><p>概率：概率思维是很多人严重缺失但又非常重要的一种思维方式，它能够告诉你没有什么事情是必然的，也没有什么事情是一定不会发生的。所有未来的事情在还没有发生的时候都是概率的，这些事情一起构建成为了「薛定谔的未来」。用这个思维来投资，它能帮助你在任何时刻准确的控制你的仓位情况，包括哪些投资标的和怎样的分配比例，同时也让你对任何未来可能的情况有所心理上的预计并做出计划和准备，在任何事情发生后都不会因为一时脑热、害怕或恐惧而做出错误的决策。错误的代价往往被低估，在投资的世界里尤其明显，不出错基本就已经可以在可量化的游戏里打败大多数人了，如何保证自己不出错是需要每个人思考的基本的问题。世界永远是概率的，这是目前唯一可以确定的事情。</p></li><li><p>长期：长期思维可以让投资者避免因短视而带来错误。人类往往容易放大眼前发生的事情带来的影响，而低估长期趋势在未来产生的作用。把孤立的事情放到一个长期变化的过程中去看，也更容易看到事情的本质。这也会成为你做出正确投资决策的基础：浮亏时，你能知道什么时候需要继续坚持，而什么时候要懂得及时止损；浮盈时，你能尽可能最大化自己的最终收益。人的一生对每个人而言也是一个长期的过程，不必因为一时的得失而或喜或悲，保持平常心对个人保持一个良好的日常状态非常关键，这也是我之前一直揣摩且追求的「个人 2016 年状态」。</p></li><li><p>非线性：非线性思维能让你避免用简单机械的方式来思考。不要觉得事情都是在简单线性发展的，不要认为努力就一定要成功且会成功，不要用静态陈旧的观念来看待和衡量周围的事物。这跟我在去年的书单总结中说到的「顿悟」的习得方式有共通之处。不要因为事情的突然失败、成功或发生而感到惊讶，有太多个人无法决定的偶然因素在相互交织产生影响，现实生活中真正复杂的系统一定是非线性的，这几乎同时暗示了物理世界「永远不存在绝对完美的事物」的残酷真相。</p></li></ul><p>理论终归只是理论，实践中很难做到完美，但完美依然值得追求。或许未来我的博客也会增加一个「滚雪球」的分类来记录一些我个人的投资感悟。</p><p>最后，站在这个看似艰难的 2019 年的尾巴上：愿世界依旧值得被好奇，愿自己依然能常怀热爱。我们一起来迎接人类下一个云谲波诡而又风景迤逦的十年的开始。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019 年对很多人来说似乎是艰难的一年，在这个世界愈发趋于动荡和不信任的大背景下，越来越多的疑惑、迷茫和不确定性从上至下笼罩在每一个人可以感知到的日常生活中。或许只是一种周期，或许就是一种趋势，各种事物的分化与混乱变得越来越明显。如果从热力学第二定律的角度来看，维持事物不走向无序是需要额外付出很多努力的，那说明人类社会目前做的共同有效努力还不够；如果从唯物论的发展观来看，事物总是螺旋式向上发展的，周期中同时也蕴含着一些不可逆的改变。把 2019 年放在历史的长河中，我不知道它处在世界发展周期的哪个部分，但很可能不是在「好」（大部分人认为的世俗意义上的「好」）的那一半。这可能是前些年某些事件的发生导致了现在的局面，同时也可能是未来很长一段时间不同局面的开始。&lt;/p&gt;&lt;p&gt;我所感知到的 2019 年，不算好，但好过 2018 年，因为在 2019 年明显可以看到一些好的发展的希望。事情多不一定会让人感觉到累，但感受不到希望是一定会让人想要逃离的。不过，希望仅仅是一种未来往好的方向发展的可能，当变化越来越快的时候，希望也是越来越脆弱的，希望远不是必然。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浮生散记" scheme="http://maples7.com/categories/%E6%B5%AE%E7%94%9F%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="书单" scheme="http://maples7.com/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>Elixir 代码性能优化指北</title>
    <link href="http://maples7.com/2019/12/05/elixir-code-performance-optimization/"/>
    <id>http://maples7.com/2019/12/05/elixir-code-performance-optimization/</id>
    <published>2019-12-05T13:20:20.000Z</published>
    <updated>2021-11-13T04:56:40.084Z</updated>
    
    <content type="html"><![CDATA[<p>Elixir 作为基于 Erlang/OTP 的年轻语言，拥有良好的并发模型设计，在 Web 场景下对于实现能承载高并发的服务毫无问题。有好事者<a href="https://github.com/mroth/phoenix-showdown" target="_blank" rel="noopener">对比过包括 Phoenix 在内不同的 Web Framework 的性能</a>，可见如果采用 Phoenix/Plug 来实现 Web Server 在性能上不会有太大的问题（代码实现良好的情况下）。所以，本文不会讨论真正的工业生产环境下整个系统的性能状态，因为系统性能受到很多因素的影响，具体编程语言的运行时的执行效率往往不是真正的问题所在，与其考虑编程语言本身的运行时效率，不如探讨系统在具体架构和实现上如何能优化来承载更高的负载来得实际。在生产环境中，我们可以借助 <a href="https://zh.wikipedia.org/wiki/应用性能管理" target="_blank" rel="noopener">APM</a> 服务来监控系统状态和性能指标。</p><p>由于 Elixir 本身是基于 Erlang 的更高层次的抽象，所以直觉上我们会觉得 Elixir 在运行性能上应该比 Erlang 本身要差一些。实际情况是不是这样呢？Elixir 相比于 Erlang 而言，为我们提供了一些可以快速调用的高阶函数库，典型的有 <a href="https://hexdocs.pm/elixir/Enum.html" target="_blank" rel="noopener"><code>Enum</code></a>、<a href="https://hexdocs.pm/elixir/Stream.html" target="_blank" rel="noopener"><code>Stream</code></a>，提高了日常实现需求的开发效率，可以让代码实现得更清晰且更易维护。而更高的抽象又几乎必然意味着底层的实现逻辑需要更通用健壮，从而也会更复杂。更高的抽象程度似乎天然与更高的运行效率有着内在的矛盾。本文的焦点在 Elixir 代码的运行性能，即对于实现同样的功能，用哪样的 Elixir 实现方式会让代码在运行时跑得更快。</p><a id="more"></a><p>接下来会拿我在刚接触 Elixir 时实际开发过程中真实写出来的代码来举例如何进行优化，相信不少 Elixir 新手会跟当时的我一样或多或少犯类似的错误。源代码可以在这里找到：<a href="https://github.com/seniverse/ex_fieldmask" target="_blank" rel="noopener">ex_fieldmask - GitHub</a>，通过项目的提交历史也可以看到我的修改过程，整个代码才一百多行，改动也都很简短，非常适合举例。这个库实现的需求是用简单的字符串解析的方式来实现类似 <a href="https://developers.google.com/youtube/v3/getting-started#partial" target="_blank" rel="noopener">Google+/YouTube API 中的 Partial Responses</a> 的语法和功能。我会以这个代码仓库中的例子来举例能明显改善 Elixir 运行性能的实现改进，其他不会明显改善性能但是也会让代码更优的改动也会稍微提一下。我们从提交历史中从前往后挑选一些值得一提的 commits 来一一解说。</p><ul><li><p>判断值时，用 <code>case</code> 替换 <code>cond</code>：<a href="https://github.com/seniverse/ex_fieldmask/commit/913be4225298d9ef90f34727108d737ea5d7701c" target="_blank" rel="noopener">commit <code>913be42</code></a>。</p><p>改动前：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cond</span> <span class="keyword">do</span></span><br><span class="line">  keys === [] -&gt; data</span><br><span class="line">  keys === [<span class="string">"*"</span>] -&gt; ......</span><br><span class="line">  <span class="keyword">true</span> -&gt; ......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>改动后：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> keys <span class="keyword">do</span></span><br><span class="line">  [] -&gt; data</span><br><span class="line">  [<span class="string">"*"</span>] -&gt; ......</span><br><span class="line">  <span class="number">_</span> -&gt; ......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>解读</strong>：能用 <code>case</code>（或函数子句）的就不要用 <code>cond</code>。<code>cond</code> 适用于多个独立的表达式求值判断真假的情况，它需要从上至下对每个表达式求值直到遇到第一个值为「真」的分支。在这里，我们全部是关于 <code>keys</code> 的简单比较，显然用 <code>case</code> 直接模式匹配会是更优的实现。<code>cond</code> 里的 <code>true</code> 的 fallback 分支在 <code>case</code> 里可以用 <code>_left</code> 来对应变更用于匹配任意项。</p></li><li><p>函数用一个完整的 Pipeline 串联来提升可读性：<a href="https://github.com/seniverse/ex_fieldmask/commit/3e610d80b69be0015e376273806df9711427e701" target="_blank" rel="noopener">commit <code>3e610d8</code></a>，其他类似的改动还有 <a href="https://github.com/seniverse/ex_fieldmask/commit/fa039386be8b953e8ec927408a880301fc5283cb" target="_blank" rel="noopener">commit fa03938</a>。</p><p>改动前：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reveal</span></span>(tree, data) <span class="keyword">when</span> is_map(tree) <span class="keyword">do</span></span><br><span class="line">  keys = Map.keys(tree)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> keys <span class="keyword">do</span></span><br><span class="line">    [] -&gt; data</span><br><span class="line">    [<span class="string">"*"</span>] -&gt; ......</span><br><span class="line">    <span class="number">_</span> -&gt; ......</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>改动后：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reveal</span></span>(tree, data) <span class="keyword">when</span> is_map(tree) <span class="keyword">do</span></span><br><span class="line">  tree</span><br><span class="line">  |&gt; Map.keys()</span><br><span class="line">  |&gt;(<span class="keyword">fn</span></span><br><span class="line">    [] -&gt; data</span><br><span class="line">    [<span class="string">"*"</span>] -&gt; ......</span><br><span class="line">    <span class="number">_</span> -&gt; ......</span><br><span class="line">  <span class="keyword">end</span>).()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>解读</strong>：最后的匿名函数中的参数匹配跟 <code>case</code> 一样也是模式匹配，同样优于 <code>cond</code>，原代码中把 <code>case</code> 改成匿名函数的形式是为了让整个 <code>reveal</code> 函数是一个完整的用 <code>|&gt;</code> 串联起来的 Pieline 而又不失简洁，但性能上并不会明显更优。这样的改动更多是把命令式的代码风格改成函数式的代码风格，Pipeline 的每个部分都是独立无状态的，可读性和可维护性都会有所提升。</p></li><li><p>List/Tuple 直接用模式匹配取值：<a href="https://github.com/seniverse/ex_fieldmask/commit/801ff47c93f4b682bbd2f2997ee23ea7e98b6b6c" target="_blank" rel="noopener">commit <code>801ff47</code></a>。</p><p>改动前：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chars = elem(item, <span class="number">0</span>)</span><br><span class="line">delimiter = elem(item, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>改动后：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;chars, delimiter&#125; = item</span><br></pre></td></tr></table></figure><p><strong>解读</strong>：同样也是用模式匹配替代使用函数来取值，不仅让代码可以一行解决，而且还会提升性能。如果 List/Tuple 很长，而我们只需要提取前面一部分的片段，则又可以使用 <code>_tail</code> 来匹配我们不关心的尾部区域。</p></li><li><p>匿名函数用 <code>&amp;</code> 改写：<a href="https://github.com/seniverse/ex_fieldmask/commit/c19d49fed10e026b0ccd3cd27a77af8e4b7fa87d" target="_blank" rel="noopener">commit <code>c19d49f</code></a>。</p><p>改动前：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enum.filter(<span class="keyword">fn</span> str -&gt; str !== <span class="keyword">nil</span> <span class="keyword">and</span> str !== <span class="string">""</span> <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>改动后：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enum.filter(&amp;(&amp;<span class="number">1</span> !== <span class="keyword">nil</span> <span class="keyword">and</span> &amp;<span class="number">1</span> !== <span class="string">""</span>))</span><br></pre></td></tr></table></figure><p><strong>解读</strong>：无他，就是代码更简洁了，而且我们不再需要想如何给函数参数命名。<a href="https://martinfowler.com/bliki/TwoHardThings.html" target="_blank" rel="noopener">众所周知，命名在编程里是一件很难的事情……</a>（当然，只有在这种函数很简单的情况下值得这样做）</p></li><li><p>在函数参数中直接匹配复杂数据结构内部的值：<a href="https://github.com/seniverse/ex_fieldmask/commit/9af5145731aacfeac0e6e3826ee4c854c8550d6a" target="_blank" rel="noopener">commit <code>9af5145</code></a> 和 <a href="https://github.com/seniverse/ex_fieldmask/commit/456d3d4c4f26919055c18a7d2ff233437530f553" target="_blank" rel="noopener">commit <code>456d3d4</code></a>，其他相同原因的改动还有 <a href="https://github.com/seniverse/ex_fieldmask/commit/21b1fee30f439628139f307157341812b52a237d" target="_blank" rel="noopener">commit <code>21b1fee</code></a>。</p><p>改动前：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Enum.reduce(&#123;%&#123;&#125;, [], [], <span class="keyword">nil</span>&#125;, <span class="keyword">fn</span> token, acc -&gt;</span><br><span class="line">  &#123;tree, path, stack, last_token&#125; = acc</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> token <span class="keyword">do</span></span><br><span class="line">    <span class="string">","</span> -&gt;</span><br><span class="line">      if List.first(stack) === <span class="string">"/"</span> <span class="keyword">do</span></span><br><span class="line">        &#123;tree, tl(path), tl(stack), token&#125;</span><br><span class="line">      else</span><br><span class="line">        acc</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"/"</span> -&gt;</span><br><span class="line">      &#123;tree, [last_token | path], [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">"("</span> -&gt;</span><br><span class="line">      &#123;tree, [last_token | path], [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">")"</span> -&gt;</span><br><span class="line">      &#123;tree, tl(path), [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> -&gt;</span><br><span class="line">      &#123;put_in(tree, Enum.reverse([token | path]), %&#123;&#125;), path, stack, token&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>改动后：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Enum.reduce(&#123;%&#123;&#125;, [], [], <span class="keyword">nil</span>&#125;, <span class="keyword">fn</span></span><br><span class="line">  <span class="string">","</span> = token, &#123;tree, path, stack, last_token&#125; -&gt;</span><br><span class="line">    if List.first(stack) === <span class="string">"/"</span> <span class="keyword">do</span></span><br><span class="line">      &#123;tree, tl(path), tl(stack), token&#125;</span><br><span class="line">    else</span><br><span class="line">      &#123;tree, path, stack, last_token&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="string">"/"</span> = token, &#123;tree, path, stack, last_token&#125; -&gt;</span><br><span class="line">    &#123;tree, [last_token | path], [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">"("</span> = token, &#123;tree, path, stack, last_token&#125; -&gt;</span><br><span class="line">    &#123;tree, [last_token | path], [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">")"</span> = token, &#123;tree, path, stack, <span class="number">_</span>&#125; -&gt;</span><br><span class="line">    &#123;tree, tl(path), [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">  token, &#123;tree, path, stack, <span class="number">_</span>&#125; -&gt;</span><br><span class="line">    &#123;put_in(tree, Enum.reverse([token | path]), %&#123;&#125;), path, stack, token&#125;</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p><strong>解读</strong>：改动前的写法更多的还是在用其他无模式匹配特性的编程语言的思维在写代码，在 Elixir 里，我们可以直接在函数参数中使用模式匹配，不仅简化了步骤让代码变得更简洁，而且也简化了变量个数、少了命名需求。在分支的匹配过程中我们还可以给匹配到的字符串同样用模式匹配 <code>&quot;/&quot; = token</code> 的方式来命名。为什么已经确定的匹配还要用一个新的变量来匹配呢？原因是在分支内部需要多次重复引用 <code>&quot;/&quot;</code>，我们直接用 <code>token</code> 来统一引用即可，小小改动却充分体现了 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">Don’t repeat yourself</a> 的原则。</p></li><li><p>用 <a href="https://elixir-lang.org/getting-started/comprehensions.html" target="_blank" rel="noopener">List Comprehensions</a> 替换高阶函数的使用：<a href="https://github.com/seniverse/ex_fieldmask/commit/8de1abf59a18829e8e19a33a625f58424e577e3b" target="_blank" rel="noopener">commit <code>8de1abf</code></a>，其他类似的改动还有 <a href="https://github.com/seniverse/ex_fieldmask/commit/48afae9357515afbd2111bd412ac4d4cd09f2229" target="_blank" rel="noopener">commit <code>48afae9</code></a>。</p><p>改动前：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span></span><br><span class="line">  [] -&gt;</span><br><span class="line">    data</span><br><span class="line"></span><br><span class="line">  [<span class="string">"*"</span>] -&gt;</span><br><span class="line">    data</span><br><span class="line">    |&gt; Map.keys()</span><br><span class="line">    |&gt; Enum.map(&amp;[&amp;<span class="number">1</span>, reveal(tree[<span class="string">"*"</span>], data[&amp;<span class="number">1</span>])])</span><br><span class="line">    |&gt; Map.new(<span class="keyword">fn</span> pair -&gt; List.to_tuple(pair) <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">  keys -&gt;</span><br><span class="line">    <span class="keyword">case</span> data <span class="keyword">do</span></span><br><span class="line">      data <span class="keyword">when</span> is_list(data) -&gt;</span><br><span class="line">        Enum.map(data, &amp;reveal(tree, &amp;<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">      data <span class="keyword">when</span> is_map(data) -&gt;</span><br><span class="line">        keys</span><br><span class="line">        |&gt; Enum.map(&amp;[&amp;<span class="number">1</span>, reveal(tree[&amp;<span class="number">1</span>], data[&amp;<span class="number">1</span>])])</span><br><span class="line">        |&gt; Map.new(<span class="keyword">fn</span> pair -&gt; List.to_tuple(pair) <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>改动后：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span></span><br><span class="line">  [] -&gt;</span><br><span class="line">    data</span><br><span class="line"></span><br><span class="line">  [<span class="string">"*"</span>] -&gt;</span><br><span class="line">    data</span><br><span class="line">    |&gt; Map.keys()</span><br><span class="line">    |&gt; (<span class="keyword">fn</span> keys -&gt;</span><br><span class="line">      <span class="keyword">for</span> key &lt;- keys, <span class="symbol">into:</span> %&#123;&#125; <span class="keyword">do</span></span><br><span class="line">        &#123;key, reveal(tree[<span class="string">"*"</span>], data[key])&#125;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>).()</span><br><span class="line"></span><br><span class="line">  keys -&gt;</span><br><span class="line">    <span class="keyword">case</span> data <span class="keyword">do</span></span><br><span class="line">      data <span class="keyword">when</span> is_list(data) -&gt;</span><br><span class="line">        <span class="keyword">for</span> item &lt;- data <span class="keyword">do</span></span><br><span class="line">          reveal(tree, item)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      data <span class="keyword">when</span> is_map(data) -&gt;</span><br><span class="line">        keys</span><br><span class="line">        |&gt; (<span class="keyword">fn</span> keys -&gt;</span><br><span class="line">          <span class="keyword">for</span> key &lt;- keys, <span class="symbol">into:</span> %&#123;&#125; <span class="keyword">do</span></span><br><span class="line">            &#123;key, reveal(tree[key], data[key])&#125;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>).()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>解读</strong>：这里性能上是不是真的有优化可能不那么明显。在 Elixir 1.9.1 中我使用 <a href="https://github.com/bencheeorg/benchee" target="_blank" rel="noopener">Benchee</a> 做 benchmark 发现 List Comprehensions 确实要比使用 Elixir 提供的高阶函数要快。没有看 Elixir 的具体的实现，但大致揣测 List Comprehensions 在底层是用简单的递归函数实现的，而高阶函数应该做了更多复杂的事情，从逻辑上可以想到的是 <code>Enum/Stream</code> 库需要先处理传入数据结构的 <code>Enumerable</code> 协议的相关要求再用不同数据类型对应的不同逻辑来处理，自然会复杂一些。</p></li></ul><p>总结上来，简单的明显可以改善代码性能的写法其实只有两类：尽可能用模式匹配、用 List Comprehensions 替换高阶函数，其他的只是从其他角度考虑的代码层面的优化。最终我们线上没有使用这个库，因为 <a href="https://github.com/seniverse/fieldmask_benchmark" target="_blank" rel="noopener">benchmark</a> 发现直接定义 Partial Responses 的语法，然后用 Erlang 的 <a href="http://erlang.org/doc/man/leex.html" target="_blank" rel="noopener"><code>leex</code></a> 做词法分析，再用 <a href="http://erlang.org/doc/man/leex.html" target="_blank" rel="noopener"><code>yecc</code></a> 做语法分析生成 <a href="https://zh.wikipedia.org/wiki/抽象語法樹" target="_blank" rel="noopener">AST</a>，最后遍历 AST 就可以得到做了 mask 的结果，即我们要的 Partial Response。代码同样开源在 GitHub：<a href="https://github.com/seniverse/fieldmask" target="_blank" rel="noopener">fieldmask - GitHub</a>，也是一个绝妙的学习 Erlang <code>leex</code> 和 <code>yecc</code> 的例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Elixir 作为基于 Erlang/OTP 的年轻语言，拥有良好的并发模型设计，在 Web 场景下对于实现能承载高并发的服务毫无问题。有好事者&lt;a href=&quot;https://github.com/mroth/phoenix-showdown&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对比过包括 Phoenix 在内不同的 Web Framework 的性能&lt;/a&gt;，可见如果采用 Phoenix/Plug 来实现 Web Server 在性能上不会有太大的问题（代码实现良好的情况下）。所以，本文不会讨论真正的工业生产环境下整个系统的性能状态，因为系统性能受到很多因素的影响，具体编程语言的运行时的执行效率往往不是真正的问题所在，与其考虑编程语言本身的运行时效率，不如探讨系统在具体架构和实现上如何能优化来承载更高的负载来得实际。在生产环境中，我们可以借助 &lt;a href=&quot;https://zh.wikipedia.org/wiki/应用性能管理&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;APM&lt;/a&gt; 服务来监控系统状态和性能指标。&lt;/p&gt;&lt;p&gt;由于 Elixir 本身是基于 Erlang 的更高层次的抽象，所以直觉上我们会觉得 Elixir 在运行性能上应该比 Erlang 本身要差一些。实际情况是不是这样呢？Elixir 相比于 Erlang 而言，为我们提供了一些可以快速调用的高阶函数库，典型的有 &lt;a href=&quot;https://hexdocs.pm/elixir/Enum.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;，提高了日常实现需求的开发效率，可以让代码实现得更清晰且更易维护。而更高的抽象又几乎必然意味着底层的实现逻辑需要更通用健壮，从而也会更复杂。更高的抽象程度似乎天然与更高的运行效率有着内在的矛盾。本文的焦点在 Elixir 代码的运行性能，即对于实现同样的功能，用哪样的 Elixir 实现方式会让代码在运行时跑得更快。&lt;/p&gt;
    
    </summary>
    
    
      <category term="一只代码狗的自我修养" scheme="http://maples7.com/categories/%E4%B8%80%E5%8F%AA%E4%BB%A3%E7%A0%81%E7%8B%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="Erlang" scheme="http://maples7.com/tags/Erlang/"/>
    
      <category term="性能调优" scheme="http://maples7.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
      <category term="Elixir" scheme="http://maples7.com/tags/Elixir/"/>
    
  </entry>
  
  <entry>
    <title>把 Airflow 搬进 Kubernetes</title>
    <link href="http://maples7.com/2019/12/03/develop-etl-via-airflow-on-k8s/"/>
    <id>http://maples7.com/2019/12/03/develop-etl-via-airflow-on-k8s/</id>
    <published>2019-12-02T16:35:32.000Z</published>
    <updated>2021-11-13T04:56:40.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>稳定高效的进行数据处理几乎是如今每一家互联网公司都要面临的课题，尤其是对于<a href="https://www.seniverse.com/" target="_blank" rel="noopener">专注于气象数据研究的我司</a>而言，做数据分析和 <a href="https://zh.wikipedia.org/wiki/ETL" target="_blank" rel="noopener">ETL</a> 的工作是整个公司业务很重要的一部分。在脱离了原始的「刀耕火种」的时代之后，我们内部一直在使用 <a href="https://airflow.apache.org/" target="_blank" rel="noopener">Airflow</a> 作为数据处理流程的框架来管理日常的数据流任务。其实我们也调研了很多其他的方案，最后还是选定了看起来相对比较可靠也比较符合我们业务需求的开源项目 Airflow 来做这个事情，虽然在使用的过程中确实也遇到了不少坑。当时这个项目还在 <a href="https://zh.wikipedia.org/wiki/Apache_Incubator" target="_blank" rel="noopener">Apache Incubator</a>，目前已经顺利毕业了。</p><p>简单介绍一下 Airflow，一般由 WebServer（一套完整的 UI 界面用于随时查看任务的执行状态并可以手动执行一些操作）、Scheduler（用来做任务的调度和管理）、Worker（真正执行任务的部分，可能有很多个）组成。这是一个常见的分布式架构，你只需要把任务流的 <a href="https://airflow.apache.org/concepts.html#dags" target="_blank" rel="noopener">DAG</a> 用 Python 代码写好，然后配置好触发条件就可以让它长期运行下去。在实际生产环境中，我们大量使用了 <a href="https://airflow.apache.org/howto/executor/use-celery.html" target="_blank" rel="noopener">Celery Executor</a> 来把任务动态分布到多个 Worker 上执行。</p><a id="more"></a><p>如果数据处理任务长期不变，这样的系统已经可以满足我们的需求了。但实际上随着越来越多的数据任务被添加到整个系统，任务负载变得越来越重，很多时候固定数量的 Worker 已经不能及时的处理完被 scheduled 的任务，造成任务队列堆积，一段时间后如果一直不能改善负载情况甚至会拖垮整个系统。这种情况下，只能手动增加更多的 Worker 来分担任务处理工作。然后不同类型的数据处理越多，Worker 所需要安装的依赖也越多，每手工增加一个 Worker 的成本也越来越高。甚至对于气象数据的处理而言，有很多非常古老的数据处理工具（很多还是 Fortran 写的），经常出现依赖相互冲突的情况（版本冲突，编译通不过等等）。如何隔离各个任务之间的运行环境，以及如何根据负载需求动态的伸缩 Worker 的数量日益成为了这个系统的一个痛点。</p><p>动态伸缩，环境隔离，自然让人联想到 <a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a> 和 <a href="https://kubernetes.io/zh/" target="_blank" rel="noopener">Kubernetes</a> 这样的技术。好在 Airflow 1.10 版本引入了 <a href="https://airflow.apache.org/kubernetes.html" target="_blank" rel="noopener">Kubernetes Executor 和 Kubernetes Operator</a> 允许为每一个任务创建新的 Pod 来处理，而执行完之后新创建的 Pod 会被清理掉，并且每一个任务都可以指定不同的 Docker image 来处理，这样看起来就可以完全解决我们前面的问题。</p><p>目前这部分功能似乎还很不稳定，官方文档和讨论都还不多，这篇博客也是为了记录下我们的踩坑过程。</p><h2 id="在-Kubernetes-上搭建-Airflow"><a href="#在-Kubernetes-上搭建-Airflow" class="headerlink" title="在 Kubernetes 上搭建 Airflow"></a>在 Kubernetes 上搭建 Airflow</h2><p>我们使用 <a href="https://helm.sh/" target="_blank" rel="noopener">Helm</a> 来管理在 Kubernetes 上个各个应用以及它们的依赖，目前官方也已经给出了 <a href="https://github.com/helm/charts/tree/master/stable/airflow" target="_blank" rel="noopener">stable/airflow 的 Chart</a>，我们可以直接使用或部分参考。下面我们介绍一下从零开始的搭建过程。</p><ol><li><p>安装 Kubernetes</p><p>本地安装的可以选择 <a href="https://kubernetes.io/docs/tasks/tools/install-minikube/" target="_blank" rel="noopener">Minikube</a>，主要它解决了跨平台的问题。我在 macOS 上使用的是 <a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="noopener">Docker Desktop for Mac</a> 里<a href="https://www.docker.com/blog/docker-mac-kubernetes/" target="_blank" rel="noopener">自带的 Kubernetes 集群</a>，如果你安装遇到了问题可以看看<a href="https://github.com/gotok8s/k8s-docker-desktop-for-mac" target="_blank" rel="noopener">这里</a>是不是解决了你的问题，或者自行 Google 也可。</p></li><li><p>安装 Helm</p><p>Helm 3 已经是正式的稳定版本，可惜我们线上还在使用 Helm 2，而 Helm 2 的版本不兼容是没法使用的。为了跟线上保持一致，我本地也是安装的 Helm 2，所以后面都是以 Helm 2 的操作来执行的，第一次进行的朋友可以直接用 Helm 3。当然安装过程也<a href="https://github.com/helm/helm/issues/4730" target="_blank" rel="noopener">很可能出现问题</a>，可以自行 Google 解决。</p></li><li><p>在 Kubernetes 上用 Helm 安装 Airflow Chart</p><p>直接根据<a href="https://github.com/helm/charts/tree/master/stable/airflow" target="_blank" rel="noopener">官方的 Airflow Chart</a>步骤执行 <code>helm install --namespace &quot;airflow&quot; --name &quot;airflow&quot; stable/airflow</code> 即可在 Kubernetes 上安装一个标准的 Airflow 集群，之后可以查看各个 Pod 的状态是不是已经 ready（一切正常的情况下会在 <code>airflow</code> 的 Namespace 下安装 airflow-web、airflow-scheduler、airflow-postgresql、airflow-flower、airflow-redis）。还可以根据 NOTES 的提示在浏览器中查看 Airflow 的 UI 界面是不是也启动良好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NOTES:</span><br><span class="line">Congratulations. You have just deployed Apache Airflow</span><br><span class="line">   export POD_NAME=$(kubectl get pods --namespace airflow -l &quot;component=web,app=airflow&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)</span><br><span class="line">   echo http://127.0.0.1:8080</span><br><span class="line">   kubectl port-forward --namespace airflow $POD_NAME 8080:8080</span><br><span class="line"></span><br><span class="line"> Open Airflow in your web browser</span><br></pre></td></tr></table></figure></li><li><p>根据自身业务情况自定义一些配置</p><p>之后可以根据 Helm 的 官方 Airflow Chart 提供的配置方式进行一些自定义配置，比如把默认的 Airflow 镜像 <code>puckel/docker-airflow</code> 替换成自己根据自身业务需求构建的（比如已经安装了实现业务需求所有必要底层依赖的 Airflow 镜像，或者对于 Kubernetes Executor and operator 必需的 <code>apache-airflow[kubernetes]</code>，这样就不用每次部署更新都安装这些依赖了）、更改 <code>executor</code> 的类型（我们改为 <code>Kubernetes</code>）等等。官方的 Chart 目录下也提供了<a href="https://github.com/helm/charts/blob/master/stable/airflow/examples/minikube-values.yaml" target="_blank" rel="noopener">一个例子</a>可供参考。</p><p>值得额外注意的是我们如何做数据的持久化。这既包括 DAGs、日志 logs，也包括 Airflow 的运行态数据 —— 存储在 Postgres 或 MySQL 中的数据 —— 如何持久化。官方的 README 对此<a href="https://github.com/helm/charts/tree/master/stable/airflow#dags-deployment" target="_blank" rel="noopener">已经有介绍</a>，同样如果有额外的自定义配置直接写到我们自己的 <code>values</code> YAML 文件中即可。<a href="https://github.com/apache/airflow/blob/1.10.6/airflow/config_templates/default_airflow.cfg" target="_blank" rel="noopener"><code>airflow.cfg</code></a> 中 <code>[kubernetes]</code> 对应的每一项配置也应该过一遍并做相应的修改，尤其是关于 <code>namespace</code> 和 <code>dags_in_image</code> 的部分。对我司而言，我们自己的 Kubernetes 集群运行在阿里云上，直接使用一个外挂的 NAS 作为 DAGs 和 logs 的共享存储即可（通过 <code>extraVolumeMounts</code> 和 <code>extraVolumes</code> 挂载和声明，也要注意跟 <code>dags.path</code> 路径保持一致），以后我们自己开发的 DAGs 可以直接通过 CI/CD 更新到 NAS 上相应的目录。数据库采用一个已经存在的外部 Postgres。</p><p>假设我们将自定义的 <code>values</code> 配置写成 <code>minikube-values.yaml</code> 的本地 YAML 文件，就可以用 <code>helm install --namespace &quot;airflow&quot; --name &quot;airflow&quot; stable/airflow -f minikube-values.yaml</code> 启动一个经过自定义修改后的 Airflow 集群（可以先把之前启动的集群通过 <code>helm delete --purge &quot;airflow&quot;</code> 清除）。</p></li></ol><p>因为业务需求和基础设施现状的不同，中间可能有不同的架构选择，但总体上经过这几步之后，一个采用 <code>KubernetesExecutor</code> 并运行在 Kubernetes 上的 Airflow 集群就基本搭建好了。</p><h2 id="开发-DAGs"><a href="#开发-DAGs" class="headerlink" title="开发 DAGs"></a>开发 DAGs</h2><p>参考 Airflow 官方文档中 Kubernetes Operator 的例子可以开发适用于自身业务需求的 DAG。之后就可以访问 Airflow WebServer 来开启相应的 DAG 任务，并观察集群中 Task 的运行行为是否与预期的一致，并逐步迭代。</p><h2 id="悄悄告诉你，真相其实是这样……"><a href="#悄悄告诉你，真相其实是这样……" class="headerlink" title="悄悄告诉你，真相其实是这样……"></a>悄悄告诉你，真相其实是这样……</h2><p>实际上，在经过我的一番折腾之后，最终我们线上使用的版本并没有使用官方的 Helm Chart，而是完全基于我们自己 build 的 Airflow 镜像，从头搭建了我们自己的 Helm Release Chart，这样整个系统拥有最高的可定制度（有些问题不在代码层面定制根本没法绕过去，下文有详述），同时也剔除了很多 Helm 官方 Chart 里有但我们不需要的东西。跟官方的 Chart 相比，我们主要做了这些更改：</p><ul><li><p>没有使用 Airflow 官方的 Kubernetes Executor，而是自己继承 <code>LocalExecutor</code> 类定制我们自己的 <code>KubeExecutor</code>，实际做的事情也很简单，就是实际在执行任务的时候不直接像 <code>LocalExecutor</code> 那样在本地执行命令，而用 <code>kubectl</code> 把任务指定在某一个 Worker Pod 或使用了 <code>KubernetesPodOperator</code> 启动的临时 Pod 里运行。这样做主要考虑的是官方的 <code>KubernetesPodOperator</code> 为了一些通用性功能从而进行了较为复杂的流程设计，我们团队自身完全可以结合在阿里云里 Kubernetes 集群的具体特点改造 <code>LocalExecutor</code>，这样不仅在运行时可以节省更多的机器资源，而且对于我们最核心的需求 —— 稳定的生产数据 —— 来说是更有利的，毕竟在运行时动态操作 Kubernetes 集群资源的流程变得简单了很多。</p></li><li><p>阿里云还有一个很大的坑是在它上面构建的官方 Kubernetes 集群产品不提供阿里云的 CA 根证书校验，而 <a href="https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/#directly-accessing-the-rest-api-1" target="_blank" rel="noopener">Kubernetes 官方明确指明了需要校验 CA bundle</a>，导致我们无法通过 API 与 Kubernetes Server 进行交互，进而在使用 <code>KubernetesPodOperator</code> 时会因为证书校验失败而无法创建 Pod。而 <code>KubernetesPodOperator</code> 也并没有提供参数让我们将 <code>verify_ssl</code> 设置为 False。所以最终我们也没有直接用官方的 <code>KubernetesPodOperator</code>，而是自己改了一个类似的把 <code>verify_ssl</code> 设置为 False 的 Operator 的版本来使用。同时这里也呼吁一下阿里云能按照技术社区标准来提供自己的技术服务与产品（我们提了工单 argue 这个事情，最终客服给我提供了根证书并叮嘱不要扩散，并不清楚阿里云不能对外公开根证书是基于什么样的考量；在其他项目中我们使用了客服提供的根证书来进行校验是没有问题的）。</p></li><li><p>去掉了不必要的通用型适配的各种选择，完全按自身需求合理定制。</p></li></ul><p>虽然我们做了定制，需要考虑的一些核心问题是没有变的，它们是：如何共享 DAG 的 Python 代码、如何做日志和数据库数据的持久化、是否使用 <a href="https://airflow.apache.org/docs/stable/concepts.html?highlight=xcom#xcoms" target="_blank" rel="noopener">XComs</a> 来做 Task 之间的消息通信（同时在集群环境下如何实现这一点）、如何注入依赖（官方 Helm Chart 的 <code>requirements.txt</code> 方式）等等。由于这个尝试和定制的过程着实复杂和不那么让人愉快，甚至需要阅读一些 Airflow 的源码和各个云服务组件的接口参数设计，所以一篇博客无法一一详尽，我自己也不想写那些我们是如何绕过由于各方面的设计缺陷或开源产品不稳定导致的问题的技术细节，它们可能时刻会变，也没有技术深度，更多的是枯燥的云服务运维细节，所以不会在这里赘述太多而分散更大层面的宏观框架上的注意力。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在我们实际使用的过程中其实还遇到了很多 Airflow 的坑，作为一个 Apache 基金会的开源项目，它确实弥补了 ETL 场景下工具和框架的缺失，也提供了非常丰富的功能，不过尽管目前版本号已经到了 1.10.6，但还是有很多明显可感知的 BUG 存在，实际的使用感受是能用但总存在一些小问题，偶尔对任务的调度和管理还可能会失灵，不那么可靠，不算是一个高质量的开源项目，所以在使用时加上适当的重试机制是很有必要的。不过目前社区里在这部分并没有更好的替代品，Airflow 已经是我们考查过的最契合管理 ETL 流程的框架了。如果有新的开源项目能弥补这方面的空缺我们会很乐意去尝试，我们自己团队也在考虑是否在更长期的计划中开发一套自己的 ETL 流程框架。</p><p>几周不断折腾尝试的搭建、使用和实际开发的过程下来，其实涉及了很多开发<a href="https://pivotal.io/cloud-native" target="_blank" rel="noopener">云原生服务</a>常用的 DevOps 工具和组件，比如 Helm、Kubernetes 和 Docker，能得心应手的使用这些工具需要一段时间的学习实践来积累知识和经验。要想在 Kubernetes 环境下玩转 Airflow，了解这些周边支撑的工具也是不可或缺极其重要的一部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;稳定高效的进行数据处理几乎是如今每一家互联网公司都要面临的课题，尤其是对于&lt;a href=&quot;https://www.seniverse.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;专注于气象数据研究的我司&lt;/a&gt;而言，做数据分析和 &lt;a href=&quot;https://zh.wikipedia.org/wiki/ETL&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ETL&lt;/a&gt; 的工作是整个公司业务很重要的一部分。在脱离了原始的「刀耕火种」的时代之后，我们内部一直在使用 &lt;a href=&quot;https://airflow.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Airflow&lt;/a&gt; 作为数据处理流程的框架来管理日常的数据流任务。其实我们也调研了很多其他的方案，最后还是选定了看起来相对比较可靠也比较符合我们业务需求的开源项目 Airflow 来做这个事情，虽然在使用的过程中确实也遇到了不少坑。当时这个项目还在 &lt;a href=&quot;https://zh.wikipedia.org/wiki/Apache_Incubator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache Incubator&lt;/a&gt;，目前已经顺利毕业了。&lt;/p&gt;&lt;p&gt;简单介绍一下 Airflow，一般由 WebServer（一套完整的 UI 界面用于随时查看任务的执行状态并可以手动执行一些操作）、Scheduler（用来做任务的调度和管理）、Worker（真正执行任务的部分，可能有很多个）组成。这是一个常见的分布式架构，你只需要把任务流的 &lt;a href=&quot;https://airflow.apache.org/concepts.html#dags&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DAG&lt;/a&gt; 用 Python 代码写好，然后配置好触发条件就可以让它长期运行下去。在实际生产环境中，我们大量使用了 &lt;a href=&quot;https://airflow.apache.org/howto/executor/use-celery.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Celery Executor&lt;/a&gt; 来把任务动态分布到多个 Worker 上执行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="一只代码狗的自我修养" scheme="http://maples7.com/categories/%E4%B8%80%E5%8F%AA%E4%BB%A3%E7%A0%81%E7%8B%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="Cloud-Native" scheme="http://maples7.com/tags/Cloud-Native/"/>
    
      <category term="Kubernetes" scheme="http://maples7.com/tags/Kubernetes/"/>
    
      <category term="Airflow" scheme="http://maples7.com/tags/Airflow/"/>
    
      <category term="Helm" scheme="http://maples7.com/tags/Helm/"/>
    
      <category term="DevOps" scheme="http://maples7.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>心知天气数据 API 产品的高并发实践</title>
    <link href="http://maples7.com/2019/05/09/high-concurrent-validity-4-api-in-seniverse/"/>
    <id>http://maples7.com/2019/05/09/high-concurrent-validity-4-api-in-seniverse/</id>
    <published>2019-05-09T04:57:40.000Z</published>
    <updated>2021-11-13T04:56:40.084Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.seniverse.com/" target="_blank" rel="noopener">心知天气</a>作为国内领先的商业气象服务提供商，天气数据 API 产品从公司创立以来就一直扮演着很重要的角色。2009 年 API 产品初次上线，历经十年，我们不断用心迭代，已经为数百家企业客户提供了超过 540 亿次稳定可靠的数据服务。在心知天气<a href="https://www.seniverse.com/" target="_blank" rel="noopener">官网首页</a>一直跳动的调用量数字就实时展示了整个天气 API 产品的服务状态。目前，心知天气数据 API 的 QPS 在高峰时期已经达到数千的量级，如何承载这样海量的并发请求，使客户能稳定及时的获取到所需数据自然也是心知技术团队一路以来不断探索的主题。</p><span itemprop="image" itemscope itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/loading.gif" data-original="/uploads/seniverse-index.gif " class="full-image" alt="图片显示错误" title="心知天气 API 服务实时访问量"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><a id="more"></a><h2 id="访问量特点"><a href="#访问量特点" class="headerlink" title="访问量特点"></a>访问量特点</h2><p>天气数据的基本属性和客户本身的业务需求决定了客户来如何调用我们的数据接口。对于部分使用我们数据进行数据展示的 2C 业务的客户而言，访问量潮汐跟人的行为规律有着明显的相关性，这大致表现为白天比晚上并发量更高；而对于部分使用天气数据做数据分析和研究或者其他需要批量请求天气数据的客户而言，他们大多会选择在整点时刻来批量请求不同的数据，所以整点时刻往往会有突发的高峰访问量。</p><p><img src="https://i.loli.net/2019/04/18/5cb885ced4a0b.png" alt="API 数据服务访问量特点"></p><p>在叠加了不同客户需求的总体 API 服务的访问量，可以看出以下几个特点：</p><ul><li>以「天」为单位周期性明显</li><li>每天零点时刻并发量会激增</li><li>整点和半点时刻存在高并发小周期</li></ul><p>只有了解了我们客户的需求特点，才能设计出更合适的技术架构来应对随之而来的挑战。</p><h2 id="石器时代"><a href="#石器时代" class="headerlink" title="石器时代"></a>石器时代</h2><p>在创业初期，「云计算」的理念开始兴起，创始团队在斟酌优劣之后，选择将整个系统构建于云服务提供商<a href="https://www.aliyun.com/" target="_blank" rel="noopener">阿里云</a>之上，如此一来心知天气团队也不必自己再手工搭建和管理需要的硬件资源，这对于创业公司而言是一个不错的选择。和大多数早期创业公司一样，囿于资源和技术积累，最早我们也是将 API 服务实例直接部署在<a href="https://cn.aliyun.com/product/ecs" target="_blank" rel="noopener">阿里云 ECS</a> 之上，对外通过<a href="https://www.aliyun.com/product/slb" target="_blank" rel="noopener">负载均衡 SLB</a> 提供统一的 API 入口。</p><p>随着心知天气数据服务体验的不断完善，客户数量也不断增多，API 服务所需要承载的流量也持续上涨。由于我们已经构建了上述这样的基础架构体系，在并发量最高的时期，我们需要手工维护高达 40 台左右的 ECS。而每个 ECS 上有自己独立但不完全一致的运行环境，不管是应对访问量突变还是部署新的版本，都无法做到比较快速的响应和执行。</p><p>在这个阶段，我们产品的 API 数据和逻辑都还比较简单，所有关于用户信息处理、位置服务和数据处理的逻辑都揉杂在一个单体服务中，最终部署时也是一个一个独立的单体式架构通过 SLB 共同对外提供服务。</p><h2 id="青铜时代"><a href="#青铜时代" class="headerlink" title="青铜时代"></a>青铜时代</h2><p>随着心知天气数据种类的不断增多，数据处理和 API 服务的逻辑也变得各不相同，比如城市级数据和公里级网格数据就有着完全不一样的处理和取数逻辑。在这种情况下，基于程序的可维护性考虑，我们很快决定根据数据处理逻辑的不同将数据服务拆分为几个不同的微服务，各自对外提供不同的天气数据 API。而为了复用取数之前的权限校验、访问量和各种日志统计的逻辑，我们开始引入网关系统。</p><p>API 网关最重要的是性能和稳定性要足够好，所有的 API 请求都需要经过网关。在通过网关的校验之后，数据服务负责获取需要的天气数据，其结果再通过网关返回给外部用户。如此一来，不同的几个数据服务退化成无状态的纯数据服务，即每个数据服务节点不再考虑任何与用户相关的逻辑，只是简单的根据请求条件将所有处理好的数据从存储系统中取出后返回，网关作为唯一的请求入口来统一处理所有的权限校验和访问量、日志的各种统计。</p><p>基于<a href="https://konghq.com/" target="_blank" rel="noopener">开源的网关系统 Kong</a>，我们使用 Lua 进行了大量的二次定制开发，从而形成了心知天气自己的一套网关体系。这套系统不仅满足网关基本的路由逻辑，还能更好的处理和我们自身业务深度耦合的用户权限校验、访问量统计以及以用户为核心的日志记录。Kong 天生也是支持集群的，所以在理论上我们可以无限横向扩展网关的处理能力。</p><p>在这样的架构之下，心知天气的 API 服务很好的遵循了<a href="https://zh.wikipedia.org/wiki/单一功能原则" target="_blank" rel="noopener">「单一职责」的原则</a>，使得我们的代码维护和版本更新都能以更快速且代价更小的方式进行。但另一方面，我们还是需要手工维护大量的 ECS 集群，甚至由于天气数据服务的多样化，手工维护多个不同种类服务的集群将面对更繁重的挑战。不过，由于我们将服务进行了更好的拆分和分层，变成了一个个更小的微服务，使得我们能把它们进行更好的分布式部署，进而可以横向扩展来提高整个服务集群处理并发请求的能力。这一阶段既是我们成功向微服务架构的转变阶段，也可以看作是我们迈向更现代的后端架构的过渡阶段。</p><h2 id="黄金时代"><a href="#黄金时代" class="headerlink" title="黄金时代"></a>黄金时代</h2><p><a href="https://pivotal.io/cloud-native" target="_blank" rel="noopener">Cloud-Native</a> 的概念是 2015 年被首次提出的，随后就获得了技术社区的大量关注。顺着之前架构演进的思路，我们很快开始用 Cloud-Native 的理念来武装整个后端系统架构。在去年，我们正式开始用 <a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a> 和 <a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 来改造和管理我们所有对外的线上服务，这些架构设计同时也与阿里云提供的云服务深度结合。</p><p>从网关到数据服务，目前我们都已经完成了容器化的改造，并且所有服务都使用 Kubernetes 来编排和管理，这意味着我们真正统一了各个服务的运行时环境，从而可以快速复制出新的服务节点。借助 Kubernetes，我们现在可以做到容器级别的自动伸缩，在并发量高的时候服务节点能够自动横向扩展以提高整个集群的并发处理能力，进而可以给用户提供更加优质稳定的天气数据 API 服务。</p><p>不仅如此，基于 Cloud-Native 的理念，我们还统一了各个服务的 <a href="https://zh.wikipedia.org/wiki/持續整合" target="_blank" rel="noopener">CI（持续集成）</a> 流程，优化了 <a href="https://zh.wikipedia.org/wiki/DevOps" target="_blank" rel="noopener">DevOps</a> 的体验，做到所有服务的标准化和归一化 —— 从此以往，万物皆容器。这对于今后产品的持续高效迭代和改进，也是有重大意义的。</p><p><img src="https://i.loli.net/2019/05/09/5cd3d76bb42c6.png" alt="心知天气数据 API 产品的高可用之路"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>心知数据 API 产品历经十年，其后端架构也逐渐从传统的企业应用的开发模式转变为现代的 Cloud-Native 应用的开发模式，不仅极大的解放了团队的产品开发效率，而且能对外提供更加优质稳定的数据服务。心知天气从创立之初就带着鲜明的互联网风格，我们崇尚极客文化，技术团队也将继续带着勇于探索和敢于挑战的极客精神，用更好的技术与更优质的产品，为我们的客户提供更具价值的产品。</p><p><strong>【本文由多人协作完成，版权归<a href="https://www.seniverse.com/" target="_blank" rel="noopener">心知天气</a>所有，转载需联系<a href="mailto:hi@seniverse.com?subject=文章转载授权申请" target="_blank" rel="noopener">心知天气</a>获取授权】</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.seniverse.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;心知天气&lt;/a&gt;作为国内领先的商业气象服务提供商，天气数据 API 产品从公司创立以来就一直扮演着很重要的角色。2009 年 API 产品初次上线，历经十年，我们不断用心迭代，已经为数百家企业客户提供了超过 540 亿次稳定可靠的数据服务。在心知天气&lt;a href=&quot;https://www.seniverse.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网首页&lt;/a&gt;一直跳动的调用量数字就实时展示了整个天气 API 产品的服务状态。目前，心知天气数据 API 的 QPS 在高峰时期已经达到数千的量级，如何承载这样海量的并发请求，使客户能稳定及时的获取到所需数据自然也是心知技术团队一路以来不断探索的主题。&lt;/p&gt;&lt;span itemprop=&quot;image&quot; itemscope itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;img itemprop=&quot;url image&quot; src=&quot;/images/loading.gif&quot; data-original=&quot;/uploads/seniverse-index.gif &quot; class=&quot;full-image&quot; alt=&quot;图片显示错误&quot; title=&quot;心知天气 API 服务实时访问量&quot;&gt;&lt;meta itemprop=&quot;width&quot; content=&quot;auto&quot;&gt;&lt;meta itemprop=&quot;height&quot; content=&quot;auto&quot;&gt;&lt;/span&gt;
    
    </summary>
    
    
      <category term="一只代码狗的自我修养" scheme="http://maples7.com/categories/%E4%B8%80%E5%8F%AA%E4%BB%A3%E7%A0%81%E7%8B%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="高并发" scheme="http://maples7.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="系统架构" scheme="http://maples7.com/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>东北的冬</title>
    <link href="http://maples7.com/2019/02/05/winter-of-north-east/"/>
    <id>http://maples7.com/2019/02/05/winter-of-north-east/</id>
    <published>2019-02-05T12:36:21.000Z</published>
    <updated>2021-11-13T04:56:40.084Z</updated>
    
    <content type="html"><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width:50%"><img data-original="https://i.loli.net/2019/02/05/5c5981f5ee873.jpg"></div><div class="group-picture-column" style="width:50%"><img data-original="https://i.loli.net/2019/02/05/5c598233d3831.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width:33.333333333333336%"><img data-original="https://i.loli.net/2019/02/05/5c59825ebeeef.jpg"></div><div class="group-picture-column" style="width:33.333333333333336%"><img data-original="https://i.loli.net/2019/02/05/5c5982bbbc951.jpg"></div><div class="group-picture-column" style="width:33.333333333333336%"><img data-original="https://i.loli.net/2019/02/05/5c5982e2aac4d.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width:33.333333333333336%"><img data-original="https://i.loli.net/2019/02/05/5c59830583ea1.jpg"></div><div class="group-picture-column" style="width:33.333333333333336%"><img data-original="https://i.loli.net/2019/02/05/5c59829a17feb.jpg"></div><div class="group-picture-column" style="width:33.333333333333336%"><img data-original="https://i.loli.net/2019/02/05/5c5983059de98.jpg"></div></div></div></div><a id="more"></a><br><p>图片已经过裁剪与压缩。</p>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;group-picture&quot;&gt;&lt;div class=&quot;group-picture-container&quot;&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;width:50%&quot;&gt;&lt;img data-original=&quot;https://i.loli.net/2019/02/05/5c5981f5ee873.jpg&quot;&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;width:50%&quot;&gt;&lt;img data-original=&quot;https://i.loli.net/2019/02/05/5c598233d3831.jpg&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;width:33.333333333333336%&quot;&gt;&lt;img data-original=&quot;https://i.loli.net/2019/02/05/5c59825ebeeef.jpg&quot;&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;width:33.333333333333336%&quot;&gt;&lt;img data-original=&quot;https://i.loli.net/2019/02/05/5c5982bbbc951.jpg&quot;&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;width:33.333333333333336%&quot;&gt;&lt;img data-original=&quot;https://i.loli.net/2019/02/05/5c5982e2aac4d.jpg&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-row&quot;&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;width:33.333333333333336%&quot;&gt;&lt;img data-original=&quot;https://i.loli.net/2019/02/05/5c59830583ea1.jpg&quot;&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;width:33.333333333333336%&quot;&gt;&lt;img data-original=&quot;https://i.loli.net/2019/02/05/5c59829a17feb.jpg&quot;&gt;&lt;/div&gt;&lt;div class=&quot;group-picture-column&quot; style=&quot;width:33.333333333333336%&quot;&gt;&lt;img data-original=&quot;https://i.loli.net/2019/02/05/5c5983059de98.jpg&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
    
    </summary>
    
    
      <category term="视觉动物" scheme="http://maples7.com/categories/%E8%A7%86%E8%A7%89%E5%8A%A8%E7%89%A9/"/>
    
    
      <category term="Sony DSC-RX100" scheme="http://maples7.com/tags/Sony-DSC-RX100/"/>
    
      <category term="东北" scheme="http://maples7.com/tags/%E4%B8%9C%E5%8C%97/"/>
    
      <category term="雪" scheme="http://maples7.com/tags/%E9%9B%AA/"/>
    
      <category term="林海" scheme="http://maples7.com/tags/%E6%9E%97%E6%B5%B7/"/>
    
  </entry>
  
  <entry>
    <title>2018 年书单</title>
    <link href="http://maples7.com/2018/12/31/2018-booklist/"/>
    <id>http://maples7.com/2018/12/31/2018-booklist/</id>
    <published>2018-12-31T14:51:30.000Z</published>
    <updated>2021-11-13T04:56:40.084Z</updated>
    
    <content type="html"><![CDATA[<p>今年的个人状态要比去年好多了，好在心态的逐渐平和。毫无疑问，今年要比去年忙很多，工作和生活都是如此，不过事情也开始越来越聚焦，大概是一种越来越明白自己在做什么以及为什么要这样做的状态。</p><p>回到「书单」的正题。在<a href="http://maples7.com/2016/12/31/2016-booklist/">之前的年终书单总结</a>中，我说过一般用 iPad 看电子书，今年引入了一个新设备 —— <a href="https://www.amazon.com/All-new-Kindle-Paperwhite-Waterproof-Storage/dp/B07CXG6C9W" target="_blank" rel="noopener">Kindle PaperWhite 4</a>（官方名称是 “All-new Kindle Paperwhite”），这是目前为止最轻的一款 Kindle。之前我一直不理解用 Kindle 看电子书比用 iPad 看电子书好在哪里 —— 忍受着上世纪电子设备的响应速度，使用着非常有限的功能，就为了墨水屏？不用不知道，在真正使用了 Kindle 之后我发现，所有的「轻薄」、「有限的功能」、「电子墨水屏」等特性，都是为了让你在阅读时更加专注 —— 避免打扰、减少疲劳感。从中我体悟到一个道理，任何细微而又专注于目标的优势都不应该被忽视，它可能是一个产品制胜的关键。Kindle 所有的设计都是为了「阅读」这一场景而设计，尽管 iPad 有着丰富得多的功能，但对于体验敏感的用户来说，在「阅读」这件事情上还是会为了用户体验而买一个 Kindle。细小而专注的优势，很重要，不仅仅适用于电子设备产品，也适用于每一件事、每一个人本身。</p><a id="more"></a><p>废话先不多说，还是按老规矩先列今年看过的书的书单。</p><ol><li><p><a href="https://www.zhihu.com/pub/book/19550356" target="_blank" rel="noopener">设计之美</a>：★★★☆<br>前言写得是真好，整本书写得最好的部分也是前言。</p></li><li><p><a href="https://book.douban.com/subject/26320659/" target="_blank" rel="noopener">万物生长</a>：★★★★<br>冯唐的文字远比<a href="https://zh.wikipedia.org/wiki/王小波" target="_blank" rel="noopener">王小波</a>的瑰丽绚烂，像被一个习惯了炒食堂大锅菜的师傅炒出的菜，加足了各种重口的佐料，分明就是他自己前不久写的那篇在朋友圈疯转的文章所说的「油腻」。<br>被称为「某某第二」的人永远不能成为「某某」，也永远达不到世俗意义上「某某」的高度，这一点，几乎是一条铁律。号称「王小波第二」的冯唐永远也成不了王小波，是因为他的文字看不到王小波能看到的东西，技巧十足，却没有让人想去细细揣摩的深意。<br>然而这个世界上没有谁需要去成为谁，冯唐不必易老，照样会让世界变得更丰富。</p></li><li><p><a href="https://book.douban.com/subject/26943161/" target="_blank" rel="noopener">未来简史：从智人到智神</a>：★★★★<br>第一部分基本是在重复<a href="https://book.douban.com/subject/26953606/" target="_blank" rel="noopener">《人类简史》</a>的观点；第二部分写得比较有意思，把人文主义主导世界的现实情况剖析得鞭辟入里；第三部阐述了数据宗教的概念，基本也没有什么新东西。<br>预言未来当然比叙述历史要难很多，没有《人类简史》那么脉络清晰且具有说服力，不过书中的很多观点都是值得了解的。</p></li><li><p><a href="https://book.douban.com/subject/27085265/" target="_blank" rel="noopener">北京，北京</a>：★★<br>「年轻人没了幻想，一不小心就俗了」；<br>作家要是没了追求，文字一不小心就俗透了。</p></li><li><p><a href="https://book.douban.com/subject/25881855/" target="_blank" rel="noopener">大教堂与集市</a>：★★★★☆<br>可以和<a href="https://book.douban.com/subject/26358448/" target="_blank" rel="noopener">《人月神话》</a>一起看。<br><a href="https://en.wikipedia.org/wiki/Fred_Brooks" target="_blank" rel="noopener">Brooks</a> 证明了「人月」在软件工程领域的非线性叠加性，而 <a href="https://en.wikipedia.org/wiki/Eric_S._Raymond" target="_blank" rel="noopener">Eric S.Raymond</a> 则告诉我们「开源」大概是破局的唯一方式。<br>这部二十多年前写就的作品在如今看来也毫不过时，甚至书中的一些预言都一一应验。开源运动绝对是上世纪末以来黑客们最伟大的宗教活动。</p></li><li><p><a href="https://book.douban.com/subject/27070488/" target="_blank" rel="noopener">围城</a>：★★★★★<br>钱钟书太厉害了，把人物形象简直刻画得惟妙惟肖，个个都像是生活中栩栩如生的样子。<br>一个围城，围住了中国人的人情、世俗、琐碎与人生的苍凉。<br><a href="https://zh.wikipedia.org/wiki/韩寒" target="_blank" rel="noopener">韩寒</a>的所谓<a href="https://book.douban.com/subject/24697636/" target="_blank" rel="noopener">《三重门》</a>不及《围城》的 0.01%。</p></li><li><p><a href="https://book.douban.com/subject/26663519/" target="_blank" rel="noopener">MacTalk 跨越边界</a>：★★★☆<br>比前作的干货更少，也看得出对于书本身的内容而言所体现出的作者的野心更少，基本都是些日常感悟和书评。大概已经无需再考虑要证明什么，可以放开手脚写想写的东西。<br>在我所接触到的所有技术人的自媒体当中，不管技术如何，<a href="http://macshuo.com/?page_id=2" target="_blank" rel="noopener">池建强</a>和<a href="https://www.zhihu.com/people/tchen/" target="_blank" rel="noopener">陈天</a>算是文字写得流畅优美、可读性非常强的两位了。<br>作为枕边读物还行。</p></li><li><p><a href="https://book.douban.com/subject/26997376/" target="_blank" rel="noopener">我是猫</a>：★★★☆<br>简直就是夏目漱石的自嘲式自传。这本书在浮躁的时候是不能读的，只有在悠闲的时候静下心来慢慢跟随「猫」的视野，才能感受到作为一个旁观者的乐趣。跟《围城》的写作手法和主旨其实有一些类似，但可读性并没有那么高，独特的视角也是本书的特色之一吧。</p></li><li><p><a href="https://book.douban.com/subject/26984868/" target="_blank" rel="noopener">神奇动物在哪里（原创电影剧本）</a>：★★★★<br>看完电影再看剧本画面简直扑面而来，第一部无论是剧本还是电影都很不错啊，好奇<a href="https://movie.douban.com/subject/26147417/" target="_blank" rel="noopener">第二部</a>的剧本到底是怎么样的，至少从电影的观赏程度上肯定不如第一部，当然也有可能第二部的定位就是为了挖大坑。<br>不过呢，出版的剧本其实并不是为了拍电影工作的原始剧本，而是根据已上映电影内容的再编辑，这样看估计出版的剧本也不会很好了。<a href="https://www.jkrowling.com/" target="_blank" rel="noopener">罗姨</a>的确是应该找个专业剧作家一起合作啊。</p></li></ol><p>今年看完的书差不多就是这样了，另外我是那种齐头并进看多本书的类型，每天看心情选择一本想看的书，投入也开心。而书单只会列出在当年看完的书，那些可能看了一半的书不好评价故不在此列，有些书甚至可能会持续一两年还没看完，但最终基本还是会有所了结。以后我也会慢慢把所有在看的书都转移到 Kindle 上去。</p><p>2018 年年初其实制定了一个非常高难度的计划，实现了其中最核心的部分，我个人觉得是幸运且满足的。2018 年似乎也是一个大环境非常不好的一年，「经济衰退」、「资本寒冬」在 2018 年的冬季被各种媒体频频提起，这似乎让 2019 更加让我期待，因为那意味着更加强烈的变化。变化和起落才是世界的真相，而太多人对自我、对世界有太大的误解，对人性和环境有太高的期待，太执拗于自我而丧失了格局。这也是今年我自我感觉更成熟的地方之一，经历得更多也越来越包容，接受各种各样的不同、缺憾、丰富和可能性，但同时也有了更坚定的自我意识。</p><p>另一个今年值得一提的收获是开始探索了一个全新的领域并乐在其中，这也是一个很可能对人生有很大影响的领域。我一直推崇「顿悟」式的习得方式，因为大部分事后复盘看起来比较重要的「获得」其实都非常偶然，可遇不可求，不管这背后的原因是来自于你长期的努力和平时的积累、目前所到达的境界和眼界还是纯粹的运气，就在那一刻，不多不少，不紧不慢，你突然有所发现，打开了新世界的大门。这背后个人努力对最终结果起到了多大的作用，并不好说。「偶然」也是世界的一种真相和常态，很多人对此也有很大的误解。作为人类我们唯一能做的，只能是尽可能多的去了解一些不一样的东西，以求能更贴近真相一些。</p><p>2019 年，我希望我可以更纯粹、更极致、更理想主义，坚定自我，从心所欲，也用更开放的胸怀和包容的态度待人接物，年度书单还将一直继续下去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年的个人状态要比去年好多了，好在心态的逐渐平和。毫无疑问，今年要比去年忙很多，工作和生活都是如此，不过事情也开始越来越聚焦，大概是一种越来越明白自己在做什么以及为什么要这样做的状态。&lt;/p&gt;&lt;p&gt;回到「书单」的正题。在&lt;a href=&quot;http://maples7.com/2016/12/31/2016-booklist/&quot;&gt;之前的年终书单总结&lt;/a&gt;中，我说过一般用 iPad 看电子书，今年引入了一个新设备 —— &lt;a href=&quot;https://www.amazon.com/All-new-Kindle-Paperwhite-Waterproof-Storage/dp/B07CXG6C9W&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kindle PaperWhite 4&lt;/a&gt;（官方名称是 “All-new Kindle Paperwhite”），这是目前为止最轻的一款 Kindle。之前我一直不理解用 Kindle 看电子书比用 iPad 看电子书好在哪里 —— 忍受着上世纪电子设备的响应速度，使用着非常有限的功能，就为了墨水屏？不用不知道，在真正使用了 Kindle 之后我发现，所有的「轻薄」、「有限的功能」、「电子墨水屏」等特性，都是为了让你在阅读时更加专注 —— 避免打扰、减少疲劳感。从中我体悟到一个道理，任何细微而又专注于目标的优势都不应该被忽视，它可能是一个产品制胜的关键。Kindle 所有的设计都是为了「阅读」这一场景而设计，尽管 iPad 有着丰富得多的功能，但对于体验敏感的用户来说，在「阅读」这件事情上还是会为了用户体验而买一个 Kindle。细小而专注的优势，很重要，不仅仅适用于电子设备产品，也适用于每一件事、每一个人本身。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浮生散记" scheme="http://maples7.com/categories/%E6%B5%AE%E7%94%9F%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="书单" scheme="http://maples7.com/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>基于 MySQL 的热数据与冷数据分离设计与实现</title>
    <link href="http://maples7.com/2018/12/25/hot-cold-data-based-on-mysql/"/>
    <id>http://maples7.com/2018/12/25/hot-cold-data-based-on-mysql/</id>
    <published>2018-12-24T19:28:51.000Z</published>
    <updated>2021-11-13T04:56:40.084Z</updated>
    
    <content type="html"><![CDATA[<p>作为<a href="https://www.seniverse.com/" target="_blank" rel="noopener">一家提供商业气象数据服务的创业公司</a>，我们一直都有一项「欠交的作业」没有完成，那就是合理的数据规划和数据治理规范。对于早期的初创公司而言，可能很难从一开始就能构想到需要对数据存储进行合理的规划并制定长期规范，大多都是简单使用单实例的数据库，直到随着业务增长数据量累积到一个不得不严肃考虑这个问题的地步。</p><h2 id="数据库发展简介"><a href="#数据库发展简介" class="headerlink" title="数据库发展简介"></a>数据库发展简介</h2><p>数据量的增长其实一直是随着互联网的发展呈现爆发式增长的，因为各种各样的数据都在不断的被原样或者是经过少量的更改和增补后拷贝到互联网的各个角落。为了适应互联网数据的海量增长，在后端和架构意义上而言，数据库的发展也大致经历了「单库单表 -&gt; 主从读写分离 -&gt; 分表分库 -&gt; NoSQL -&gt; NewSQL」这样的过程。</p><a id="more"></a><p>一开始，我们把数据都堆在一个数据表里；后来为了提高性能、增加数据扩展的能力，采用了「主从读写分离」和「分表分库」的方式，前者只需要在主从实例之间做数据同步而不会对既有业务有较大的影响，后者则需要用一套切合业务逻辑的方式合理的制定分表分库的策略；再后来出现的 NoSQL，打破了传统关系型数据库固有的一些限制，它们有不同的类型，有的是为了解决高性能读写的需求，有的则是为了解决海量数据存储的需求，还有的需要数据结构本身具备可扩展性；NoSQL 的不同类型在不同的侧重点解决了不同的问题，而如今出现的 NewSQL 则倾向于把数据库看作是一个黑匣子服务，你还是可以遵照传统的数据库协议的使用方式（比如传统 MySQL 的使用方式）来使用它，但数据存储服务本身既可以同时具备较高的读写性能又可以轻易的实现横向扩展。NewSQL 并不是一个全新的东西，我们可以把它看作是之前积累的数据库技术结合分布式技术的集大成解决方案，它使得使用数据服务的人几乎不需要再考虑性能和扩展问题，而尽量在数据服务内部实现高可用、高性能、可扩展。</p><h2 id="「热数据」和「冷数据」"><a href="#「热数据」和「冷数据」" class="headerlink" title="「热数据」和「冷数据」"></a>「热数据」和「冷数据」</h2><p>在简单了解了数据库发展历程之后，再介绍一下我们目前在数据存储上遇到的问题和一些业务背景。</p><p>作为气象大数据服务商，随着我们积累的数据量和数据种类越来越多，我们发现我们已经迫切需要一个在全局层面统一的数据路径规划和规范。很多时候，我们从数据源获取到的数据，既需要马上分发给线上用户，也需要被内部项目使用，如果只是简单的按需实现，那数据流转会非常混乱。基于这种考虑，我们引入了「热数据」（「在线数据」）和「冷数据」（「离线数据」）的概念：</p><ul><li><p>「热数据」指的是需要即时对用户进行分发的数据，即从数据源抓取之后经过数据清洗，需要即时存储到可以快速分发的存储介质（如 Redis）供 API 或直接面向用户的系统使用。「热数据」线需要重点保障服务质量和稳定性，为了保证数据的时效性，在数据处理上也是优先级高的数据。「热数据」可能是临时或短期存储的，后来的数据可能会覆盖已有的数据。</p></li><li><p>「冷数据」指的是不需要即时分发给用户的数据，这些数据甚至可能永远都不会原样分发给用户的，但它们需要经过长期的积累，使我们可以从中得出基于此的更高 level 的分析。「冷数据」典型的使用场景是供内部数据评估系统做数据准确度的评估分析，同时也可以给算法团队建模使用。设立这个数据线的原则是不影响「热数据」的服务质量，尤其是时效性和稳定性，同时也满足一些非线上项目的数据使用需求。</p></li></ul><p><img src="https://i.loli.net/2018/12/25/5c213783d5c3e.png" alt="热数据线和冷数据线设计"></p><p>这其实也不是什么新鲜的概念，很多做数据服务的公司都有类似的设计，我们只是根据我们的业务特点借用了这样的概念，不过它们的含义可能与你在其他地方看到的类似概念的含义有所不同。</p><p>结合我们具体的业务场景来说，「热数据」线其实已经一直在有效运转了，即我们从数据源获取到数据然后尽快存储到高性能存储介质中，再通过 HTTP 协议分发出去，这些数据都是即时更新的最新的数据。而其中有一些类型的数据，我们还需要在可视化项目中查看历史变化情况，并能进行简单的聚合和计算，这意味着数据需要积累一段时间，那我们也需要一些可以持久化存储的介质。</p><p>拿天气实况来举例，我们在采集完数据之后，随即就存储最新的一份数据到 Redis，而出于数据积累的角度考虑，我们同时也把新数据写入 MySQL。这是之前我们的做法，然而随着数据量的极速扩大，问题很快就会出在 MySQL 上。对于「亿」级别行数往上的 MySQL 单表，操作会变得越来越困难，而大范围的抽数或者插入数据的操作都可能使得整个 MySQL 无法提供服务，这对于线上业务而言是不可接受的。</p><h2 id="离线数据中心的实现"><a href="#离线数据中心的实现" class="headerlink" title="离线数据中心的实现"></a>离线数据中心的实现</h2><p>在提出了「冷数据」的概念之后，我们意识到那些久远的历史数据其实需要存放到「冷数据」的数据中心池子里，而线上 MySQL 只需要保留最近一段时间的数据即可。另外，为了不改变现有项目使用数据的方式，降低数据库使用者的门槛，不管是对于线上数据库还是「离线数据」的数据中心，我们都需要兼容 MySQL 单表的使用协议。</p><p>很快我们就开始考虑 NewSQL 的方案，<a href="https://github.com/pingcap/tidb" target="_blank" rel="noopener">TiDB</a> 很自然地进入了我们的视野，这是一个既可以兼容现有数据使用方式，又可以实现数据横向扩展的完美方案，但无奈搭建一个最小版本的 TiDB 数据集群的成本，相比于目前我们把它作为一个「离线数据」存储中心的角色而言，还是有一些偏高，而我们的存量服务也基本都是基于阿里云的，所以最终我们选择了阿里云推出不久的云数据库 <a href="https://www.aliyun.com/product/polardb" target="_blank" rel="noopener">PolarDB</a>。其间我们还研究了很多其他数据库方案，比如 <a href="https://www.aliyun.com/product/drds" target="_blank" rel="noopener">DRDS</a>、<a href="https://oceanbase.alipay.com/" target="_blank" rel="noopener">OceanBase</a>、<a href="https://cloud.google.com/spanner/" target="_blank" rel="noopener">Google Cloud Spanner</a>、<a href="https://aws.amazon.com/cn/rds/aurora/" target="_blank" rel="noopener">Amazon Aurora</a> 等。</p><h2 id="数据同步和数据过期"><a href="#数据同步和数据过期" class="headerlink" title="数据同步和数据过期"></a>数据同步和数据过期</h2><p>有了离线数据存储中心之后，我们开始考虑如何把「热数据」转化为「冷数据」，同时也使得线上数据库可以自动过期超出时间窗口的历史数据。另外，由于内部可视化项目也希望看到实时的实况数据，所以离线数据最好也能很快获得最新的实况数据。</p><p>既然是两个 MySQL（集群）之间的实时数据转移，很自然的就想到了我们可以做类似主从节点之间通过 binlog 的数据同步机制，这个同步可以做到秒级延迟，在实时性上是完全可以接受的。不过这不能是简单的数据同步，因为离线数据是不能同步线上数据的过期操作的。更具体的，我们可以概括成：MySQL 从节点同步主节点所有数据增添和数据修改的操作，而对于数据的删除操作不做同步。</p><p>在调研之后，我们发现 TiDB 提供的同步工具 <a href="https://pingcap.com/docs-cn/v3.0/reference/tools/syncer/" target="_blank" rel="noopener">Syncer</a> 可以实现这一点，我们只需要在配置注明过滤掉 DELETE 的 DML 语句即可，示例如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[skip-dmls]]</span></span><br><span class="line"><span class="attr">db-name</span> = <span class="string">"weather_data"</span></span><br><span class="line"><span class="attr">tbl-name</span> = <span class="string">"weather_now_history"</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">"delete"</span></span><br></pre></td></tr></table></figure><p>而数据过期方案则可以直接借助 MySQL 本身的 EVENT 和 PROCEDURE 机制完成。首先我们可以创建一个删除数据的 PROCEDURE：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER=<span class="string">`weather`</span>@<span class="string">`%`</span> <span class="keyword">PROCEDURE</span> <span class="string">`weather_data`</span>.<span class="string">`del_old_data`</span>(<span class="keyword">IN</span> <span class="string">`date_inter`</span> <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">from</span> weather_data.weather_now_history <span class="keyword">where</span> datetime &lt; <span class="keyword">date_sub</span>(<span class="keyword">curdate</span>(), <span class="built_in">interval</span> date_inter <span class="keyword">day</span>);</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>这个 PROCEDURE 功能是删除 <code>weather_now_history</code> 表中 <code>date_inter</code> 天之前的数据。然后我们再创建一个 EVENT：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EVENT</span> del_old_data</span><br><span class="line"><span class="keyword">ON</span> SCHEDULE EVERY <span class="number">1</span> <span class="keyword">DAY</span></span><br><span class="line">STARTS <span class="string">'2018-12-25 10:08:35.000'</span></span><br><span class="line"><span class="keyword">ON</span> COMPLETION <span class="keyword">PRESERVE</span></span><br><span class="line"><span class="keyword">ENABLE</span></span><br><span class="line"><span class="keyword">DO</span> <span class="keyword">call</span> del_old_data(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>这个 EVENT 则会每天调用一次名为 <code>del_old_data</code> 的 PROCEDURE，并同时把 <code>date_inter</code> 赋值为 <code>30</code>。这意味数据库每天会删一次数据，使得线上数据库一直只保留最近 30 天的数据，而全量的数据是在数据写入时就实时同步到了离线数据中心，可谓完美。</p><h2 id="持续改进"><a href="#持续改进" class="headerlink" title="持续改进"></a>持续改进</h2><blockquote><p>All problems in computer science can be solved by another level of indirection.<br>—— David Wheeler</p></blockquote><p>上述的具体业务场景更多的还是 case by case 的解决了「热数据」和「冷数据」的分离和转化问题，这意味着方案并不具有普适性，以后我们遇到其他的数据库或者不同的数据使用场景可能就不再适用。另外，很多时候，「热数据」和「冷数据」的划分并不是那么明晰的，对于「冷数据」的需求有可能转变为「热数据」需求，我们需要可以灵活切换的机制，做到数据源只抓取一次（「热数据」和「冷数据」不要分别抓取），而抓取到的数据可以任意自由的流淌到「热数据」或「冷数据」线使用，这意味着我们在数据抓取和数据存储之间应该再做一层隔离。</p><p>要实现数据抓取和数据存储之间的隔离，我们可以采用「发布/订阅模式」：简单说，数据抓取服务在获取数据之后将数据发布到消息队列，后面的存储服务任意订阅这个消息队列再做存储，这样数据源只需要抓取一次，我们可以把它作为热数据使用，也可以作为冷数据使用，甚至可以即作为热数据又作为冷数据使用，切换起来也十分简单。这是后续系统架构可以改进的一个地方。</p><p>另外，离线数据中心仅仅使用 PolarDB 对于我们可能产生的数据量级而言也是远远不够的，我们还需要更低成本的数据存储方案来存储时间更久远、平时几乎不大会访问的一些需要被「归档」的数据，这个时候，一些基于列存储的 NoSQL 数据库可能可以派上用场。</p><p>数据治理需要一个长期持续的过程，我们还在结合自身的业务场景不断的摸索当中。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/36112488" target="_blank" rel="noopener">TiDB 在饿了么归档环境的应用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为&lt;a href=&quot;https://www.seniverse.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一家提供商业气象数据服务的创业公司&lt;/a&gt;，我们一直都有一项「欠交的作业」没有完成，那就是合理的数据规划和数据治理规范。对于早期的初创公司而言，可能很难从一开始就能构想到需要对数据存储进行合理的规划并制定长期规范，大多都是简单使用单实例的数据库，直到随着业务增长数据量累积到一个不得不严肃考虑这个问题的地步。&lt;/p&gt;&lt;h2 id=&quot;数据库发展简介&quot;&gt;&lt;a href=&quot;#数据库发展简介&quot; class=&quot;headerlink&quot; title=&quot;数据库发展简介&quot;&gt;&lt;/a&gt;数据库发展简介&lt;/h2&gt;&lt;p&gt;数据量的增长其实一直是随着互联网的发展呈现爆发式增长的，因为各种各样的数据都在不断的被原样或者是经过少量的更改和增补后拷贝到互联网的各个角落。为了适应互联网数据的海量增长，在后端和架构意义上而言，数据库的发展也大致经历了「单库单表 -&amp;gt; 主从读写分离 -&amp;gt; 分表分库 -&amp;gt; NoSQL -&amp;gt; NewSQL」这样的过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="一只代码狗的自我修养" scheme="http://maples7.com/categories/%E4%B8%80%E5%8F%AA%E4%BB%A3%E7%A0%81%E7%8B%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="MySQL" scheme="http://maples7.com/tags/MySQL/"/>
    
      <category term="热数据" scheme="http://maples7.com/tags/%E7%83%AD%E6%95%B0%E6%8D%AE/"/>
    
      <category term="冷数据" scheme="http://maples7.com/tags/%E5%86%B7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="在线数据" scheme="http://maples7.com/tags/%E5%9C%A8%E7%BA%BF%E6%95%B0%E6%8D%AE/"/>
    
      <category term="离线数据" scheme="http://maples7.com/tags/%E7%A6%BB%E7%BA%BF%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>长按是好的交互方式吗？</title>
    <link href="http://maples7.com/2018/12/19/long-press-sucks/"/>
    <id>http://maples7.com/2018/12/19/long-press-sucks/</id>
    <published>2018-12-18T16:42:27.000Z</published>
    <updated>2021-11-13T04:56:40.083Z</updated>
    
    <content type="html"><![CDATA[<p>长按是好的交互方式吗？</p><p>这个问题虽然微小但其实困扰了我本人很久。每当我拿起索尼头戴式耳机，忍受着右手以一种不那么舒服的姿势，心里充满不确定性和不安全感地用自己的大拇指紧紧按住电源键几秒钟试图开机或关机时，我都会反复的问自己：长按是一种好的交互方式吗？</p><p>智能手机时代，最开始接触到「长按」这种交互方式，大概始于智能手机的电源键。记忆里，在 iOS 系统中，「长按电源键」一开始是唤出关机界面「滑动已关机」的交互方式，而在新款 iPhone 搭配的 iOS 中，「长按电源键」是唤醒 Siri 的一种方式。</p><a id="more"></a><p>除了平时最长接触到的手机，「长按」交互在各种音乐相关的电子设备上也常见，比如各种便携式音箱和头戴式耳机<del>（也不知道是音箱「抄」了耳机，还是耳机「抄」了音箱）</del>。在我的索尼 SRS-X11 小音箱上，「短按电源键」是开关，「长按电源键直到听到哔声」会进入蓝牙配对模式。而在索尼 WH-CH500 头戴式耳机上，「长按电源键约 2 秒」是开关耳机，「长按电源键约 7 秒」会让耳机进入蓝牙配对模式，这几乎是目前我所有电子设备中让我最想吐槽的交互方式。</p><p>不管是 iPhone 还是索尼的这两款音乐电子设备，都是大众电子消费品。对于我个人而言，长按的交互方式在 iPhone 和 SRS-X11 上的设计是合格的，在 WH-CH500 上的设计则完全不合格，这几乎是初级产品经理或交互设计师都不应该犯的设计错误。</p><p>作为一名软件开发工程师，我并不知道「长按」在交互设计上是否有硬件技术或工程上的考量，这里仅从用户体验的角度来妄自品评一下。</p><p>首先，「长按」交互本身是一种怎样的体验？</p><p>第一，「长」不是一个可以量化的形容词。我并不知道我需要按多久才算「长」，每个人对于「长」的理解是不一样的，用户由此在心中产生的不确定性疑惑和不安全感最终会转化成对产品的不信任，使得用户体验大打折扣。更不用说「长按 2 秒是 A 操作而长按 7 秒是 B 操作」这种失败设计了：我要是不小心长按了 3.5 秒会怎么样？多长时间是 7 秒呢？我需要用秒表数吗？现在我已经按几秒了？</p><p>第二，「长」这个字首先就说明了这是一个需要用户<strong>持续</strong>用力的<strong>过程</strong>，可以说非常不友好。在这个快节奏的社会，人们都在追求<a href="http://maples7.com/2016/08/24/understand-sync-async-and-blocking-non-blocking/">「异步非阻塞」式的交互方式</a>：所谓「异步」，我希望我调用了任务之后可以在它完成后主动通知我；所谓「非阻塞」，在这个任务执行的过程中我希望我自己是自由的，可以去做任何我想做的事情，我作为独立个体是完全解放的。虽然「长按」交互本身是一个时间上并不算长的交互，但它几乎带给我几秒钟的「同步阻塞」的体验，这意味着我的 CPU —— 大脑 —— 甚至需要一直关注在我的长按操作上，并且要不断的 check 我的操作是否成功了。这简直「反现代人类」。</p><p>第三，「长按」的重试成本很高。「长按」本身就是一个耗时操作，假设在我的一阵不安的惊恐长按操作之后，产品并没有实现我预期的效果，我首先可能会怀疑 —— 是它还在「反应中」吗？操作本身的延时性会让人怀疑是不是这个操作产生的结果也是耗时的，这意味着我需要等。如果稍等片刻之后大概率确信是刚才的操作失败，我就需要不断的重试，这是一个接一个「同步阻塞」的耗时操作。</p><p>对于 C 端产品而言，好的交互应该是自然而然的，在你进行过操作之后你不需要意识到你做过了什么，也不需要怀疑自己，产品就已经给了你想要的东西。而「长按」的交互方式违背了这一点。</p><p>那「长按」交互的设计初衷是什么呢？我想本质上是为了使得操作本身不那么容易被触发。所以接下来，我们再结合具体产品的使用场景来琢磨一下这个交互方式。</p><p>在 iPhone 上，无论是「开关机」操作还是「唤醒 Siri」的操作，都不算是常用操作，而且由于电源键的位置正好是单手拿起握住时食指所在的位置，削弱了「长按」操作本身的「存在感」；在 SRS-X11 上，「长按」仅用于蓝牙配对，这本身也是一个很低频的操作；而在 WH-CH500 上，「长按」居然被用在了耳机开关这种高频操作上，在有时不确定设备是否是开启状态而又不想把它从头上摘下来看指示灯的状态的时候，我甚至需要先长按试试耳机是开机状态还是关机状态，如果不幸把它按关机了我还需要再长按一次来开启它。更不必说「长按不同时间产品会响应不同的操作结果」了，这几乎是一个类似于用多进制计算机取代二进制计算机的失败设计，加剧了系统的不稳定性和用户体验的不确定性。似乎几乎所有的索尼头戴式耳机都是采用的「长按电源键进行开关」的交互设计，我非常希望他们能仔细考虑一下这一点。在我看来，即便是拨动式的开关设计也比长按来开关耳机的交互体验要好。</p><p>综上所述，从具体产品的使用场景上来说，「长按」其实类似于软件开发中日志等级的 WARNING 级别，不是日常信息且需要一些用户的注意力，如果用户需要使用到这个操作，那希望他是有一定的意识清楚自己在做什么的。按这个类比，日常的点按、滑动等无意识操作算是 INFO 级别的日志；而非紧急情况下不应该使用的操作，比如 iOS 里的「SOS 紧急呼叫」、楼道里需要砸破玻璃才能按下的消防按钮等，应该归类到 ERROR 级别。</p><p>希望以后的产品设计师在选择使用「长按」作为交互方式时都能走点心，而不仅仅是按照所谓的「传统如此」。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;长按是好的交互方式吗？&lt;/p&gt;&lt;p&gt;这个问题虽然微小但其实困扰了我本人很久。每当我拿起索尼头戴式耳机，忍受着右手以一种不那么舒服的姿势，心里充满不确定性和不安全感地用自己的大拇指紧紧按住电源键几秒钟试图开机或关机时，我都会反复的问自己：长按是一种好的交互方式吗？&lt;/p&gt;&lt;p&gt;智能手机时代，最开始接触到「长按」这种交互方式，大概始于智能手机的电源键。记忆里，在 iOS 系统中，「长按电源键」一开始是唤出关机界面「滑动已关机」的交互方式，而在新款 iPhone 搭配的 iOS 中，「长按电源键」是唤醒 Siri 的一种方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浮生散记" scheme="http://maples7.com/categories/%E6%B5%AE%E7%94%9F%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="交互设计" scheme="http://maples7.com/tags/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="产品" scheme="http://maples7.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>完全理解并发</title>
    <link href="http://maples7.com/2018/10/21/understand-concurrency/"/>
    <id>http://maples7.com/2018/10/21/understand-concurrency/</id>
    <published>2018-10-20T21:10:52.000Z</published>
    <updated>2021-11-13T04:56:40.083Z</updated>
    
    <content type="html"><![CDATA[<p>越是往后端深入到 Web 开发和分布式系统，就越会觉得把「并发」理解清楚是多么重要，而每天的日常工作中很多时候都需要处理与并发有关的话题，大到整个系统架构层面的并发考量，小到某一段代码的并发控制。</p><p>本来不想把这篇文章加入到<a href="http://maples7.com/tags/「完全理解」系列/">「完全理解」系列</a>，因为觉得「并发」涉及到的东西实在是很多，而我想凭借一篇博客企图「完全理解」那是不现实的。但虽然不能做到「完全理解」，但我还是会尝试尽力提纲挈领的把「并发」相关的话题都理清楚，把脉络勾勒出来，让它尽可能对得起「完全」吧。<del>毕竟，如果以后我有了一些更深的理解，我还可以继续迭代这篇文章。</del></p><a id="more"></a><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>在开始正式的话题之前，我们先来厘清两个概念——「并发」与「并行」。</p><p>Erlang 之父 Joe Armstrong 曾经用一张非常简单易懂的图解释了「并发」与「并行」的区别：</p><p><img src="https://i.loli.net/2018/08/06/5b67309e4d019.jpg" alt="Joe Armstrong 解释「并发」与「并行」"></p><p>「并发」是同学们排成两队，然而却只有一个咖啡机在工作，所以两个队列排在前面的同学交替使用咖啡机；「并行」则是两台咖啡机分别服务两个独立的同学队列，它们同时进行，互不干扰。</p><p>这样的例子简单易懂，但依然还需要更进一步说明的是，「并发」与「并行」其实并不是同一个维度上非黑即白的两个对立的概念。「并发」更多的强调的是有没有这样的能力或特征，它是从事物的性质和对外表现上来说的，它不在乎你内部是如何实现「并发」的，相对而言是在更高层次上的概括，而「并行」则规定了它们在物理上一定是同时进行的，相对而言更严格。</p><p>具体从编程的角度来说，「并行」甚至可以是实现「并发」的一种手段，比如用下文所要讲的「多线程」或「多进程」的方式来赋能某一段程序的「并发」能力：为了使程序具备「并发」的能力，采用「多线程」或「多进程」在应用层面上可以「并行」运行的具体实现手段来为其赋能。</p><h2 id="计算机操作系统发展史"><a href="#计算机操作系统发展史" class="headerlink" title="计算机操作系统发展史"></a>计算机操作系统发展史</h2><p>要追根溯源的来理解「并发」，我们首先应该了解一下计算机操作系统的发展历史。因为回顾整个计算机操作系统的发展历史，我们就会发现，几乎所有的关键历史节点，都是因为它使得计算机系统拥有了更强的并发处理能力而变得重要的。</p><p>在计算机诞生之初，是没有操作系统这种东西存在的，当时人们只能先把打孔纸带通过输入机将程序传入计算机，再启动运行。在程序执行完毕之后，打印机把计算结果输出，在现场监督程序执行的程序员再取走纸带。在这个时期，同一个计算机系统在同一时间只能处理唯一确定的一件事情。</p><p>后来人们发明了批处理系统。批处理系统相当于计算机上的一个任务监督程序，在它的控制和调度下，计算机能够自动的、成批的处理一个或多个用户的任务。在批处理系统的帮助下，各个任务之间可以自动衔接，减少了需要人工建立任务和手工操作的时间，提高了计算机的利用效率。</p><p>再后来，随着 CPU 性能的不断提升，出现了分时系统和实时系统。分时系统是把 CPU 的运行时间分成很短的时间片，按时间片轮流把 CPU 分配给各联机任务使用。若某个任务在分配给它的时间片内不能完成其计算，则该任务暂时中断，把 CPU 让给另一任务使用，等待下一轮调度时再继续其运行。由于计算机速度很快，各个任务之间轮转得也很快，给每个用户的感觉是他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。为了解决分时系统不能及时响应用户指令的情况，又出现了能够在严格的时间范围内完成事件处理、及时响应随机外部事件的实时系统。</p><p>IBM 于 1964 年伴随着大型机 System/360 推出了通用操作系统 OS/360，这个通用的操作系统使得不同型号的计算机设备也可以在同样的操作系统控制下使用同样的外部设备（如打印机）和更上层的软件，并且这些设备之间可以相互连接，共同工作。通用操作系统使得不同型号的计算机设备之间能够真正组成网络来处理复杂的任务。<del>软件工程领域的著作<a href="https://book.douban.com/subject/2230248/" target="_blank" rel="noopener">《人月神话》</a>也是诞生于 IBM 的这个项目。</del></p><p>再往后就是我们相对更加熟悉的 Unix/Linux/Windows/OS X 这些现代操作系统诞生、迭代、版本更替的历史，目前这些操作系统的并发能力已经远远超出了当时的 OS/360，而现代计算机网络的加持更是使得理论上的计算机并发处理能力几乎已经没有了上限。</p><p>从整个计算机操作系统的历史我们可以清晰的看到历史上的计算机科学家们是如何一步一步来提升计算机处理任务的效率的。从一开始需要手工的开启、监督、结束单一任务，到使用批处理系统来自动化的监督任务流水线，再到使用分时系统来让 CPU 在多个任务之间不停的轮转，然后用后文要详述的多 CPU 使用多进程和多线程的方式来进一步提升多任务的执行效率，最后我们使用通用计算机系统来组成庞大的计算集群来处理复杂的各种各样需要随机响应的任务，并发能力一次比一次有了质的提升。</p><p>如果说<a href="https://zh.wikipedia.org/wiki/摩尔定律" target="_blank" rel="noopener">「摩尔定律」</a>使得 CPU 的性能可以指数级的增长来从单机速度上提升任务完成的效率，那么不断的提升并发能力则是更高屋建瓴的考虑如何不间断不浪费的来「压榨」CPU 的高性能，这种思考问题的维度比一门心思的考虑提升单 CPU 的速度更具有现实意义，对于解决现有问题来说是更加高明的选择。尤其是在「摩尔定律」行将失效的今天，采用分布式的方式提高整个系统的并发处理能力几乎成了唯一的选择。</p><h2 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h2><p>让我们先回到单机时代，来了解目前主流的并发模型——多进程与多线程。现代操作系统早已进入多 CPU 时代，自然会支持多进程和多线程。「进程」就是操作系统中一个具有独立功能的程序，操作系统管理所有进程的执行并且以进程为单位分配存储空间。一个进程还可以拥有多个并发的执行流程，这些并发的执行流程是可以获得 CPU 调度和分派的基本执行单元，也就是线程。</p><p>进程是计算机资源的拥有者，创建、切换和销毁都有较大的时空开销，而一个进程内的所有线程共享这个进程的资源，更轻量级，对其的相关操作也开销更小。需要注意的是，对于单核 CPU 系统而言，并行其实是不存在的，任何时刻 CPU 其实只能被一个线程所获取，线程之间共享了 CPU 的执行时间。由于切换的速度很快，对外表现为并发执行的样子。</p><p>多进程和多线程是如今高级编程语言中实现并发的常规模型，比如 C++、Java、Python。同时为了解决程序中多个进程和线程对资源的抢占问题，还引入了「锁」的概念。在这个并发模型中，需要开发人员利用「锁」来处理资源抢占的问题，也就是不让某一个资源同时被多于一个进程（线程）所处理而带来不可预期的后果。</p><p>既然有多进程和多线程，那么「锁」自然也有「进程锁」和「线程锁」。我们知道两个进程其实是相互独立的，各自拥有操作系统分配的独立资源，而「进程锁」是为了防止两个进程对他们所占用的资源以外的共享资源同时访问，一般可以使用操作系统级别的信号量来实现。相对应的，「线程锁」则是保证同一段代码在同一时间只有一个线程在执行，一般各语言本身或类库会提供实现方式。</p><h2 id="分布式并发锁"><a href="#分布式并发锁" class="headerlink" title="分布式并发锁"></a>分布式并发锁</h2><p>「分布式锁」跟「进程锁」和「线程锁」很像，不过它更多的是使用在计算集群的场景中。在本质上，进程锁、线程锁和分布式锁的作用都是一样的，只是作用的颗粒度不一样。线程锁作用于单一进程的范围，进程锁作用于单一操作系统的范围，而分布式锁则可以作用于网络结构中。在分布式集群当中，我们使用分布式锁来保证不同线程对代码和资源是独占的。</p><p>如何实现一个完美的分布式锁呢？我们先来分析一下实现一个好的分布式锁应该满足什么需求：首先这个加锁操作应该是原子性的，否则这个锁是有可能被「击穿」的；其次锁一般还需要有过期时间，使得某一次执行异常没有移除锁的情况下也能自然过期然后重试。</p><p>以大多数人都熟悉的 Redis 为例，我们可以使用 Redis 的 set 指令，把 key 作为锁的标志。尤其注意的是，这个操作原子性包含了查看锁存不存在、加锁和设置过期时间三步操作，它们合在一起应该具有原子性（至少前两步）。也就是说，如果我们需要先使用 get 指令查看锁存不存在再决定是否加锁，这个锁已经不是一把好「锁」了。好在 <a href="https://redis.io/commands/set" target="_blank" rel="noopener">Redis 2.6.12 以上的 set 指令</a> 支持了同时加参数设置过期时间和判断 key 是否存在，比如使用 <code>SET lock_key lock EX 5000 NX</code>，NX 保证了锁不存在时才上锁，而 Redis 指令本身具有原子性，这样就实现了一把看起来还不错的锁。在任务执行完毕后我们还需要用 del 指令主动把锁删掉以释放资源。</p><p>上述例子只是一个简单的场景，这个锁其实还并不是完美的。思考这样的问题：如果某一次操作线程 A 执行的特别慢，超过了过期时间，这个时候锁已经自动过期失效了，这样就有可能两个线程同时在执行了。如何避免这样的问题这里不再详述，感兴趣的同学可以参考末尾 References 里面的内容。总之，实现一把完美的分布式锁可能并没有想象中那么简单。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>对于高级编程语言而言，多进程和多线程的并发模型更多的还是与操作系统底层对于并发的实现是保持一致的。也就是说，在它们的抽象层级上，实现并发的方式基本只是复刻了操作系统底层的并发模型。而 JavaScript 却不一样。</p><p>JavaScript 在诞生时就被定位为在网页前端执行的脚本，为了保证线程安全，而且主线程也不会被 I/O 等待所阻塞而失去响应，JavaScript 在设计阶段就采用了「异步事件模型」。这个模型并不是 JavaScript 独有的，它只是借用了这个古老的模型来解决它自身的问题。</p><p>在实际情况中，异步事件模型也是采用多线程的方式来实施的。但是对于开发人员而言，你永远只需要跟主线程打交道，而所有的这些交互都是所谓「异步」的，也就是说，你调用的任何一个 API 都在执行成功后主动告知你执行结果，这样你就可以不必被任何 I/O 所堵塞（详细的关于异步、同步、阻塞和非阻塞的辨析可以看这里：<a href="http://maples7.com/2016/08/24/understand-sync-async-and-blocking-non-blocking/">《完全理解同步/异步与阻塞/非阻塞》</a>）。既然不会被阻塞，那么你可以以很快的速度调用很多个你需要调用的 I/O，这些 API 在自己执行完毕后会主动返回结果，你可以拿着结果来继续做后续的事情，而其他时刻你完全是「自由」的。</p><p>在这个并发模型中，你不再需要处理各种「锁」的问题，因为真正和你交互的只有主线程。可是作为开发者，你可能需要考虑如何处理代码中的各种异步流程。因为在异步的世界里，代码不再是简单的按照书写顺序来顺序执行的，如何在工程中清晰合理的组织这些流程是在这个并发模型下需要考虑的问题。</p><h2 id="各种各样的并发模型"><a href="#各种各样的并发模型" class="headerlink" title="各种各样的并发模型"></a>各种各样的并发模型</h2><p>这个世界上除了多进程/多线程的并发模型和异步事件并发模型，还有很多其他的并发模型，比如 Erlang 的 Actor 并发模型和 Golang 的 CSP 并发模型。在 Erlang 的并发世界里，有很多比内核线程还要轻量级的对象，它们之间通过各种 Message 来进行数据共享。这些对象非常轻，可以同时成千上万的被创建出来实现并发，而对象之间都通过发消息来进行数据交换，根本不需要「锁」。</p><p>在一个没有「锁」的世界里，并发的效率是可以大大的提升的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每一个并发模型都有其存在的意义和价值，不过在具体的业务场景下，采用不同的并发模型的好坏却是客观的。</p><p>真理是存在的，可以被不断逼近却永远无法被任何事物所完美诠释。在技术的领域里，没有永恒的真理，但是真理永远值得被追求。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://book.douban.com/subject/26337939/" target="_blank" rel="noopener">《七周七并发模型》</a></li><li><a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python-100-Days</a></li><li><a href="https://www.itcodemonkey.com/article/3934.html" target="_blank" rel="noopener">漫画：什么是分布式锁？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越是往后端深入到 Web 开发和分布式系统，就越会觉得把「并发」理解清楚是多么重要，而每天的日常工作中很多时候都需要处理与并发有关的话题，大到整个系统架构层面的并发考量，小到某一段代码的并发控制。&lt;/p&gt;&lt;p&gt;本来不想把这篇文章加入到&lt;a href=&quot;http://maples7.com/tags/「完全理解」系列/&quot;&gt;「完全理解」系列&lt;/a&gt;，因为觉得「并发」涉及到的东西实在是很多，而我想凭借一篇博客企图「完全理解」那是不现实的。但虽然不能做到「完全理解」，但我还是会尝试尽力提纲挈领的把「并发」相关的话题都理清楚，把脉络勾勒出来，让它尽可能对得起「完全」吧。&lt;del&gt;毕竟，如果以后我有了一些更深的理解，我还可以继续迭代这篇文章。&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="一只代码狗的自我修养" scheme="http://maples7.com/categories/%E4%B8%80%E5%8F%AA%E4%BB%A3%E7%A0%81%E7%8B%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="「完全理解」系列" scheme="http://maples7.com/tags/%E3%80%8C%E5%AE%8C%E5%85%A8%E7%90%86%E8%A7%A3%E3%80%8D%E7%B3%BB%E5%88%97/"/>
    
      <category term="并发" scheme="http://maples7.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>2017 年书单</title>
    <link href="http://maples7.com/2017/12/31/2017-booklist/"/>
    <id>http://maples7.com/2017/12/31/2017-booklist/</id>
    <published>2017-12-31T10:42:34.000Z</published>
    <updated>2021-11-13T04:56:40.083Z</updated>
    
    <content type="html"><![CDATA[<p>今年太「荒废」了。无论是工作还是生活，已经发生的事情之丰富复杂相比去年完全有过之而无不及，自己心态上的改变也是不少。这种内省式的变化会直接导致个人情绪的变化。用一个烂俗的比喻来说，如果去年的心情像一汪平静的湖水，那今年则可以用海啸来形容<del>（夸张到油腻了）</del>。</p><p>我不是一个喜欢制定目标的人，因为无论事情是否达到了你的目标，这个设定都会让你对于自己所做的事情产生反向的反馈：完成了会开始沾沾自喜、放松警惕，没完成则会开始怀疑人生、消极懈怠。当然，这可能只是一个现实的悲观主义者的惯性思维，不足以为参考。</p><p>即便如此，年初也制定了一些小目标，明确了一下「即将过去的这一年」的大致方向。写博客的目标是超额完成了，导致我后几个月的博客更新都放缓了（应证了我上一段的描述），可是看书的目标远远没有达到。这意味着今年是个「输出」大于「输入」的一年。</p><a id="more"></a><p>开篇不多说，今年的书单如下：</p><ol><li><p><a href="https://book.douban.com/subject/27013716/" target="_blank" rel="noopener">沉默的大多数</a>：★★★★★<br>每一句话的笔触都轻，但合起来的力道却很重。三观正得惊人，王小波手执着民族的警钟。</p></li><li><p><a href="https://book.douban.com/subject/26729776/" target="_blank" rel="noopener">雪人</a>：★★★★☆<br>其实不能算典型的推理小说吧，不过读起来非常爽，文字画面感极强。虽然反转设计的痕迹很重，但非常有效的加强了故事的戏剧张力，自然就在一堆老掉牙的传统推理小说中脱颖而出了。</p></li><li><p><a href="https://book.douban.com/subject/26835090/" target="_blank" rel="noopener">软技能：代码之外的生存指南</a>：★★★★<br>我是听了译者在某个播客节目的介绍才了解到这本书的，而这本书的内容完全超出了我的预期。<br>首先，这本书的内容不是鸡汤，而是从作者的亲身体验给程序员打造的全方位工作、生活、学习、健身等等各个方面的实用建议。更重要的是这些建议中体现出的作者的技术价值观，我个人也非常认同。<br>目前市面上这类书不多，能跟上时代而不流于形式和灌鸡汤的就更少了。而且译者翻译的中译本很用心，强烈推荐。</p></li><li><p><a href="https://book.douban.com/subject/25910698/" target="_blank" rel="noopener">迷人的假象</a>：★★★★<br>一本现代大众心理学读物。<br>这个社会很多看似神秘的现象或许都可以从心理学的角度找到科学的解释，甚至可以加以利用。<br>而客观世界的大多数情况下，随机、偶然、无意义才是背后最大的真相，这样的真相又乏味又动人。</p></li><li><p><a href="https://book.douban.com/subject/26739566/" target="_blank" rel="noopener">途客圈创业记：不疯魔，不成活</a>：★★★★<br>对创业的描写可以说非常真实了，很多事情即便是我这种才进创业公司几个月的人都有些体会，或许大部分人心里都有一个创业梦吧。<br>作者及其团队包括复盘在内一些方法很值得学习，他写过的公众号文章我之前也基本是一篇不落的都看过，非常好。<br>创业维艰，一切都值得好好珍惜。</p></li><li><p><a href="http://survivor.ruanyifeng.com/" target="_blank" rel="noopener">未来世界的幸存者</a>：★★★☆<br>阮一峰老师还未出版的新书。<br>虽然不是所有的推论过程都十分赞同，但内容还是有一定的启发性，阮一峰老师能够看到事物之间的联系。</p></li><li><p><a href="https://book.douban.com/subject/25892728/" target="_blank" rel="noopener">Erlang 程序设计（第二版）</a>：★★★★★<br>其实并没有太深入扣代码细节的东西，但惊艳到我的还是 Erlang 实现并发的「与众不同」的设计思路，值得每一个后端程序员了解：<a href="http://maples7.com/2017/06/10/awesome-erlang/">《了不起的 Erlang》</a>。</p></li><li><p><a href="https://book.douban.com/subject/27059884/" target="_blank" rel="noopener">碟形世界：猫和少年魔笛手</a>：★★★☆<br>固然是好的童话故事，也明显可以看出作者就是在暗讽成人世界的一些事情（我愈发开始对这种用童话故事讨好成年世界的做法的动机变得敏感和怀疑，或许是受近年某些国产作品的影响，而且大多时候这些暗讽的内容已经被各种作品说了太多遍了，也没什么意思了），但腰封上宣传的「比《哈利·波特》和《魔戒》加起来还好看的」，仅就这一本来说，哪里来的自信？</p></li><li><p><a href="https://book.douban.com/subject/11941213/" target="_blank" rel="noopener">Learn Python the Hard Way(3rd Edition)</a>：★★★<br>一本非常适合新手入门的书，但我开始越来越不赞同用所谓的 “hard way” 的方式去学习新知，我觉得那只是对自己放弃更进一步去探索的借口和让自己心安的理由。知识是没有边界的，尽管放开了去学就好了，何必用 “hard way” 这种外在方式上的、形而下的枷锁来束缚自己呢？<br>Anyway, 今年大部分的工作时间是在用 Python 的，但对这门语言的自信程度还远不如 Node.js，甚至我并不确定它是否真的能让我达到对 Node.js 那样的感觉。依据我有限的经验，Python 在工程化上的实践成熟度比 Node.js 还是差了不少。</p></li></ol><p>人是复杂的，与人相关的所有事情都复杂，人的复杂之处体现在人性上；但「人群」却是简单的，因为你永远只需要往最坏的方向去想就好了。</p><p>我为什么在最后还莫名其妙的抛出这样的观点？你可以说世界是一直在向前发展的，也可以鸡贼的说世界是「螺旋式上升」的，但在大众认知领域，世界的发展其实是循环的。这大概是我所看到的 2017 年的最大的特征。</p><p>大众认知的底线无疑是在提高，但讨论的实质内容却并没有什么变化。大众热衷于讨论的不是知识，而是观点，而且是些早已经被无数前辈所表达的观点，绝大部分人只是在简单的跟随和重复。知识在信息洪流中的传播天生必然会败给观点，越来越多的人会选择「美味的糖果」而不是「苦口的良药」，依然是人性使然。大众永远在追逐社会热点，而社会热点的发生近乎「随机」。</p><p>不过说到这里，<a href="http://maples7.com/2016/11/27/traditional-edu-and-programming/">再一次</a>为了避免误会，还是得区分一下上文所说的「知识」与「观点」。知识是客观的、量化的、难以简单表达的，而观点则完全相反。只有知识才能产生创造，而观点并不能，甚至可能会扼杀创造。</p><p>所以，新的一年的一个大的方向就是——更多的学习知识，不要热衷于讨论观点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年太「荒废」了。无论是工作还是生活，已经发生的事情之丰富复杂相比去年完全有过之而无不及，自己心态上的改变也是不少。这种内省式的变化会直接导致个人情绪的变化。用一个烂俗的比喻来说，如果去年的心情像一汪平静的湖水，那今年则可以用海啸来形容&lt;del&gt;（夸张到油腻了）&lt;/del&gt;。&lt;/p&gt;&lt;p&gt;我不是一个喜欢制定目标的人，因为无论事情是否达到了你的目标，这个设定都会让你对于自己所做的事情产生反向的反馈：完成了会开始沾沾自喜、放松警惕，没完成则会开始怀疑人生、消极懈怠。当然，这可能只是一个现实的悲观主义者的惯性思维，不足以为参考。&lt;/p&gt;&lt;p&gt;即便如此，年初也制定了一些小目标，明确了一下「即将过去的这一年」的大致方向。写博客的目标是超额完成了，导致我后几个月的博客更新都放缓了（应证了我上一段的描述），可是看书的目标远远没有达到。这意味着今年是个「输出」大于「输入」的一年。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浮生散记" scheme="http://maples7.com/categories/%E6%B5%AE%E7%94%9F%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="书单" scheme="http://maples7.com/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>今晚月色真美</title>
    <link href="http://maples7.com/2017/12/21/love/"/>
    <id>http://maples7.com/2017/12/21/love/</id>
    <published>2017-12-20T16:40:40.000Z</published>
    <updated>2021-11-13T04:56:40.083Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5099468&auto=0&height=66"></iframe><p>这个世界上最复杂、最难以捉摸的事情是什么？</p><p>有人说，永远不要在晚上做任何一个决定，因为那是人一天中最不理性的时候。<br>我并不赞同。<br>如果所有的事情都由理性思维来主导，那这个世界上不会有音乐和诗歌，<a href="https://www.youtube.com/watch?v=L9jiPQAuTBw" target="_blank" rel="noopener">约翰·列侬、爱因斯坦、乔布斯、黑泽明也不会被人们传颂和铭记</a>。<br>夜深人静，是一个人能与自己对话的时候，也是最能看清自己心意的时候。</p><a id="more"></a><p>有一种感觉，我遗失了很久，最近又开始出现了。<br>也可能并不是我遗失了她。她一直在那儿，但我以为她已经不存在了。<br>这是一种什么样的感觉？<br>她会让人开始做奇怪的事情。<br>她会让头脑里产生更多的臆想和猜测。<br>她会让你的心时而悬着、时而放下。</p><p>人的一生中存在命中注定吗？<br>存在一个对其他人而言「正确」的人吗？<br>右边是被保护的位置吗？<br>人与人都是如何相遇的？<br>人的意识是怎样产生的？<br>地球为什么是圆的？<br>…………<br>噢，不，这些问题都太俗气了……</p><p>人为什么活着？<br>只能也只有唯一一个答案——好奇心，对尚未知世界的好奇心。<br>世界上唯一不变的事情就是永远在变，是好奇心让你想知道世界下一秒会变成什么样子。<br>嗯，这是我上一秒钟的答案。<br>可是事情似乎已经超出了「好奇心」可以解释的范畴。<br>真的超出了吗？</p><p>云朵本来是没有形状的，有人赋予了它们形状。<br>流星本来是没有寓意的，有人相信它们有寓意。<br>世界依然是概率的。<br>今晚的月色是美的。</p><p>我，好像是你的。</p>]]></content>
    
    <summary type="html">
    
      &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=5099468&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;p&gt;这个世界上最复杂、最难以捉摸的事情是什么？&lt;/p&gt;&lt;p&gt;有人说，永远不要在晚上做任何一个决定，因为那是人一天中最不理性的时候。&lt;br&gt;我并不赞同。&lt;br&gt;如果所有的事情都由理性思维来主导，那这个世界上不会有音乐和诗歌，&lt;a href=&quot;https://www.youtube.com/watch?v=L9jiPQAuTBw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;约翰·列侬、爱因斯坦、乔布斯、黑泽明也不会被人们传颂和铭记&lt;/a&gt;。&lt;br&gt;夜深人静，是一个人能与自己对话的时候，也是最能看清自己心意的时候。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浮生散记" scheme="http://maples7.com/categories/%E6%B5%AE%E7%94%9F%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="感情" scheme="http://maples7.com/tags/%E6%84%9F%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>完全理解回调函数</title>
    <link href="http://maples7.com/2017/10/17/understand-callback/"/>
    <id>http://maples7.com/2017/10/17/understand-callback/</id>
    <published>2017-10-17T04:43:49.000Z</published>
    <updated>2021-11-13T04:56:40.083Z</updated>
    
    <content type="html"><![CDATA[<p>什么是回调函数？</p><p>在任何一个函数是「一等公民」的编程语言里，这都不会成为一个问题。简单说，回调函数就是传递给其他代码的函数实体或引用，但其内涵远没有这么简单。</p><p>回调函数本质上提供了一种与常规的上层调用下层代码相反的模式，使得底层代码也有机会反调高层的代码，这大大提升了代码的能力，也同时给工程化项目带来了新的问题和挑战。</p><p>回调函数也是事件驱动式编程的基础，使得程序不必像传统的流程驱动式编程那样亦步亦趋的向下进行，而是可以被动性的由外来事件来触发进行，这几乎是所有图形化编程最基础和标准的实现方式。</p><a id="more"></a><p>一个典型的回调函数的例子就是在各个语言中都很常见的排序接口（比如 C++ STL 中 sort 函数），它们几乎都允许用户自己提供一个定制化的「比较函数」，这个比较函数就是典型的回调函数，它将会在排序接口的内部被执行。正是由于这样的回调函数的存在，使得排序接口不再仅仅局限于自然排序，大大提高了代码和接口的重用性。</p><p>回调函数分为两种，一种是同步回调函数，另一种是异步回调函数。上述排序接口的回调函数就是同步回调函数，而在 Node.js 中常见的回调函数是异步回调函数。同步回调和异步回调都可以使得调用者（caller）不再简单依赖于被调用者（callee），使得二者在代码空间分布上解耦，而异步回调函数更是在运行时从时间上将二者解耦。</p><p>回调函数背后其实隐藏着「控制反转（IoC，Inversion of Control ）」的编程哲学，或者说回调函数是实现 IoC 的最常见的手段。IoC 的核心思想是 “Don’t call me, I’ll call you”，也被叫作「好莱坞原则」，据说是好莱坞经纪人的口头禅。控制反转其实也很常见，一般的库（library）中有回调函数的地方就有控制反转，这种控制反转可能还是局部的，而 Web 开发中几乎肯定会用的框架（framework）则是把控制反转作用到了全局，它使得基于上的更高层开发者不用像命题作文一样从零开始创作，而是把它变成了一道填空题，你只需要在约定好的地方按照具体的业务需求填入相应的内容即可，整个程序的运转流程被牢牢地把控在框架手中。</p><p>这样的框架重用度非常高，经过不断地迭代，越通用的东西会越来越沉淀到底层，服务于更广泛的上层代码，而多亏了回调函数的存在，使得上层开发者也能将自己独特的业务需求植入其中。</p><p>从事件驱动式编程的角度来说，回调函数也是实现 OCP（Open Close Principle，开闭原则）的手段之一。「开闭」指的是「对扩展开放，对修改封闭」，它要求代码在尽量少修改的情况下还有足够好的扩展性。举例来说，如果需要实现一个通用的消息消费者，如何做到在添加新的消息类型时却不必修改主函数呢？答案可以是让每种消息类型传递自己特有的回调函数，消费者的主体不变，在合适的地方调用随同消息一起传递过来的回调函数即可。</p><p>回调函数也不是全然没有问题。</p><p>Node.js 天然的异步特性设计使得大多数接口都是异步的，自然也充满了各种各样的异步回调函数。在 Node.js 里，回调函数最大的问题不仅仅是代码书写上产生了 callback hell，更本质的问题是回调函数的调用得不到有效的控制。因为外部异步接口不都像框架一样是基本可信任的，所以你并不能保证别人会如何对待你传入的回调函数。有趣的是，异步流程控制协议 Promise 再一次利用控制反转解决了回调函数调用的「信任」问题。Promise 把本来由异步接口控制的回调函数调用权收归自己所有，所有的异步调用都是通过 Promise 这个「中介」来完成，而回调函数的管理和调用也由 Promise 来一手掌握。</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://book.douban.com/subject/4031906/" target="_blank" rel="noopener">《冒号课堂》</a></li></ul><h4 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h4><ul><li><a href="http://maples7.com/2016/08/24/understand-sync-async-and-blocking-non-blocking/">完全理解同步/异步与阻塞/非阻塞</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是回调函数？&lt;/p&gt;&lt;p&gt;在任何一个函数是「一等公民」的编程语言里，这都不会成为一个问题。简单说，回调函数就是传递给其他代码的函数实体或引用，但其内涵远没有这么简单。&lt;/p&gt;&lt;p&gt;回调函数本质上提供了一种与常规的上层调用下层代码相反的模式，使得底层代码也有机会反调高层的代码，这大大提升了代码的能力，也同时给工程化项目带来了新的问题和挑战。&lt;/p&gt;&lt;p&gt;回调函数也是事件驱动式编程的基础，使得程序不必像传统的流程驱动式编程那样亦步亦趋的向下进行，而是可以被动性的由外来事件来触发进行，这几乎是所有图形化编程最基础和标准的实现方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="一只代码狗的自我修养" scheme="http://maples7.com/categories/%E4%B8%80%E5%8F%AA%E4%BB%A3%E7%A0%81%E7%8B%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="「完全理解」系列" scheme="http://maples7.com/tags/%E3%80%8C%E5%AE%8C%E5%85%A8%E7%90%86%E8%A7%A3%E3%80%8D%E7%B3%BB%E5%88%97/"/>
    
      <category term="回调函数" scheme="http://maples7.com/tags/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    
      <category term="控制反转" scheme="http://maples7.com/tags/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>独立书店的生存困境</title>
    <link href="http://maples7.com/2017/08/23/arduous-independent-bookstores/"/>
    <id>http://maples7.com/2017/08/23/arduous-independent-bookstores/</id>
    <published>2017-08-22T17:14:07.000Z</published>
    <updated>2021-11-13T04:56:40.083Z</updated>
    
    <content type="html"><![CDATA[<p>独立书店，<a href="https://www.wikipedia.org/" target="_blank" rel="noopener">维基百科</a>给的描述是<a href="https://zh.wikipedia.org/wiki/独立书店" target="_blank" rel="noopener">「主要以当地人拥有、经营的书店」、「可以是连锁书店的相反词」</a>，这个描述多半还给「独立书店」这个词涂抹上了一点纸质书年代的理想主义色彩。在电商平台、互联网经济大行其道的今天，甭说是「当地人经营」的书店了，即便是那些可以给不同地域的人留下共同回忆、实力还算雄厚的半独立半连锁书店，其生存状态同样不容乐观。又或者说，作为一家「书」店，单看其书籍的销售量，基本已经可以用「垂死挣扎」来形容了。本文就着眼于这些宽泛定义的独立书店的生存困境。当然，新华书店至少是不在这个讨论的范围之内了。</p><a id="more"></a><p>讲到中国内地的书店，目光自然首先要聚焦到文化中心——北京。</p><p>在被戏称为「宇宙中心」的海淀区五道口，高校环伺，不少别具一格的独立书店藏匿其中，这之中最有名的要数目前位于<a href="http://www.tsinghua.edu.cn/" target="_blank" rel="noopener">清华</a>南门附近的<a href="http://www.allsagesbooks.com/GUANYU/JIANJIE.HTM" target="_blank" rel="noopener">万圣书园</a>。如果你第一次来这个书店，很可能会感到失望——「名声在外的万圣书园原来就是这个破败的样子？」。这也侧面反映出了大环境下独立书店的生存不易。北京的房价自不必多说，更何况是在五道口，2012 年的搬迁直接就让万圣书园的面积缩水了 300 多平米。目前，万圣书园凭借着创办人<a href="https://zh.wikipedia.org/wiki/刘苏里" target="_blank" rel="noopener">刘苏里</a>在文化圈的影响力，依然吸引着众多爱书之人慕名前来，而且这里还时不时会举办一些新书发布会、读书会等活动，客流量还算可观，依傍其旁的醒客咖啡也势必把客单价提高了不少。万圣书园最大的优势就在于其书籍收录之广泛全面，这从店面内直接码放到天花板的书架就可以看出。如果你想找别的书店找不到的书，如果你想找某个品类下一系列相关的书，<del>如果你还想逗一逗书店里的万圣猫，</del>来万圣书园看看吧。</p><p>与万圣书园隔街相望的是<a href="https://baike.baidu.com/item/豆瓣书店" target="_blank" rel="noopener">豆瓣书店</a>。这个书店的店面就更小了，总共也就约五十平米。它最大的特色就是专营旧书，这也可能是它至今还能在著名的万圣书园对面存活下来的原因。旧书并不是指二手书，而是指那些出版年代久远，可能即将被出版社销毁的库存书。但可别因为这样就小看了这些书的质量，能进入豆瓣书店的书都是店长去北京的各大出版社收罗的。因此，你总是能在豆瓣书店找到很多奇特又便宜的旧书，它们可能出版了 5-20 年甚至更长的时间，但你还是很有可能在它们中发现你感兴趣的东西。豆瓣书店每个月还会设计不一样的书签放在门口，供顾客随意取用收藏。值得一提的是，豆瓣书店跟<a href="https://www.douban.com/" target="_blank" rel="noopener">豆瓣网</a>没有任何关系，纯粹只是起名的巧合而已<del>，不然店面就不会这么小了（甚至有热心的豆瓣网友呼吁豆瓣网收购豆瓣书店）</del>。</p><p>另一个在<a href="http://www.pku.edu.cn/" target="_blank" rel="noopener">北大</a>师生心中拥有崇高地位的书店是<a href="http://www.jiemian.com/article/1426822.html" target="_blank" rel="noopener">野草书店</a>。本来它已经在北大校园内呆了 14 年了，但因为今年初夏的店面招标失败，被迫搬离了北大，来到了万圣书园附近的一个地下超市的旁边。野草书店可能是这三个书店里网络营销做得最好的。书店经理赵亮用几个手机几个微信号在网上维护着一两万个野草书店的忠实客户，微博上也会时常更新最新到货的新书（可网购邮寄），再配合令人难以想象的折扣力度，野草书店在线上线下应该都还经营得不错。听北大的朋友说，他们以前经常拿着老师开的书单来野草书店购书。</p><p>位于成府路上的这三个独立书店可以说是北京众多独立书店的代表，它们各有各的特色，能够在艰难环境中存活下来的原因更是各不相同。</p><p>跳出北京，南方的一些半独立书店就和北京这几个书店的经营策略不完全相同<del>，至少它们的店面都有着现代化的精致装修和室内设计</del>。</p><p>拿 2015 年年底在苏州开业的<a href="https://www.esliteliving.com/store/store.aspx?a=CN&l=gb&storeno=201511180004" target="_blank" rel="noopener">诚品书店</a>来说，它已经被打造成集潮流生活、风格美学、创意设计于一体，照顾现代人品质生活方方面面的一个联合体。这里不仅仅做到了藏书丰富（尤其是一些外文书和台版书），是爱书之人的首选，同时也吸引了一群对生活品质有要求的人。和诚品有着类似经营策略的还有<a href="https://zh.wikipedia.org/wiki/方所" target="_blank" rel="noopener">方所</a>，目前总共只有四家，分别位于广州、成都、重庆和青岛。方所甚至比诚品有着更高的「艺术」和「审美」追求，基本都开在奢侈品林立的中心商务区。</p><p>另外一些规模相对小一些的半独立书店，像<a href="https://zh.wikipedia.org/wiki/西西弗书店" target="_blank" rel="noopener">西西弗书店</a>、广州北京路上的<a href="https://baike.baidu.com/item/联合书店" target="_blank" rel="noopener">联合书店</a>，虽然还没有达到像苏州诚品这样多位一体的状态，但靠着经常举办的特色活动，也吸引着一批对特定领域感兴趣的人群的光顾，再加上店内的饮品店和一些其他的配套服务，应该也都还有尚可观的经营状态。</p><p>综合来看，虽然本文所列出的书店有的似乎还活得不错，但整个实体书店行业一定是一年不如一年了。高昂的地价成本，加上纸质书相对于电子书的固有成本，以及电商时代人们购书习惯的逐渐变化，使得这些书店不得不树立自己的特色、塑造自己别具一格的品牌形象，来吸引那些有特定需求的人群。好在，这个时间节点上，有不少人还是偏爱纸质书阅读的。</p><p>很多爱书之人都有这样的一个梦想，那就是退休之后开一家有个性的书店。随着时间的推移和时代的发展，这个梦想可能会变得越来越遥不可及。对于现有的这些独立书店来说，如果不迅速找准自己的特色和定位，扬长补短，那它们的命运都值得让人担忧。</p><p>或许，在独立书店这个领域，光有一点点理想主义情怀，还远远不够。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;独立书店，&lt;a href=&quot;https://www.wikipedia.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt;给的描述是&lt;a href=&quot;https://zh.wikipedia.org/wiki/独立书店&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;「主要以当地人拥有、经营的书店」、「可以是连锁书店的相反词」&lt;/a&gt;，这个描述多半还给「独立书店」这个词涂抹上了一点纸质书年代的理想主义色彩。在电商平台、互联网经济大行其道的今天，甭说是「当地人经营」的书店了，即便是那些可以给不同地域的人留下共同回忆、实力还算雄厚的半独立半连锁书店，其生存状态同样不容乐观。又或者说，作为一家「书」店，单看其书籍的销售量，基本已经可以用「垂死挣扎」来形容了。本文就着眼于这些宽泛定义的独立书店的生存困境。当然，新华书店至少是不在这个讨论的范围之内了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浮生散记" scheme="http://maples7.com/categories/%E6%B5%AE%E7%94%9F%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="独立书店" scheme="http://maples7.com/tags/%E7%8B%AC%E7%AB%8B%E4%B9%A6%E5%BA%97/"/>
    
  </entry>
  
  <entry>
    <title>被分化的树叶</title>
    <link href="http://maples7.com/2017/07/15/diversified-leaves/"/>
    <id>http://maples7.com/2017/07/15/diversified-leaves/</id>
    <published>2017-07-14T20:12:22.000Z</published>
    <updated>2021-11-13T04:56:40.083Z</updated>
    
    <content type="html"><![CDATA[<p>窗外是早晨浓重的雾。那的确只是雾，而不是在这座城市常见的霾。</p><p>窗子属于道路边一幢十多层高的居民楼，楼的西边儿有一棵不知名的树。树长得很高，树顶已经没过了两旁的建筑。虽然高，但看起来并不显得十分茂盛。树枝均匀的分布在树干上，让树整体上显得很有层次，像二十多岁少女的身姿。</p><p>透过洒落在晨雾里的朦朦胧胧的阳光，还是可以勉强从树下看到树上叶子的形状。椭圆形的树叶，面积并不大，长度只及人类中指的二分之一左右。叶片边缘有细小的锯齿，但在这么大的雾里肯定是分辨不出的了。或许是因为阳光的缘故，树南侧的叶子明显比北侧要茂密一些。</p><a id="more"></a><p>树叶们早已经被分化了。</p><p>那是很多年以前，这棵树还只是南方某森林里不知名的小树苗，树叶也不多，但它们在各个方向的长势却基本一致。然而，从它被种到这座北方城市的这一隅开始，树叶们的分化就命中注定般的开始了。自然环境基本决定了每一片叶子未来的大小和形状，无一幸免，无一例外。</p><p>太阳越升越高，雾也开始渐渐散去。</p><p>树的正西侧中上部位有一片很普通的叶子，大小在这棵树的所有树叶中居中，可是身材已经完全走了样。尽管它很努力的想要保持自己沿中茎两侧的部分对称且均匀，甚至曾经不惜费尽心思借住风的力量让自己的右半边多接触些阳光，然而还是可以明显看出它的左半边比右半边要大一些，而且中茎也已经被左边压弯了，呈现出指向北边的弧度。这片叶子很不喜欢自己失衡的身材，它觉得很失落，也很苦恼。</p><p>从树所在的地方再往西边走十几米，是一个十字路口。这个路口是这座城市繁华的缩影，每天从这经过的人和车成千上万，附近的地铁站里也无时无刻不挤满了人。那片身材走样了的叶子每天除了绞尽脑汁的想着如何让自己的右半边的大小能追上自己的左半边之外，就是从这些在它跟前经过的形形色色的人身上找些乐子了。它认为其他树叶肯定也跟它一样，只是都不好意思说。</p><p>这么多年过去了，叶子早已经阅人无数了。它看过各种不同年纪的人、各种不同长相的人、各种不同打扮的人、各种不同身材的人、各种不同职业的人、各种不同心情的人、使用各种不同交通工具的人，甚至是在各种不同天气下的各种各样的人。叶子觉得自己已经不能更了解人类了。</p><p>然而在这个平凡的大雾的早晨，叶子感觉自己还是在人类身上发掘出了不一样的东西。</p><p>以往的叶子总是把它有限的注意力都放在经过它前面的它感兴趣的某一个人类个体上。虽然它的注意力很有限，但它总是能把个体观察得格外细致。经过它长年累月不断打磨的关于人类的经验，它现在已经能从一个人经过它跟前的短短几秒到十几秒钟内，判断出这个人的职业和大致的社会地位。这种判断几乎是瞬间做出的，叶子知道它现在都已经不必经过叶脑思考了。</p><p>这个关于人类的新发现正是发生在叶子一如既往百无聊赖地观察人类的时候。这片因身材而犹豫的叶子大概是心情过于郁闷，想找点事情转移一下自己关于自身身材的注意力，于是尝试着强迫自己重新带上自己的脑子去观察人类，很快，它产生了新的思考。</p><p>今天的叶子萌芽出了一种更宏观的思维，它开始思考它所观察到的人类样本总体，于是它很顺理成章地就发现了人类个体之间巨大的差异性。它以前只是能把某个人类个体的特征描述完整，从而形成对这个个体的画像，但今天经过它自己的思考，它发现原来人与人之间是那么的不同，这种差异之巨大应该是它们树叶所完全不能理解也无法想象的。</p><p>它当然知道树叶们都已经是各不相同的了，即便它和它的兄弟姐妹们都生长在同一颗树上，也已经产生了很大的不同，而且他还知道世界上还有其他树的存在（这是它对侧的兄弟告诉它的，那个兄弟说它对面就有另外一棵树，树上也长满了叶子）。有的叶子色泽光鲜、叶片饱满、茎脉挺拔，有的则显得相对孱弱，甚至还有的叶片都已经有部分残缺了。但从人类之间的差异性上看，它突然觉得它们树叶之间的差异根本算不上什么，因为树叶之间的差异再怎么大也不至于连一丁点儿相似的地方也找不出吧，然而从人类身上它却可以轻松地从记忆中找到两个没有半点特征一样的人。</p><p>这样想着，它觉得它自己左半边和右半边之间的差异好像也不那么可恨了。它不知道这是不是它为了自我合理化所找的借口。</p><p>太阳好像已经快到树的正上方了，大雾也基本已经散去。</p><p>突然，一阵儿微风吹过，这片爱思考的叶子条件反射般地借着风的力量努力扭转着自己的身姿，想尽量让自己相对瘦小的右半边能多接触到一些正午的阳光。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;窗外是早晨浓重的雾。那的确只是雾，而不是在这座城市常见的霾。&lt;/p&gt;&lt;p&gt;窗子属于道路边一幢十多层高的居民楼，楼的西边儿有一棵不知名的树。树长得很高，树顶已经没过了两旁的建筑。虽然高，但看起来并不显得十分茂盛。树枝均匀的分布在树干上，让树整体上显得很有层次，像二十多岁少女的身姿。&lt;/p&gt;&lt;p&gt;透过洒落在晨雾里的朦朦胧胧的阳光，还是可以勉强从树下看到树上叶子的形状。椭圆形的树叶，面积并不大，长度只及人类中指的二分之一左右。叶片边缘有细小的锯齿，但在这么大的雾里肯定是分辨不出的了。或许是因为阳光的缘故，树南侧的叶子明显比北侧要茂密一些。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浮生散记" scheme="http://maples7.com/categories/%E6%B5%AE%E7%94%9F%E6%95%A3%E8%AE%B0/"/>
    
    
      <category term="意识流" scheme="http://maples7.com/tags/%E6%84%8F%E8%AF%86%E6%B5%81/"/>
    
      <category term="散文" scheme="http://maples7.com/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>如何系统地学习一门编程语言？</title>
    <link href="http://maples7.com/2017/07/13/comprehensively-learn-a-new-programming-lauguage/"/>
    <id>http://maples7.com/2017/07/13/comprehensively-learn-a-new-programming-lauguage/</id>
    <published>2017-07-12T18:05:48.000Z</published>
    <updated>2021-11-13T04:56:40.082Z</updated>
    
    <content type="html"><![CDATA[<p>「学习一门新的编程语言」是每个程序员都必然会面对的一个课题（注：本文特指工程实践中常用的高级编程语言）。自从高一开始编程到现在，我也接触了不少的编程语言，有的语言已经能在工作中得心应手的使用；有的语言用的不多，但大概了解其设计，也能在官方文档的帮助下简单使用；还有的则之前很了解，但很长时间没有使用过了。</p><p>换一份新的工作是最有机会让程序员接触到新的东西的，最近我就应工作需求开始接触一门新的编程语言，学习过程中难免会和已经熟悉的编程语言进行对比，然后发现其实编程语言的学习完全是有「套路」可循的，这篇博客试图总结一下这种「套路」。</p><a id="more"></a><p>总的来说，编程语言各种各样的特性共同决定了这门语言，这样的特性可能大到并发模型的设计，小到某个具体的语法特性。学习一门编程语言的过程就是不断了解这些语言特性并进行实践应用以及工程化使用的过程。系统性地把语言的主要特性明确清楚，可以快速地建立对一门语言的基本认识，并能做到胸有成竹地深入和细化。</p><p>下面就一一说明学习一门新的编程语言至少需要明确的语言特性有哪些，供参考。</p><h3 id="编译型-or-解释型"><a href="#编译型-or-解释型" class="headerlink" title="编译型 or 解释型"></a>编译型 or 解释型</h3><p>如今一门语言是编译型语言还是解释型语言似乎对工程开发的影响越来越小（而且大有相互靠拢之势，界限也变得越来越不清晰），这或多或少得益于各种编辑器和 IDE 对于中间过程的自动化处理。不过，明确一门编程语言是编译型还是解释型依然是基础且非常有必要的，这对于理解一些程序的深层行为逻辑会很有帮助。</p><p>其实对于语言设计者来说，编译型和解释型从根本上是语言开发自由度和性能优化能力之间的博弈。</p><h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>基本地，需要了解该语言都原生支持哪些数据类型，而其中哪些是简单／基础类型，哪些又是复杂／复合类型，各个类型之间又有哪些区别等等。</p><p>更抽象来看，类型系统又可以从两个维度来定义：</p><ul><li>强类型 or 弱类型：核心的区别在于语言<strong>是否偏向于容忍隐式的类型转换</strong>。一个常见的错误理解是「C/C++ 是强类型语言」，实际上，在 C/C++ 中隐式类型转换很常见，它们是弱类型语言。与之相对的，Python 则是强类型语言。</li><li>动态类型 or 静态类型：核心区别在于<strong>是否在编译时就能明确每一个变量的类型</strong>。对于静态类型来说，如果编译时存在类型错误，是无法编译通过的，而对于动态类型来说，由于程序运行时才能明确类型，所以类型错误通常不会导致编译出错（错误会在运行时暴露出来）。Python 就是动态类型，而 C/C++ 则是静态类型。</li></ul><h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><p>如今的高级语言基本都会有成熟的模块系统，好的模块系统对于构建大型工程项目来说必不可少，它可以大大提高程序的可复用能力和模块化能力。</p><p>了解一门编程语言的模块系统大概至少需要了解这些细节：</p><ul><li>依赖的路径是如何解析的？</li><li>如何引用自定义模块（文件）？</li><li>如何引用第三方的模块或包？</li></ul><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>与模块系统相关的一个很影响实际开发的问题是「变量的作用域（scope）是怎样的」。常见的可以自己问的问题是：</p><ul><li>什么情况下是全局作用域？</li><li>什么时候又会是函数作用域？</li><li>块作用域又是怎样的？</li></ul><p>不过，不同的语言对于作用域的定义和分类可能不同，需要具体情况具体了解。</p><p>另外，明确语言是「动态作用域」还是「静态（词法）作用域」也非常重要：与动态类型和静态类型的区别类似，静态作用域是在<strong>书写代码</strong>或者说定义时确定的，而动态作用域是在<strong>运行时</strong>确定的。静态作用域关注函数在<strong>何处声明</strong>，而动态作用域关注函数从<strong>何处调用</strong>，其作用域链是基于运行时的调用栈的。可以看看<a href="https://www.zhihu.com/question/20032419/answer/112564460" target="_blank" rel="noopener">这个例子</a>做进一步的区分。</p><h3 id="支持的编程范式与特色"><a href="#支持的编程范式与特色" class="headerlink" title="支持的编程范式与特色"></a>支持的编程范式与特色</h3><p>编程语言支持哪样的编程范式对于工程项目也非常重要，这也基本和语言设计上的一些别具一格不那么常见的特色相关。比如函数式编程中的「函数是一等公民」、面向对象中的「封装、继承和多态」对应到编程语言上应该如何具体实现、面向并行的语言又是如何实现并发的等等。</p><p>了解了这些特色你才能更清楚这门语言在工程中更擅长做哪样的事情，更适合哪些项目。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>基础的你需要了解基本的语法规则和特性，比如分支、循环、函数等等。更深入一些的时候则可以了解一下语言的架构设计、那些语言特性为什么会这样设计以及它们都是如何被实现的。了解实现不一定非得去看源码，搞清楚语言大体上的实现过程还是比较简单的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，把前文的部分<a href="https://www.processon.com/chart_image/595f2e79e4b0a77c5aeb50d7.png" target="_blank" rel="noopener">总结成一张思维导图</a>，希望能够让开始学习新编程语言的过程更清晰快速。</p><img src="https://i.loli.net/2018/08/06/5b6731fe12be8.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「学习一门新的编程语言」是每个程序员都必然会面对的一个课题（注：本文特指工程实践中常用的高级编程语言）。自从高一开始编程到现在，我也接触了不少的编程语言，有的语言已经能在工作中得心应手的使用；有的语言用的不多，但大概了解其设计，也能在官方文档的帮助下简单使用；还有的则之前很了解，但很长时间没有使用过了。&lt;/p&gt;&lt;p&gt;换一份新的工作是最有机会让程序员接触到新的东西的，最近我就应工作需求开始接触一门新的编程语言，学习过程中难免会和已经熟悉的编程语言进行对比，然后发现其实编程语言的学习完全是有「套路」可循的，这篇博客试图总结一下这种「套路」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="一只代码狗的自我修养" scheme="http://maples7.com/categories/%E4%B8%80%E5%8F%AA%E4%BB%A3%E7%A0%81%E7%8B%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="编程" scheme="http://maples7.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="程序员" scheme="http://maples7.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="编程语言" scheme="http://maples7.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>了不起的 Erlang</title>
    <link href="http://maples7.com/2017/06/10/awesome-erlang/"/>
    <id>http://maples7.com/2017/06/10/awesome-erlang/</id>
    <published>2017-06-10T15:45:44.000Z</published>
    <updated>2021-11-13T04:56:40.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p><em>Shared mutable state is the root of all evil</em><br><em>共享的可变状态是万恶之源</em></p><p><strong>Pete Hunt</strong></p></blockquote><p>大概是从去年年底开始，我开始断断续续地了解 Erlang 这门语言。之所以会想要去学习它，是因为它跟我已经比较熟悉的任何一门语言都有着截然不同的设计理念，而且我了解得越深，就越为其设计思想所折服。</p><p>虽然这门语言的年纪早已不算年轻，而且似乎从未「大众流行」过，但在如今 CPU 多核化和云计算的时代背景下，Erlang 却焕发出了不一样的生机。</p><a id="more"></a><p>Erlang 在构建高可用服务上有其独特的优势，这与 Web 服务的要求不谋而合，其设计理念值得每一名 Web 后端开发工程师去了解。</p><p>在介绍 Erlang 的几个核心概念之前，需要先说明的是，本文所指的 Erlang 不仅仅指这门语言本身，而是指整个构建于 Erlang 虚拟机之上的技术体系，这就至少包括了 Erlang 语言、Elixir 语言及围绕它们所展开的技术模型的设计。</p><p>语言并不那么重要，重要的是蕴含在语言之中的设计理念和设计思想。</p><h2 id="不可变状态"><a href="#不可变状态" class="headerlink" title="不可变状态"></a>不可变状态</h2><p>Erlang 是一种一次性赋值（single-assignment variable）的动态类型函数式编程语言。单次赋值意味着每个变量只能被赋值一次，如果试图在变量被赋值后改变它的值，程序会出错。</p><p>如果你初次接触单次赋值这个概念，可能会感到很难理解，但这并不是 Erlang 的原创。函数式编程的重要特点之一就是「不可变状态」（immutable state），Erlang 正符合这个特点。</p><p>实际上，在 Erlang 里，变量获得值是一次成功模式匹配操作的结果。如果你有着 C-like 编程语言的背景，你一定知道 <code>=</code> 表示的是一个赋值语句，而且大有各种入门书籍告诉你务必要与数学中的 <code>=</code> 符号区分开来，并很可能会举出 <code>i = i + 1</code> 这样在 C-like 语言中很常见，但在数学中明显不存在的式子（除非是在反证法中）。而在 Erlang 里，<code>=</code> 是一次模式匹配操作，<code>Lhs = Rhs</code> 的真正意思是：计算右侧（Rhs）的值，然后将结果与左侧（Lhs）的模式相匹配。这更多的像是<strong>回归了数学中 <code>=</code> 符号的本意</strong>。实际上，这也并不奇怪，函数式编程这种编程范型就是为了将电脑运算视为数学上的函数计算，同时还要避免使用程序本身的状态和易变的对象。</p><p>那为什么「不可变状态」会让编程变得更美好呢？</p><p>一个表面上明显的好处是让调试程序变得更简单。引起程序出错的常见原因就是变量得到了意料之外的值，为了防止意料之外的状态进入内部，我们可能不得不在 API 入口处进行参数校验，这意味着我们不得不写出大块的「防御式编程」的代码（这与后文要讲到的 “Let it crash” 特性一脉相承）。在 C-like 的语言里，变量可以被多次修改，因此每一个修改了变量值的地方都有可能是错误产生的地方，而在 Erlang 里，检查这样的错误只需要 check 一处即可。</p><p>另一个更深层次的好处是，「不可变状态」是使得程序运行不会产生副作用的保证之一，而<strong>没有副作用意味着可以让程序并行</strong>，这与后文的 Actor 并发模型又是一脉相承的。</p><h2 id="Actor-并发模型"><a href="#Actor-并发模型" class="headerlink" title="Actor 并发模型"></a>Actor 并发模型</h2><p>并发模型有很多种，大多数人最熟悉的还是 Java 所采用的基于锁和线程的并发模型，但也有其他的如 Golang 采用的 CSP 模型和 Erlang 的 Actor 模型，如果你对并发模型感兴趣，可以参阅<a href="https://book.douban.com/subject/26337939/" target="_blank" rel="noopener">《七周七并发模型》</a>这本书。</p><p>如果是传统编程语言来为多核 CPU 编程，就不可避免的需要程序员去对付共享内存的问题。进而为了不破坏共享内存，自然而然地又产生了「锁」的概念，即在必要的时候给这些内存加锁来解决共享内存的问题，而且访问这些共享内存的程序在操作共享内存时还万万不能崩溃，否则很可能产生难以追踪且无法预料的错误（可以与后文的 “Let it crash” 特性对比）。这就跟《人类简史》中所说的「农业社会是人类构建错误社会形态的开始」的概念类似，我们很可能从一开始就构建了不正确的模型，从而只能滚雪球式的将错就错、一错到底。而在 Erlang 里，没有可变状态，没有共享内存，也没有锁，这使得要让程序并行变得很简单。</p><p>Erlang 的基本并发单元是进程（Process），它们是一些独立的小型虚拟机。但这与操作系统的进程并不相同，Erlang 的进程是是隶属于编程语言而不是操作系统的。一方面，这意味着 Erlang 是跨平台的，而且它在任何操作系统上都会具有相同的逻辑行为，使得编写可移植的代码完全不是问题；另一方面，这些进程是 Erlang 虚拟机自身实现的，所以它们非常的轻量，创建和销毁都十分快速，占用的资源也非常小，这意味着大量的进程可以并存。</p><p>当然，Erlang 的进程是不共享任何内存的，它们相互之间完全独立，而唯一的交互方式是消息（CSP 模型也是如此）。</p><p>到此为止，我想题记中的那句「共享的可变状态是万恶之源」就不难理解了。</p><h2 id="Let-it-crash"><a href="#Let-it-crash" class="headerlink" title="Let it crash"></a>Let it crash</h2><p>在一般的传统语言里，我们总是被教导着要写「防御性代码」。那可能意味你代码中任何层次抽象出的每一个接口都应当检查传入的参数、可能意味着代码中需要大量的与业务逻辑交织在一起的错误检查代码。这是可以理解的，因为在基于锁和线程的并发模型中，编写多进程代码极其困难，多数程序都只有一个进程，所以如果这个进程随随便便就会崩溃，用专业的话说那就是程序的「鲁棒性」太差了。</p><p>而在 Erlang 里对于错误的处理方式与在传统顺序编程的处理方式完全不同。</p><p>在 Erlang 里，由于我们有大量的轻量级进程可供支配，所以任何的单进程的故障都不会那么重要。一般情况下，在 Erlang 里我们只需要编写极少量的防御性代码（注意，这里有个过犹不及的误解，在编程时我们不能把 <em>Let it crash</em> 当成一个可以被滥用的特性，也就是不要明知道某个地方可能 crash 却不予理睬），而可以把重点放在纠正性代码上。</p><p>在 Erlang 里，系统中的 Process 会划分为两个角色：一部分负责解决业务问题，另一部分则负责在错误发生时纠正错误。负责解决业务问题的部分会尽可能少的使用防御性代码，同时也会假设传入函数的所有参数都是正确的。而纠正错误的部分不会与解决业务的部分耦合在一起，所以这也意味着它们在大部分情况下是<strong>可以被复用</strong>的。</p><p>抽象来说，传统的错误处理方式与 Erlang 的错误处理理念实际上是对于问题发生时解决问题的两种不同思路。传统的方式强调尽可能的避免错误发生的可能，但有过编程经验的人基本都知道，要想避免所有错误发生的可能，这是不可能的。而 Erlang 处理错误的角度则不同，它是在错误已经发生后，不管这个错误是怎样的产生的（当然事后还是要具体分析原因的），或者是什么类型的错误，我们都把 A 进程发生的错误交由与之相关的 B 进程来处理，来试图纠正这个错误，使得整个系统恢复到一个我们已知的可控的状态。同时 A 进程直接 crash 掉就好。Erlang 把错误处理的注意力放在的错误发生后的清理工作上。这一点，其实与 Node.js 集群部署时的理念有类似之处，进程分为主进程和工作进程，但 Erlang 在这一点上做得更为彻底，而且在语言层面上就是这样设计的。</p><p><em>Let it crash</em> 所带来的好处其实有很多，除了前面已经说到的不用写大量与业务代码交织在一起的防御性代码和在错误发生时可以不管原因统一处理之外，他还能使得发生的错误不至于被恶化造成不可控的更严重的后果，因为发生错误的 Process 已经被 crash 了。它也使得错误能够立即被上述的 B 进程处理，而且错误不会继续运行导致调试也变得困难。更深入地，它还使得我们在设计系统时可以有意识地把业务部分和错误恢复部分当成两个独立的问题来思考，这一点是非常符合 <a href="https://zh.wikipedia.org/wiki/关注点分离" target="_blank" rel="noopener">SoC（Separation of Concerns）</a> 的要求的（我在上一篇博文<a href="http://maples7.com/2017/05/24/programming-and-life/#分工明确，关注点分离">《程序与人生》</a>中也有提到这一点），即特定问题由特定专业分工明确的不同代码来解决。</p><h2 id="GitHub-语言颜色"><a href="#GitHub-语言颜色" class="headerlink" title="GitHub 语言颜色"></a>GitHub 语言颜色</h2><p>最后，说一个 tricky 的理由，在 GitHub 上代表 Erlang 和 Elixir 的颜色是紫色（Elixir 的颜色更深一点），这个已经暗示了这门技术的尊贵之处了。</p><p>哈哈，开个玩笑。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>希望这篇文章能真正引发你对于 Erlang 这门设计优秀的语言的兴趣与关注，并同时推荐你看<a href="https://book.douban.com/subject/25892728/" target="_blank" rel="noopener">《Erlang程序设计（第2版）》</a> 这本书，它是由 Erlang 的设计和发明者、「Erlang 之父」Joe Armstrong 亲笔撰写的，所以在语言的诸多设计理念上都有非常清晰的讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;&lt;em&gt;Shared mutable state is the root of all evil&lt;/em&gt;&lt;br&gt;&lt;em&gt;共享的可变状态是万恶之源&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Pete Hunt&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;大概是从去年年底开始，我开始断断续续地了解 Erlang 这门语言。之所以会想要去学习它，是因为它跟我已经比较熟悉的任何一门语言都有着截然不同的设计理念，而且我了解得越深，就越为其设计思想所折服。&lt;/p&gt;&lt;p&gt;虽然这门语言的年纪早已不算年轻，而且似乎从未「大众流行」过，但在如今 CPU 多核化和云计算的时代背景下，Erlang 却焕发出了不一样的生机。&lt;/p&gt;
    
    </summary>
    
    
      <category term="一只代码狗的自我修养" scheme="http://maples7.com/categories/%E4%B8%80%E5%8F%AA%E4%BB%A3%E7%A0%81%E7%8B%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="Erlang" scheme="http://maples7.com/tags/Erlang/"/>
    
      <category term="函数式编程" scheme="http://maples7.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="并发" scheme="http://maples7.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>程序与人生</title>
    <link href="http://maples7.com/2017/05/24/programming-and-life/"/>
    <id>http://maples7.com/2017/05/24/programming-and-life/</id>
    <published>2017-05-23T18:31:47.000Z</published>
    <updated>2021-11-13T04:56:40.082Z</updated>
    
    <content type="html"><![CDATA[<p>最近趁着离职的一点空隙，稍微能有些时间和心情来思考一些更有深度和更长远的问题，这篇文章的内容算是我近期开的小小脑洞之一。</p><p>越来越发现，前人总结的一些众所周知并经过时间验证过的关于写代码的道理，只要我们换个角度来类比和思考，同样可以适用于我们人生历程的一些方面。这篇文章就是我想到的一些例子，小标题都是写代码时所谓的一些「金科玉律」，而我会试图通过这些相通的「规律」，衍生出个人对人生某个方面的思考，可能小到微不足道的个人习惯，大到能够决定人生方向的人生观。</p><a id="more"></a><h2 id="做好垃圾回收"><a href="#做好垃圾回收" class="headerlink" title="做好垃圾回收"></a>做好垃圾回收</h2><p>任何使用 C/C++ 写代码的程序员都会在编码时尤其注意一个问题，那就是及时进行垃圾回收。具体来说，由于 C/C++ 本身不具有自动垃圾回收的机制，所以但凡程序向操作系统「借用」了一块内存来存放新生成的对象，都必须在对应对象的生命期结束之后的某个时刻主动的进行内存释放，即手动进行垃圾回收。如果没有进行合适的垃圾回收，则系统会陷入了我们常说的「内存泄漏」的问题——由于无用的内存得不到及时的释放，导致程序占用的内存越来越多，最后导致内存不足而整个系统无法正常运行。</p><p>一个合格的 C/C++ 程序员会把主动进行垃圾回收的习惯带到生活中，小到随手关灯、随手关门、把用过的会议室恢复原样，中到把借来的东西物归原主，甚至大到整个人类对发展过程中对生态环境破坏的及时弥补，其内在其实都是自然的「垃圾回收」原则。</p><h2 id="永远不忘把错误默默吞掉"><a href="#永远不忘把错误默默吞掉" class="headerlink" title="永远不忘把错误默默吞掉"></a>永远不忘把错误默默吞掉</h2><p><em>“Errors should never pass silently”</em> 是<a href="https://en.wikipedia.org/wiki/Zen_of_Python" target="_blank" rel="noopener">《The Zen of Python》</a>中重要的一条，它告诉我们永远不要忽视代码中的「异常」（Exception）。无论你是像目前大多数语言或框架所设计的把「异常」向上「抛」到一个足够高的层次然后统一记录日志并做处理然后程序继续运行，还是像 Erlang 那样崇尚 <em>let it crash</em> 的思想把所有被「异常」所「感染」到的轻量级 Process 全部挂掉，其相同的基点都是不能把异常默默的忽视掉。</p><p>其内在的逻辑在于，我们绝不能忽视系统中的任何一个错误，把问题暴露出来总是比隐藏问题要更好。任何一个不加处理和纠正的错误，对于有状态的系统而言，可能导致系统处于一个完全失常的状态，其行为得不到有效的控制；对于无状态的系统而言，则可能使得任何触发了这个错误的用户请求都产生错误的结果和返回，即便不直接把 Process 挂掉，也至少把错误捕捉到且记录日志并视问题严重程度适当进行告警，否则问题将永远得不到解决。</p><p>生活中其实也是如此。当我们遇到问题时，人的本能反应都是逃避的，但逃避永远解决不了我们遇到的问题。选择直面问题和困难是强者和自信者的逻辑和选择，人生也只有在不断的打怪升级中进阶成为更好的自己。具体来说，学习时遇到难点要想办法去弄懂原理，人际交往中遇到误会要及时沟通，工作时遇到阻碍要直面解决等等。</p><h2 id="分工明确，关注点分离"><a href="#分工明确，关注点分离" class="headerlink" title="分工明确，关注点分离"></a>分工明确，关注点分离</h2><p><a href="https://zh.wikipedia.org/wiki/关注点分离" target="_blank" rel="noopener">SoC（Separation of Concerns）</a>是面向对象程序设计的核心概念之一，它强调把业务逻辑的代码与解决特定领域问题的代码分离，这样才能使得代码具有「高内聚，低耦合，分层明确」的特点，也就是使得日后由于需求变动带来的维护修改能够以尽可能小的影响面来进行。其实 Erlang 的 actor 并发模型设计对此也有所体现，整个系统任务被拆分成一个个不同的小任务，被大量的轻量级 Work Process 来执行，而 Process 之间唯一的交互方式是通过 messages（这就是好比各个子系统通过 API 来进行黑盒交互），这样的并发模型就完全避免了传统的共享内存式并发的 data race、死锁等固有问题。</p><p>人类社会整个就是一个分工明确的动态系统，不同人一定会有不同的专长和兴趣，在走向社会之后也一定会或主动或被动的走到合适自己的岗位上去。而整个人类社会系统是不断动态发展的，正是由于明确的分工机制，客观世界的某个具体的变化不必需要人类全体都进行调整来适应，这样人类社会总体上才得以能够勉力跟上客观世界变化的速度。其实道理很简单，就拿最近影响面极广的 WannaCry 勒索病毒事件来说，即便微软早在两三月前就已经推送了补丁修复漏洞，但由于需要调整的用户数量太大（即便假设所有用户对系统更新都持开放态度），所以肯定还是会有大量来不及进行调整的用户中招。更明确的说，个体数量越多，则所有个体都从当前状态调整到另一个确定状态所遇到的阻力就越大。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实如果有心，还可以发现很多沉淀下来的技术「准则」都可以有更哲学更生活化的解读和理解，也欢迎留言提供你的「新发现」。</p><p>程序与人生，不仅仅是写程序的人生，更是透着程序思想哲思的人生。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近趁着离职的一点空隙，稍微能有些时间和心情来思考一些更有深度和更长远的问题，这篇文章的内容算是我近期开的小小脑洞之一。&lt;/p&gt;&lt;p&gt;越来越发现，前人总结的一些众所周知并经过时间验证过的关于写代码的道理，只要我们换个角度来类比和思考，同样可以适用于我们人生历程的一些方面。这篇文章就是我想到的一些例子，小标题都是写代码时所谓的一些「金科玉律」，而我会试图通过这些相通的「规律」，衍生出个人对人生某个方面的思考，可能小到微不足道的个人习惯，大到能够决定人生方向的人生观。&lt;/p&gt;
    
    </summary>
    
    
      <category term="一只代码狗的自我修养" scheme="http://maples7.com/categories/%E4%B8%80%E5%8F%AA%E4%BB%A3%E7%A0%81%E7%8B%97%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="程序员" scheme="http://maples7.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="人生" scheme="http://maples7.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
</feed>
