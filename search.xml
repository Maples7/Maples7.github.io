<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>大理：一场风花雪月的事</title>
    <url>/2014/09/21/dali-things-about-wind-flowers-snow-and-moon/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=29777634&auto=0&height=66"></iframe>
很多人知道大理这个地方，大概都与金庸的小说《天龙八部》有关。未到大理，这座想象中的古城或多或少会让人有关于生死大义、爱恨情仇的武侠幻想。这种感觉仿佛像是将要误入边陲一隅的桃花源，少了现代生活的喧嚣与紧张，剩下的只有这座与世隔绝的古城的林林总总。

<p>从丽江到大理，已是凌晨，火车站都显得有些僻静。偶有一两个旅店拉客的老板。经历过丽江和香格里拉不大愉快的消费经历，必定是对这些「上门推销」的人存在戒心的。但最后还是无奈于「夜已深、天微凉」，也就上了辆「贼车」了。</p>
<span id="more"></span>

<p>从大理火车站到大理古城，车程也要几十分钟。夜色中的大理，只有「静」可以来形容，这种静，简直是静到人的灵魂深处。没有流光溢彩的街灯，没有灯火通明的夜市，有的，只有那一轮朦胧的月。再放眼远处，只有连绵不绝的高山，在月色下影影绰绰地把整个大理城围着。而山脚下不大的大理古城，夜色里只剩一抹温柔。</p>
<p>如果你想让自己的大理之行与众不同，深夜的大理古城是一定要逛的。我们住的客栈在古城西边。从西城门对面的小巷一路向城走，那种感觉，简直是回到了只存在于记忆中的童年。月色皎洁，映照着石板路，没有路灯。幽深的古巷里除了你一个人也没有，偶有狗吠，却也慢悠悠融合在这夜色里。有个有意思的说法是，大理的狗是不咬人的，也不知是真是假。进入古城，想找个夜宵摊竟也是一件颇为难的事情。这里完全没有我们所想象的热门旅游景点的样子，有的完完全全就是小镇的生活气息，日出而作，日落而息。深入古城很远，也不见一家亮着灯的夜宵摊。偶有开着小门的小店铺，昏黄的光从屋内流泻出来洒在石板路上，彷佛你自己又置身于记忆深处的童年。久不遇夜宵摊，只得在小店铺买了点零食，遂折返。</p>
<p>沈从文曾写过一篇名为《云南看云》的散文，看云来云南，是的确不假的。大理的云尤其有其独特之处。早晨，透过客栈的落地窗，一睁眼，映入眼帘的便是天空大片大片的云。单说云，其实还不够准确，应该是在湛蓝湛蓝的天空背景下的云。因为即便是这样的云，放到北京，我相信也是「无福消受」的了。</p>
<p>来大理这种地方，如果你不想毁了自己这趟旅行，是万万报不得团的。无论何种形式的团，最好都避而远之。自己去当地的青年旅馆租一辆自行车，便可以开始自己一天的旅行了。</p>
<p>白天的大理古城终于有了一个旅游景点该有的景象，但即便是游客如云的地方，也绝对少不了当地人的身影。他们似乎早已对这些外来人习以为常，只是经历着自己的生活，经营着自己的日常，浓郁的生活气息让人感到分外温暖。在古城吃过当地的特色早餐，便开始逛古城了。古城城墙很厚，城墙上竟可以看到民宅，可谓奇特。古城的街道与丽江古城让人找不到北的弯弯曲曲的小巷不同，都是笔直的，从北门直通南门，从东门直通西门。方方正正，直来直往，似乎也是这里的特色。站在高高的城门上，或俯瞰古城，或眺望远处的苍山洱海，都是甚为壮观的。这不禁让人想象历史当中的大理古城，是多么气派和繁华。同样，与丽江古城已经被外来人的商业化腐蚀得不成样子不同，大理古城还保留着自己的本色。最让我感到印象深刻的，还是古城当中的老电影博物馆。进入博物馆，彷佛就进入了一段历史。那古朴的氛围和细腻的情愫，从古老的只能在电影中看到的放映机、胶卷中缓缓散发出来，述说着这座城市昨日的故事。</p>
<p>每个旅游城市都会有一些不能不去的景点。来大理，苍山洱海是一定要去看的。说是去看，其实在大理古城城墙一角，便早已看到了。那远处山峰插入云端的群山，便是苍山；与苍山相对的湖泊，便是洱海。其实吧，在大理骑自行车赏景，倒不如步行来得痛快。因为实际情况基本上是，每骑了二十米左右，便忍不住要停下来，然后拿出相机，开始拍照。不知是不是有季节和天气的原因，我们见到的苍山，美得简直让人醉了。而这美，还是因为云。这云与普通的天空飘的大坨大坨的云还不同，她彷佛是盖在苍山上的一床棉被，或者说更像是山那边有海水漫过来激起的白色的浪花，整个把山的上部完完全全的盖住了。而且过一段时间你再去看，云确实还慢慢地在往山脚下移动。到傍晚时分，简直已经盖住苍山的一半多了。苍山脚下，还有一个十分著名的景点——大理三塔。在《天龙八部》的经典电视剧版本中，就有这三塔的场景。</p>
<p>大理地处西南边陲，自古以来就有「妙香佛国」之称，这点从三塔建筑以及三塔到沧海的这条路的布局和建设就可以看出，此中玄妙，定是不少。从苍山到洱海，就体现了租来的自行车的价值了。我们特意选取了一条田野间的小路，找准洱海的方向，便出发了。路途依然是停的时候居多。从各种不同的角度回头看苍山，看大理古城，都有一番不同的感觉。</p>
<p>由于走了一条乡间石子小路，不久我们就迷失在小路尽头的建筑群中。大理当地主要的少数民族是白族，建筑也具有白族独特的风格。在询问过一个白族小孩儿过后，我们终于走出了建筑群，来到了公路上。这时候已经是下午三四点钟了，来到公路上我们才发现，像我们这样骑车来个环洱海游的还有不少。再骑了一会儿，终于来到了洱海边的环湖公路。夏季的洱海，是平静的。湖中央游荡着一两条小船，船夫撑着杆子戴着斗笠。湖边在风景好的地方，建有花园式的茶吧和旅馆，有秋千，有落地窗，甚至还有供游客租用的房车。但其实这样的商业设施还并不多，整体上还是一副田园自然做派。这时，看看洱海，再回过头看看被「云被」盖着的苍山，你会产生一种一辈子就留在这里的想法。</p>
<p>从洱海回到客栈，天已经黑了。虽然十分不舍，但计划好的晚上的火车就要离开这座古城了。收拾好了行李之后我便去了白天租自行车的青年旅馆还车。当时他们还在旅馆的庭院里摆着桌子吃饭，院子里停着各式各样的自行车和一辆卡丁车，显示出了这里年轻活泼的气息。待我从里屋里办完手续出来，一回头，我再一次被惊艳到。由于青旅对面就是民居的侧墙（白族建筑的墙面都是白色粉刷的，只在墙面边缘做少量装饰纹），青旅的年轻老板便将电视信号投影到了整面墙上，大家一起坐在庭院，磕着瓜子看着电视，似乎这已经是生活再平常不过的事情了。看着这一幕，我硬生生地站定愣住了。感慨着这天然幕布真好的同时，两行热泪差点没掉出来。这样很多人围在庭院里乘着凉休息聊天的场景，大概也只存在记忆深处中的童年了吧。</p>
<p>大理是适合情侣一起去的地方。你可曾想象和自己喜欢的人躺在城墙上，只是看着天上的蓝天白云；骑着双人自行车来洱海边看日落；登上苍山一起抚摸那一床「云被」；凌晨时分逛着古城一起找寻那昏黄的街灯……</p>
<p>如此种种，便已是人生难得的幸福。</p>
<p>在大理，观苍山，品洱海，我又开始期待着，那一场风花雪月的事儿。</p>
]]></content>
      <categories>
        <category>在路上</category>
      </categories>
      <tags>
        <tag>大理</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>没有微信的 24 小时里</title>
    <url>/2014/09/25/24h-without-wechat/</url>
    <content><![CDATA[<p>也是前不久在《简书周刊》上看到一篇文章，作者讲述自己在删除了所有手机上的社交 App 后的种种感受。或许我们都早已承认社交网络已经深刻的影响着我们的日常生活，但在看到那篇文章之前，我还真没有意识到离开以微信为首的社交 Apps 之后会是一番怎样真切的感受。</p>
<p>当时钟快要滑向凌晨的时候，脑袋一热，于朋友圈(juàn)留下一条「绝笔状态」，便删除了手机和 iPad 上的冠以「社交」两字的文件夹。自我感觉良好。对于我这样的重度社交 App 依赖患者，这也是一件颇值得考究的行为。大概这就是极端下的自我厌恶吧。</p>
<span id="more"></span>

<p>在多看怒刷完两百页电子书，很理智的抑制住自己想要分享到朋友圈(juàn)的习惯性冲动，美美地进入了梦乡。</p>
<p>生活是平凡的，也是不凡的。我们以天、以周、以月、以年为周期重复着我们的生活，却总可以在这样的重复中感知点点滴滴的变化，并始终保持着对未知的下一秒的期待。或许你早已经熟悉，讲台上老师混杂着方言与普通话的语调，却总可以在桌洞里冒出来的小纸条上发现惊喜。这些惊喜都促使你产生了对朋友圈(juàn)的冲动。朋友圈(juàn)成了我们每天精彩生活的缩影。一条段子，一张自拍，一个玩笑，甚至是一句抱怨，寄托着我们的情感，都流淌到了朋友圈(juàn)里。更让人着迷的是，那些远在天边的、近在你旁边的、几乎不联系的、天天联系的、熟悉的陌生的、认识的不认识的，都可以在你的状态下轻轻地点上一个赞，或者感触相似者还会稍加评论一番，似乎是对自己发布的这条状态的奖励。久而久之，潜意识开始依赖这种奖励式的互动方式。</p>
<p>朋友圈(juàn)，圈养着我们的朋友们。</p>
<p>于是，上课、开会无聊时，会刷一刷朋友圈(juàn)；食堂排队等饭时，会刷一刷朋友圈(juàn)；自习看不下书时，会刷一刷朋友圈(juàn)。甚至，重度患者如我，解锁开屏幕的同时，手指也就不自觉的落在了「社交」为名的文件夹上，忘了最初为什么要拿出手机了。</p>
<p>所以，没有微信的这 24 小时里，我的感受是复杂的。</p>
<p>这是一个从平静变得焦虑的过程。刚开始，会有那么一丝丝的成就感：看，没有刷微信我多看了多少页书，多做了多少道题，多背了几个单词。内心是多么的安宁和满足。再然后，开始抱怨和不满。之前任何刷微信、刷人人、刷微博、刷知乎的个人「基本需求」都可以简单快捷的通过 Apps 得以满足，现在，这长期培养出来的个人需求被硬生生地截断了。我开始更多的依赖浏览器，用浏览器刷知乎，刷微博，然后对网页版渣成翔的用户体验充满怨念。紧接着，我开始有些许期待朋友圈(juàn)的朋友们又给我评论些什么，又产生了哪些新鲜事，我又错过了哪些让我开怀大笑的段子。我也才意识到，社交网络，尤其是微博和各种微信公共账号，已经成了我每天浏览新闻、了解这个世界的主要途径。</p>
<p>又一次快要凌晨的时候，我已经难以说服自己承受这种刻意压制自己需求带来的些许焦虑感。但是，我昨天才在朋友圈(juàn)发的「告别状态」啊……在反复纠结当中，我最终还是选择了顺遂自己的心意。我还真怕这激烈的克制对心理造成不良的影响。看着朋友圈(juàn)上的红色标记，在点开的一瞬间，我似乎感到了一种解脱和释然。</p>
<p>毫无疑问，互联网让我们的生活质量有了质的飞跃。同时我们也越来越依赖于互联网带给我们的更开放、联系更紧密的社交生活。但是，这种看似频繁的社交联系真的带来了真实感情上的亲近吗？</p>
<p>可笑的是，就在我正在码字之时，我也边回复着微信、QQ 好友发来的各种消息，并且我还很可能会把这些文字分享到我将持续刷下去的朋友圈(juàn)里。</p>
<p>不过，值得一提的是，经过这 24 小时的实验，我想我会更加注意适度的去控制打开这些社交 Apps 的频率，我将更能深刻体会社交网络给自己的日常生活带来的真切的影响，我将开始有意重新培养自己长篇阅读以及长时间专注的能力。更依赖社交网络的同时，也会更加珍惜和谨慎的去把握好那个「度」了。</p>
<p>下次再刷屏的时候，不妨想想，是你在刷屏，还是屏在刷你？</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>社交网络</tag>
      </tags>
  </entry>
  <entry>
    <title>无复屠苏梦，挑灯夜未央</title>
    <url>/2016/02/24/no-childhood-dream-night-does-not-fall/</url>
    <content><![CDATA[<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b672af6aaec0.gif" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b672af6894bf.gif" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b672af6a19b2.gif" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b672af6baeb1.gif" /></div></div></div>

<span id="more"></span>

<br />

<p>图片已经过裁剪与压缩，原图在这里：<a href="https://maples7.tuchong.com/12896822/">https://maples7.tuchong.com/12896822/</a></p>
]]></content>
      <categories>
        <category>视觉动物</category>
      </categories>
      <tags>
        <tag>黑白</tag>
        <tag>Sony DSC-RX100</tag>
      </tags>
  </entry>
  <entry>
    <title>巴山蜀水毓灵秀</title>
    <url>/2016/06/10/mountains-in-chongqin-and-water-in-chengdu/</url>
    <content><![CDATA[<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b672af6a96f4.gif" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b672af68b036.gif" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b672af6a29bb.gif" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b672af6a482e.gif" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b672af6a5fdb.gif" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b672af6b7aa7.gif" /></div></div></div>

<span id="more"></span>

<br />

<p>图片已经过裁剪与压缩，原图在这里：<a href="https://maples7.tuchong.com/13205116/">https://maples7.tuchong.com/13205116/</a></p>
]]></content>
      <categories>
        <category>视觉动物</category>
      </categories>
      <tags>
        <tag>Sony DSC-RX100</tag>
        <tag>城市</tag>
        <tag>光影</tag>
      </tags>
  </entry>
  <entry>
    <title>我的密码管理策略</title>
    <url>/2016/04/06/my-strategy-about-passwords-management/</url>
    <content><![CDATA[<p>[ 本文来自于<a href="https://www.zhihu.com/question/19695004/answer/93985563">我的知乎回答</a>，现整理修改后记于博客。]</p>
<p>随着互联网时代的发展，世界上的每个个体与互联网的关系也变得愈发紧密，而移动互联网更是极大的促进了这种趋势——一部手机，世界就在你手中。</p>
<p>伴随着这种趋势而来的，是个人对于互联网应用的依赖激增，每个人每天几乎同时使用着几十款互联网应用，如何管理这些互联网应用的个人密码并保证足够的安全性变得重要起来。</p>
<p>本文介绍一下我的密码管理策略。</p>
<span id="more"></span>

<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>有人可能会直接推荐使用一些密码管理工具（比如 1Password、LastPass 等）来管理自己的密码，但我不打算采用。任何工具在将来都存在不可靠的可能，但自己的大脑却是值得信赖的。</p>
<p>如果用做一款互联网产品的思维来思考，首先这套策略应该是对用户友好的（人脑可兼容的），但同时又必需在日益复杂的互联网环境中具有足够的强度。</p>
<p>列出的需求如下：</p>
<ul>
<li>强度足够；</li>
<li>易于记忆、输入方便；</li>
<li>方便生成与定期更换；</li>
<li>不借助密码管理工具，任何工具都不一定可靠；</li>
<li>不同应用的密码应该不一样，不把鸡蛋放一个篮子里；</li>
<li>加入随机因子（或伪随机因子）；</li>
<li>密码中无个人永久信息；</li>
</ul>
<p>其实这就是如何在方便和复杂这种天然的矛盾中找出人脑可记忆的那个平衡点。</p>
<h3 id="策略细节"><a href="#策略细节" class="headerlink" title="策略细节"></a>策略细节</h3><p>依据这样的需求，我构思了这样一种方案：</p>
<h4 id="构造基础字串：应用特征信息-私钥"><a href="#构造基础字串：应用特征信息-私钥" class="headerlink" title="构造基础字串：应用特征信息 + 私钥"></a>构造基础字串：应用特征信息 + 私钥</h4><ol>
<li><p>应用特征信息：</p>
<p> 由于需要每个应用密码都不同，而且自己又要记得住（或者可根据一定规则推算出来），所以基础字串中一定要有应用的特征信息，可以是 URL 的某一部分、应用名，甚至是页面源代码的倒数第五个非 html 元素等等。</p>
<p> 总之这个信息应该至少具备两个特点：基本不会变化 + 规则固定（最好是一眼就可以看出来的，取决于自己决定的规则）。</p>
</li>
<li><p>私钥（或者说 salt）:</p>
<p> 我决定用一段时间内自己特别关注的某个点来定义私钥，由于这个信息可能是自己在这一段时间内特别关注的，所以一般也不会忘记。</p>
<p> 这个的灵感来源于这个答案：<a href="https://www.zhihu.com/question/24306804/answer/29038524">用什么方式记密码最好？ - 匿名用户的回答</a>。你也可以根据这个答案的内容来确定自己某一段时间内的私钥。</p>
<p> 注意：由于私钥过一段时间更换一次，所以密码随着私钥更新也要更新（稍后会讲维护方法），这相当于添加的一些与应用无关的随机因素，而别人一般也不可能猜到。</p>
</li>
</ol>
<p>基础字串由应用特征信息和私钥组合而成，至于组合规则你可以简单拼接，或是更复杂的交叉拼接都可。不过这里还是建议简单点设计，便于记住。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>在基础字串的基础上，根据一些替换、交换次序等特有规则进行编码，灵感来源于 <a href="https://www.zhihu.com/people/e5fb0aab23f1ebca897594c74d178c79">@吴涛</a> 的这个回答：<a href="https://www.zhihu.com/question/19695004/answer/12976049">如何管理好自己的密码？ - 吴涛的回答</a>。这样的规则也不宜过多，总之以自己能方便记住和输入为原则。</p>
<p>一旦你的规则确定下来，这样就生成了你的某一个应用的唯一密码。</p>
<h3 id="具体实践"><a href="#具体实践" class="headerlink" title="具体实践"></a>具体实践</h3><p>对于具体实践，我还设计了这样的维护方案：</p>
<h4 id="根据规则写成脚本"><a href="#根据规则写成脚本" class="headerlink" title="根据规则写成脚本"></a>根据规则写成脚本</h4><p>如果会编程可以把以上自己确定下来的规则写成脚本，方便自己在电脑上使用时不用多想一键生成密码（注意脚本中是不记录你提取出的应用特征信息和私钥的，所以即便脚本不小心被别人拿走也不知道你构建基础字串的方法）。</p>
<p>但是，写脚本并不是为了让你总是依赖它来生成你的密码进行登录，<u><strong>你应该总是能够在短时间内根据自己设定的规则在脑中生成密码</strong></u>。</p>
<p>脚本存在的最大的意义在于：注册时尽量使用脚本生成的密码，避免你自己确定的密码生成规则存在歧义的情况下导致以后的自己会生成不一样的密码而无法登录，因为代码是不存在二义性的（无随机语句类似的情况时），这可以为以后确定密码提供一个依据。</p>
<p>所以如果你不会脚本也没有关系，只要你保证自己设定的规则没有歧义就可以了。</p>
<h4 id="维护一个有两个列表的文本文件"><a href="#维护一个有两个列表的文本文件" class="headerlink" title="维护一个有两个列表的文本文件"></a>维护一个有两个列表的文本文件</h4><ul>
<li><p>列表一是你或常用或重要的应用列表，如果是网站就记录网址，如果是应用就记录名字等等。</p>
<p>在这个列表中的所有应用，都是你的核心应用，并且网站开发者具有一定的技术实力，至少它的密码加密方式一定不是很随意可破解的。</p>
<p>对于这些应用，私钥绝对要使用你的最新私钥。注意这个私钥不要记录下来，而应该是你在这段时间内一定不会忘记的某些信息，这样即便这个文本被泄露别人还是不知道你的最新的私钥（以及密码生成规则）。</p>
<p>这个列表也可帮助你在更新私钥之后有次序的依次更新这个列表中应用的密码。</p>
</li>
<li><p>列表二是一些不重要或技术水平存疑的网站，比如学校网站、政府网站等等，这样的网站或应用不仅需要记录它的 URL 或者名字，还应该记录一个注册时采用的私钥。也就是说，这些应用的私钥不是最新的，而且密码也一般是永远不会改变的。</p>
<p>这样做的原因在于，如果这些技术水平存疑或者故意使坏的网站对于你的密码没有加密或加密可轻易破解，这样在类似于拖库之后你的私钥和密码生成规则很可能都会被猜到，如此便极有可能影响到那些对你而言重要的网站或应用，那样你就不得不更换算法了。所以这里采用过时的私钥，相当于加筑一道防火墙。</p>
<p>（如果这里觉得麻烦，也可以简单的对这些不重要的网站采用同一个密码。<u>不过最好还是按上述做法。</u>）</p>
</li>
</ul>
<p>即便这个文本文件泄漏，别人也不会知道你的密码生成规则、基础字串的构建方法和最新的私钥。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，总结一下，你需要做的：</p>
<ol>
<li><p>记住：密码生成规则（使用几遍就可记住）+ 最新的私钥；</p>
</li>
<li><p>把脚本和本地的文本文件做好备份，可以备份到多个硬盘、U盘或者你绝对信得过的云盘。</p>
<p>不过即便你的这俩文件都丢失了，你依然可以凭最新的私钥生成密码，所以那些重要的应用依然不受影响。并且你可以在浏览器中对这些网站添加书签并云备份，所以你的重要列表也不会丢，但可能不重要列表中那些年代久远的密码就找不回了。不过既然不重要，那又能怎样呢？</p>
</li>
</ol>
<p>目前这套方案我已经稳定使用了很久了，有人可能觉得规则过于复杂难以记住，实际上我在规则确定的第二天就能稳定快速的对任一款应用生成自己的密码。而且你使用的次数越多，记忆会越来越深刻，也会越来越不容易出错，是个正反馈良性循环。</p>
<p>同时祝你使用愉快。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>密码管理</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>人类，请收起你们虚妄的自尊心</title>
    <url>/2016/03/18/humans-please-hold-your-humanity-back/</url>
    <content><![CDATA[<p>人类纪元，公元 2016 年 3 月中旬，一件令全世界瞩目的事件即将发生，世界围棋冠军李世乭九段与 Google DeepMind 团队研发的围棋人工智能程序 AlphaGo 之间的围棋五番棋大战即将展开，一时间「人机大战」、「人GO大战」等词充斥于各大社交网站和媒体。几天过后，最终以人机 1:4，AlphaGo 轻松打败李世乭九段而取胜。</p>
<p>有意思的是，赛前，新浪体育和新浪科技都对网友做过调查，在新浪体育的调查结果显示，认为李世乭将战胜 AlphaGo 的网友占 72.7%，而在新浪科技的调查结果中显示，认为李世乭将获胜的网友占 47.8%。</p>
<span id="more"></span>

<p>我无意于对比和分析同属于新浪两个频道的调查结果产生差异的原因，毕竟实际的目标用户就不同。不过这个数据从一个侧面说明，赛前普通大众中的更多人还是觉得机器在围棋上还是无法战胜人类的。这一点，从微信朋友圈赛前赛后所有有关这场比赛的文章标题，就可以明显看出语气上的落差。</p>
<blockquote>
<p>19年前，深蓝战胜卡斯帕罗夫的时候，中国人一片那种「计算机虽然已经很厉害了，但是那是因为西洋象棋本身不够高深，咱们中国发明的围棋博大精深、玄妙无比」之类的论调。当年我才 17 岁，也陶醉在中国文化博大精深这种民族自豪感的情绪里。今天我终于知道，这世界，终究是要向前走的。</p>
</blockquote>
<blockquote>
<p>—— 来自社交网络，出处未知</p>
</blockquote>
<p>诚然，强人工智能的时代可能还很遥远，但它总有一天将要到来。或许目前依然有不少人怀疑人类是否能突破强人工智能的技术难点。你我（可能）都不是研究人工智能的专家，无法从科学上给出一个或肯定或否定的回答。即便是专家，或许自己也难以给出一个肯定的答复。但从哲学的角度上说，人工智能对于人脑智能的模拟总有一天是可以无限趋近的。如果你承认人脑——作为自然界存在的事物之一——不可被研究，那就已经在无意中陷入不可知论的框架中去了。</p>
<p>从赛前的大众舆论可以看出，人类对于自己在这世界上独一无二的智能能力还是感觉十分良好的。而在第一局李世乭败给了 AlphaGo 之后，从第一时间少部分人在社交网络的言论可以看出，有些人似乎隐隐有一种被机器「羞辱」了的情绪在。知乎上开始出现这样的问题：「如何杀死一个人工智能？」。潜意识中，这些人已经把人类和人工智能对立了起来。</p>
<p>其实如果真要认真地试着来回答知乎上的这个问题，不先完整地定义人工智能这个问题根本无从开始。其中我看到最多的答案大概是「拔掉电源」，还获得了不少赞。试想如果真的是一个无论从外形还是综合能力都已经跟人类相似甚至超过了人类的强人工智能，欸，下半句都不必说了，你还记得<a href="https://movie.douban.com/subject/4160540/">《机械姬》（Ex Machina）</a>的结局吗？另外，谁又说过人工智能一定是具有具体形态的呢？</p>
<p>当然，创作毕竟是创作，如电影中这样的强人工智能能不能诞生还很难说。这并不是否定我前面所说的强人工智能「总有一天将要到来」，而是因为人类可能无法到达强人工智能诞生的那一天就可能因为其他更严峻的问题遭受到重大打击甚至灭绝，比如与外星文明的接触（引力波被发现了还记得吗？）。</p>
<blockquote>
<p>如果你不觉得老婆比自己聪明会让自己显得没有尊严，那么机器比自己聪明同样不应该让你觉得丢脸。</p>
</blockquote>
<blockquote>
<p>—— 字节社创始人，《IT公论》主播不鳥萬如一</p>
</blockquote>
<p>其实，人工智能的胜利正是显示了人类创造的强大能力，但同时也应该清楚，人工智能很可能是人类有史以来最值得争议的创造，甚至可能决定了人类的存亡。是不是队友，现在还很难说。</p>
<p>不管你现在承不承认，强人工智能总有一天将会到来，并且 Ta 们的能力总有一天会超过人类。所以，让我们收起那些无处作祟的虚妄的自尊心吧。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>AlphaGo</tag>
      </tags>
  </entry>
  <entry>
    <title>非关系型数据库中的「关系」实现</title>
    <url>/2016/04/06/how-to-implement-relationship-in-nosql/</url>
    <content><![CDATA[<p>这两三年来，伴随着大数据（Big Data）的空前火热，无论是在工程界还是科研界，非关系型数据库（NoSQL）都已经成为了一个热门话题。</p>
<p>相比于传统的关系型数据库，非关系型数据库天生从理念上就给数据存储提供了一种新的思路。而在实际应用中，它往往更轻巧灵活、扩展性高，并且更能胜任高性能、大数据量的场景。</p>
<p>值得一提的是，NoSQL并不是 “No SQL” 的意思，而是 “Not Only SQL” 的简写。</p>
<span id="more"></span>

<p>尽管非关系型数据库没有关系型数据库中很多预定义的死板模式的限制，但自然数据间总是充满联系的，所以在数据库中我们势必需要抽象出这种数据之间的联系。</p>
<p>本文就个人实践经验，总结一下 NoSQL 数据库中表现数据关系的常见办法，并且结合一个实践项目来举例说明（样例为 Node.js 项目，使用常用的文档型数据库 MongoDB（Mongoose 来操作）来举例）。</p>
<p>方法如下：</p>
<h3 id="1-嵌套"><a href="#1-嵌套" class="headerlink" title="1. 嵌套"></a>1. 嵌套</h3><p>得益于非关系型数据库的灵活数据类型，我们可以直接将 Schema A 中的某个属性设置为「数组」类型，用以存储所有与它有 1：N 关系的其他数据对象。</p>
<p>举例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> commentSchema = <span class="keyword">new</span> <span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">time</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Date</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">content</span>: <span class="title class_">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> messageSchema = <span class="keyword">new</span> <span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">content</span>: <span class="title class_">String</span>,</span><br><span class="line">  <span class="attr">time</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Date</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">comments</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: [commentSchema],</span><br><span class="line">    <span class="attr">default</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在上例中，一个 <code>message</code> 文档可能包含很多 <code>comment</code> 文档，所以在 <code>messageSchema</code> 的 <code>comments</code> 属性中用一个数组来存储某个 <code>message</code> 的所有 <code>comment</code>。</p>
<p>值得注意的是，这里 <code>commentSchema</code> 并不实际对应一个数据集合，它只用于在这里帮助定义 <code>messageSchema</code>。</p>
<p>相比于下面要讲到的引用的办法，这个方法适合于查询频繁（少了引用查询）、有强逻辑联系的 1：N 关系（即每次显示 A 文档都需要显示众多 B 文档）、且 B 文档改动较少（毕竟嵌套操作相对复杂一些）的场景。</p>
<p>这种方法也是 NoSQL 数据库相比于传统的关系型数据库的优势所在。</p>
<h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2. 引用"></a>2. 引用</h3><p>NoSQL 数据库中并不存在传统关系型数据中类似于 join 的方法，所以这使得我们的复杂查询可能会变得相对困难，好在很多封装好的数据库包提供了很多便利。</p>
<p>引用方法又可分为两种：</p>
<h4 id="Ⅰ-手动引用"><a href="#Ⅰ-手动引用" class="headerlink" title="Ⅰ. 手动引用"></a>Ⅰ. 手动引用</h4><p>手动引用很简单，就是在 Schema A 中定义一个 Schema B 中唯一（<code>unique</code>）的属性（一般为<code>_id</code>），每次当查询 A 后又需要查询 B 时，需要自己根据 A 中定义的 <code>_id</code> 值手动去查询 B 的完整数据。</p>
<p>方法简单，不再举例赘述。</p>
<p>不过，在实践中唯一值得注意的是：A 中定义的与 B 相关的属性应该不具备业务语义，且基本不会被改动，否则当你对 B 中的相应属性进行改动的时候，所有引用此 B 文档的 A 文档，都需要对定义的引用属性进行更新，这是绝对需要避免的！这也是为什么一般引用 <code>_id</code> 的原因（一般在生命期内都不会被业务需求改变）。</p>
<h4 id="Ⅱ-自动引用"><a href="#Ⅱ-自动引用" class="headerlink" title="Ⅱ. 自动引用"></a>Ⅱ. 自动引用</h4><p>自动引用是借助于类似关系型数据库中定义的 Reference key 或 Foreign key 进行预先的引用定义。在查询时，数据库可以根据事先定义的「引用键」进行解引用，找到引用到的另一个集合中的文档。</p>
<p>在有一些封装好的数据库操作包中，可以实现自动解引用的功能，即凡是检测到引用键就自动的去查询对应的文档进而解引用。不过即便不是自动解引用，手动解引用也会花费开销进行查询，这也是为什么使用引用查询次数会更多的原因。试想如果对于「嵌套」方法中的样例，每次都进行自动解引用，那么在嵌套方法中可能进行的 1 次查询，在这里可能就需要 N+1 次了（N 为 <code>message</code> 中 <code>comments</code> 数组的长度）。</p>
<p>样例如下：</p>
<p>在 user.js 中定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userSchema = <span class="keyword">new</span> <span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">unique</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">password</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">email</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">intro</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 msgboard.js 中定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> messageSchema = <span class="keyword">new</span> <span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">user_id</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: mongoose.<span class="property">Schema</span>.<span class="property">ObjectId</span>,</span><br><span class="line">    <span class="attr">ref</span>: <span class="string">&#x27;User&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">content</span>: <span class="title class_">String</span>,</span><br><span class="line">  <span class="attr">time</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Date</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里，我们在 <code>messageSchema</code> 中定义了一个引用键 <code>user_id</code> 引用到 <code>userSchema</code> 中 <code>_id</code> 字段。<br>注意：MongoDB 会自动为文档创建唯一的 <code>_id</code> 字段！</p>
<p>如此，便在 Schema 层次上定义好了引用。具体在查询时，我们可以根据具体使用的包的特性来决定如何进行解引用的操作。</p>
<p>在 Mongoose 里，可以使用 <code>populate</code> 方法。详细的使用方法可以参考 Mongoose API 文档，这里仅给出一个样例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Message</span>.<span class="title function_">find</span>(query)</span><br><span class="line">  .<span class="title function_">populate</span>(<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">  .<span class="title function_">skip</span>((page - <span class="number">1</span>) * <span class="variable constant_">NUM_EACH_PAGE</span>)</span><br><span class="line">  .<span class="title function_">limit</span>(<span class="variable constant_">NUM_EACH_PAGE</span>)</span><br><span class="line">.<span class="title function_">sort</span>(&#123;<span class="attr">time</span>: -<span class="number">1</span>&#125;).<span class="title function_">exec</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">messages</span>) &#123;</span><br><span class="line">    <span class="comment">// do something with messages</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(messages);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里用 Promise（异步流程控制方式的一种） 链式操作的方进行对 <code>messages</code> 进行查询，同时 <code>skip</code> 和 <code>limit</code> 用于翻页。</p>
<p>重点可关注 <code>populate</code> 方法，我们在这里获取了引用到的 <code>user</code> 文档 <code>name</code> 字段的值。</p>
<p>对于自动引用方式而言，由于在同等数据量的情况下查询次数一般要多，所以适用于查询不大频繁、具有相对更弱逻辑性的数据关系之间（不是 A 出现 B 一定需要出现的关系），而且用它既定义了数据之间的关系，也方便对数据进行各种 CURD 操作（没有嵌套或少嵌套了）。</p>
<p>注：本文在 NoSQL 数据库中使用关系型数据库中的「字段」的概念，实际是表示 NoSQL 数据库文档中的属性。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 中的模块循环依赖及其解决</title>
    <url>/2016/08/17/cyclic-dependencies-in-node-and-its-solution/</url>
    <content><![CDATA[<p>Node.js 开发一般不容易遇到真正的模块循环依赖的情况，可是当你的项目开始达到一定的复杂度之后，你很有可能在你的 Node.js 编码生涯中遇到几次。而且如果你之前没有关于这方面的意识，Debug 可能会花费不少的时间。</p>
<p>我在最近的项目中就遇到了这种情况，而且不能轻易通过项目架构的重构来解决。具体来说，A 文件中需要用 B 文件中某些函数，B 文件又需要用到 A 文件中的某些函数。</p>
<span id="more"></span>

<h3 id="定义问题"><a href="#定义问题" class="headerlink" title="定义问题"></a>定义问题</h3><p>实际上，Node.js 官网上就有<a href="https://nodejs.org/api/modules.html#modules_cycles">关于模块循环 <code>require()</code> 的说明</a>。</p>
<p>在官网给出的例子中，有 3 个模块：<code>main.js</code>、<code>a.js</code>、<code>b.js</code>。其中 <code>main.js</code> 有对 <code>a.js</code> 和 <code>b.js</code> 的引用，而 <code>a.js</code> 和 <code>b.js</code> 又是相互引用的关系（详细情况请参阅上段末的超链接）。</p>
<p>官网上点出了这种模块循环的情况，并且解释清楚了原因（但并没有给出具体可行的解决方案）：</p>
<blockquote>
<p>When <code>main.js</code> loads <code>a.js</code>, then <code>a.js</code> in turn loads <code>b.js</code>. At that point, <code>b.js</code> tries to load <code>a.js</code>. In order to prevent an infinite loop, an <strong>unfinished copy</strong> of the <code>a.js</code> exports object is returned to the <code>b.js</code> module. <code>b.js</code> then finishes loading, and its exports object is provided to the <code>a.js</code> module.</p>
</blockquote>
<p>简单说就是，为了防止模块载入的死循环，Node.js 在模块第一次载入后会把它的结果进行缓存，下一次再对它进行载入的时候会直接从缓存中取出结果。所以在这种循环依赖情形下，不会有死循环，但是却会因为缓存造成模块没有按照我们预想的那样被导出（export，详细的案例分析见下文）。</p>
<p>官网给出了三个模块还不是循环依赖最简单的情形。实际上，两个模块就可以很清楚的表达出这种情况。根据递归的思想，解决了最简单的情形，这一类任意大小规模的问题也就解决了一半（另一半还需要探明随着问题规模增长，问题的解将会如何变化）。</p>
<p>下面是一个两个模块循环依赖的问题最简情形：</p>
<p><code>A.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./B&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A: before logging b&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A: after logging b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">A</span>: <span class="string">&#x27;this is a Object&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>B.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./A&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B: before logging a&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B: after logging a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">B</span>: <span class="string">&#x27;this is b Object&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行 <code>A.js</code>，将会看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B: before logging a</span><br><span class="line">&#123;&#125;</span><br><span class="line">B: after logging a</span><br><span class="line">A: before logging b</span><br><span class="line">&#123; B: &#x27;this is b Object&#x27; &#125;</span><br><span class="line">A: after logging b</span><br></pre></td></tr></table></figure>

<p>JavaScript 作为一门解释型的语言，上面的打印输出清晰的展示出了程序运行的轨迹。在这个例子中，<code>A.js</code> 首先 <code>require</code> 了 <code>B.js</code>, 程序进入 <code>B.js</code>，在 <code>B.js</code> 中第一行又 <code>require</code> 了 <code>A.js</code>。</p>
<p>如前文所述，为了避免无限循环的模块依赖，在 Node.js 运行 <code>A.js</code> 之后，它就被缓存了，但需要注意的是，此时缓存的仅仅是一个未完工的 <code>A.js</code>（an <strong>unfinished copy</strong> of the <code>a.js</code>）。所以在 <code>B.js</code> <code>require</code> <code>A.js</code> 时，得到的仅仅是缓存中一个未完工的 <code>A.js</code>，具体来说，它并没有明确被导出的具体内容（<code>A.js</code> 尾端）。所以 <code>B.js</code> 中输出的 <code>a</code> 是一个空对象。</p>
<p>之后，<code>B.js</code> 顺利执行完，回到 <code>A.js</code> 的 <code>require</code> 语句之后，继续执行完成。</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>想要解决这个问题有一个很简明的方法，那就是在循环依赖的每个模块中先导出自身，然后再导入其他模块（对于本文的举例来说，实际只需改动 <code>A.js</code> 就可以达到效果）。</p>
<p>话不多说，放码过来：</p>
<p><code>A.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">A</span>: <span class="string">&#x27;this is a Object&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./B&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A: before log b&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A: after log b&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>B.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">B</span>: <span class="string">&#x27;this is b Object&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./A&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B: before log a&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B: after log a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>此时，在 A 和 B 中，都在 <code>require</code> 之前就导出了自身需要导出的模块，此时输出则是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B: before log a</span><br><span class="line">&#123; A: &#x27;this is a Object&#x27; &#125;</span><br><span class="line">B: after log a</span><br><span class="line">A: before log b</span><br><span class="line">&#123; B: &#x27;this is b Object&#x27; &#125;</span><br><span class="line">A: after log b</span><br></pre></td></tr></table></figure>

<p>可以看到 B 中按我们的预期输出了 A 中导出的值。</p>
<p>这种解决办法可行的原因也很简单，还是因为 JavaScript 是一门解释型的语言，在 <code>require</code> 其他模块之前，已经把自身需要导出的部分都导出了，所以即便有模块载入缓存，也不影响最终结果按预期进行。</p>
<p>这种办法几乎没什么副作用，唯一稍令强迫症感到不快就是这种顺序与我们通常的书写顺序不符。一般我们都会先把 <code>require</code> 写在源文件开头，<code>exports</code> 放到后面的位置。唯一需要祈祷的是，之后接手项目的代码猴儿不会因为觉得这个顺序看着碍眼又把它改回去。鉴于此点，<u><strong>在导入导出语句上添加合理的解释性注释变得很重要</strong></u>。</p>
<h3 id="其他相关问题"><a href="#其他相关问题" class="headerlink" title="其他相关问题"></a>其他相关问题</h3><p>实际上，我还自己实验并查阅了一些资料来探索是否有其他的解决办法，但那些办法要么是适用于特定的情形和设计模式之下，要么就没有上述方法简洁，本文就不赘述了。如果有兴趣，可以参看本文末尾的 References 链接。如果你发现有更好的解决办法，欢迎在评论区留言。</p>
<p>要想彻底弄明白 Node.js 模块加载的相关问题，一定得去读读 Node.js 相关部分的源码。其次，推荐阅读<a href="https://book.douban.com/subject/25768396/">《深入浅出 Node.js》</a>第二章与<a href="http://www.ruanyifeng.com/blog/2015/05/require.html">阮一峰的这篇日志</a>。</p>
<p>有趣的是，ES6 特性中已经有了更优秀的 <code>import/export</code> 模块加载机制，就不会存在这样的问题（原因参考 References 第5条），然而 Node.js 还并不支持。Github 上有人提出过这个问题，Node.js 基金会成员 <a href="https://github.com/bnoordhuis">@bnoordhuis</a> 对此的回复是：</p>
<blockquote>
<p>In a nutshell, <code>require()</code> is not going anywhere - removing it would break too much for too little gain - but we’ll almost certainly end up supporting ES6 import&#x2F;export somehow, details TBD.</p>
<p>Support for ES6 modules first needs to land in V8.</p>
</blockquote>
<p>详细的讨论可以到<a href="https://github.com/nodejs/help/issues/53">这里</a>查看。</p>
<p>虽然因为 V8 的原因 Node.js 官方还不能支持 <code>import/export</code>，不过我们依然可以借助 Babel 来提前在 Node.js 使用这个特性，感兴趣的同学可以参考<a href="http://taobaofed.org/blog/2016/01/07/find-back-the-lost-es6-features-in-nodejs/">这里</a>。 </p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol>
<li><a href="https://nodejs.org/api/modules.html#modules_cycles">Modules | Node.js Documentation</a></li>
<li><a href="https://coderwall.com/p/myzvmg/circular-dependencies-in-node-js">Circular dependencies in node.js</a></li>
<li><a href="https://cnodejs.org/topic/4f16442ccae1f4aa27001045">node.js的循环依赖 - cnode</a></li>
<li><a href="https://segmentfault.com/a/1190000004151411">Node.js 中的循环依赖 - sf</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html">JavaScript 模块的循环加载 - 阮一峰</a></li>
<li><a href="https://github.com/Gaubee/blog/issues/65">nodejs中模块循环依赖的解决方案 #65</a></li>
</ol>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>循环依赖</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>完全理解同步/异步与阻塞/非阻塞</title>
    <url>/2016/08/24/understand-sync-async-and-blocking-non-blocking/</url>
    <content><![CDATA[<p>随便翻开一本 Node.js 入门书籍的绪论部分，一般都可以看到「异步」、「单线程」、「非阻塞」这样的字眼。因其采用异步非阻塞的模型而构建，Node.js 得以能充分利用 CPU 资源，具有极强的处理高并发请求的能力。</p>
<p>可是到底什么是同步和异步？什么是阻塞和非阻塞？同步就意味着阻塞吗？异步就一定是非阻塞吗？即便是业务经验十分丰富的 Node.js 程序员，都不一定对这些概念辨别得十分明晰。</p>
<p>本文力求以简明的语言来解释清楚这几个概念并加以区分，但不涉及到 Node.js 底层的具体实现。</p>
<span id="more"></span>

<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>从简单的开始，我们以经典的读取文件的模型举例。（对操作系统而言，所有的输入输出设备都被抽象成文件。）</p>
<p>在发起读取文件的请求时，应用层会调用系统内核的 I&#x2F;O 接口。</p>
<p>如果应用层调用的是阻塞型 I&#x2F;O，那么在调用之后，应用层即刻被挂起，一直出于等待数据返回的状态，直到系统内核从磁盘读取完数据并返回给应用层，应用层才用获得的数据进行接下来的其他操作。</p>
<p>如果应用层调用的是非阻塞 I&#x2F;O，那么调用后，系统内核会立即返回（虽然还没有文件内容的数据），应用层并不会被挂起，它可以做其他任意它想做的操作。（至于文件内容数据如何返回给应用层，这已经超出了阻塞和非阻塞的辨别范畴。）</p>
<p>这便是（脱离同步和异步来说之后）阻塞和非阻塞的区别。总结来说，是否是阻塞还是非阻塞，关注的是接口调用（发出请求）后等待数据返回时的状态。被挂起无法执行其他操作的则是阻塞型的，可以被立即「抽离」去完成其他「任务」的则是非阻塞型的。</p>
<p><img data-src="https://i.loli.net/2018/08/06/5b672dabdf36a.png" alt="阻塞和非阻塞调用模型"></p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>阻塞和非阻塞解决了应用层等待数据返回时的状态问题，那系统内核获取到的数据到底如何返回给应用层呢？这里不同类型的操作便体现的是同步和异步的区别。</p>
<p>对于同步型的调用，应用层需要自己去向系统内核问询，如果数据还未读取完毕，那此时读取文件的任务还未完成，应用层根据其阻塞和非阻塞的划分，或挂起或去做其他事情（所以同步和异步并不决定其等待数据返回时的状态）；如果数据已经读取完毕，那此时系统内核将数据返回给应用层，应用层即可以用取得的数据做其他相关的事情。</p>
<p>而对于异步型的调用，应用层无需主动向系统内核问询，在系统内核读取完文件数据之后，会主动通知应用层数据已经读取完毕，此时应用层即可以接收系统内核返回过来的数据，再做其他事情。</p>
<p>这便是（脱离阻塞和非阻塞来说之后）同步和异步的区别。也就是说，是否是同步还是异步，关注的是任务完成时消息通知的方式。由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。</p>
<p><img data-src="https://i.loli.net/2018/08/06/5b672dabecc59.png" alt="同步和异步调用模型"></p>
<h3 id="Node-js-的异步非阻塞模型"><a href="#Node-js-的异步非阻塞模型" class="headerlink" title="Node.js 的异步非阻塞模型"></a>Node.js 的异步非阻塞模型</h3><p>完整来说，一个最高效且理想的文件读取异步非阻塞模型应该是这样的：应用层发起调用后系统内核立即返回（还没有文件内容数据），应用层继续做其他无关的事情，在系统内核从磁盘读取完数据之后主动通知应用层任务已完成，应用层此时接收系统内核返回的数据，然后继续做其他相关或不相关的事情。</p>
<p>可以看到，在这个模型中，没有无谓的挂起、休眠与等待，也没有盲目无知的问询与检查，应用层做到不等候片刻的最大化利用自身的资源，系统内核也十分「善解人意」的在完成任务后主动通知应用层来接收任务成果。</p>
<p>Node.js 是不是就是这样实现的呢？是，也不是。</p>
<p>现实总是比理想骨感，系统内核并没有理想中那样「善解人意」。异步模型的内核调用在各个平台上实现不一，而且各有各的问题，所以实际上， Node.js 其实是借助多线程来模拟实现了上述理想的异步非阻塞模型。</p>
<p>有人可能有疑问，前面不是说 Node.js 是单线程的吗？</p>
<p>实际上单线程是对用户（使用 Node.js 进行上层开发的程序员，而不是开发 Node.js 的人员）而言的。Node.js 在底层对多个 I&#x2F;O 操作是借助多线程实现异步非阻塞的，具体来说，Node.js 总是存在一个主线程，用来管理调度 I&#x2F;O 线程并进行运算，而其他的线程都是 I&#x2F;O 线程。I&#x2F;O 线程在主线程的调度下与系统内核进行交互完成完成 I&#x2F;O 操作并把数据返回给主线程，而主线程对 I&#x2F;O 线程的调度就完全是上述异步非阻塞的（至于 I&#x2F;O 线程是异步还是同步、阻塞还是非阻塞，已经不重要了，因为它不影响主线程的效率，只要它能按时返回预期的数据就行）。我们平时所说的 Node.js 是单线程的，就是指 Node.js 的主线程。I&#x2F;O 线程完全是对用户屏蔽的，所以用户根本无需关心。</p>
<p>这也解释了为什么我们要避免书写计算密集型或者阻塞的代码，一旦主线程被阻塞，那整个应用就是真的都被阻塞了。</p>
<h3 id="场景举例与总结"><a href="#场景举例与总结" class="headerlink" title="场景举例与总结"></a>场景举例与总结</h3><p>最后，再来举一个我们日常的例子来加深对这几个概念的理解。</p>
<p>假设小明需要在网上下载一个软件：</p>
<ul>
<li>如果小明点击下载按钮之后，就一直干瞪着进度条不做其他任何事情直到软件下载完成，这是同步阻塞；</li>
<li>如果小明点击下载按钮之后，就一直干瞪着进度条不做其他任何事情直到软件下载完成，但是软件下载完成其实是会「叮」的一声通知的（但小明依然那样干等着），这是异步阻塞；（不常见）</li>
<li>如果小明点击下载按钮之后，就去做其他事情了，不过他总需要时不时瞄一眼屏幕看软件是不是下载完成了，这是同步非阻塞；</li>
<li>如果小明点击下载按钮之后，就去做其他事情了，软件下载完之后「叮」的一声通知小明，小明再回来继续处理下载完的软件，这是异步非阻塞。</li>
</ul>
<p>相信看完以上这个案例之后，这几个概念已经能够分辨得很清楚了。</p>
<p>总的来说，同步和异步关注的是<strong>任务完成消息通知的机制</strong>，而阻塞和非阻塞关注的是<strong>等待任务完成时请求者的状态</strong>。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol>
<li><a href="https://book.douban.com/subject/25768396/">《深入浅出 Node.js》</a>第三章；</li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTA1MDUyMA==&mid=2655435714&idx=2&sn=dd23e9d357c3adce3bc1b78956d10105&scene=1&srcid=0423LaJvwtyeAr3OMFwcJeAg#wechat_redirect">聊聊同步、异步、阻塞与非阻塞</a>；</li>
</ol>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>同步</tag>
        <tag>异步</tag>
        <tag>阻塞</tag>
        <tag>非阻塞</tag>
        <tag>「完全理解」系列</tag>
      </tags>
  </entry>
  <entry>
    <title>构建合格的 RESTful API Server</title>
    <url>/2016/09/05/build-qualified-restful-api-server/</url>
    <content><![CDATA[<p>这一篇我要把 References 写在前面：</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=401902529&idx=1&sn=575ae8fdf163afa30604d712a73079fd&scene=21#wechat_redirect">再谈 API 的撰写 - 总览</a>；</li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=401924543&idx=1&sn=97de2e09c9fddfd905992c19aedb6182&scene=1&srcid=0427sAmgXKhksqURPXRj2cxv#wechat_redirect">再谈 API 的撰写 - 架构</a>；</li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=402076898&idx=1&sn=32b7591a6385ab695d5070061bf18a0a&scene=1&srcid=04276Jyhm6g4QMOyPgfm8jxj#wechat_redirect">再谈 API 的撰写 - 子系统</a>；</li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=402114651&idx=1&sn=a7b891f532e29b73afd83f17ae071023&scene=1&srcid=0427CHvTKeMIQsr5uT3x9nIN#wechat_redirect">再谈 API 的撰写 - 契约</a>；</li>
</ul>
<p>通过这一系列文章，大神已经自顶向下的把构建一个合格的 RESTful API Server 的要点都涉及到了，并且基本都是最佳实践，值得反复咀嚼。这一篇我结合自己的实践做一些 localization 的总结和实践归纳。文中都以 Node.js 的 Express 框架来举例。</p>
<span id="more"></span>

<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><blockquote>
<p>All problems in computer science can be solved by another level of indirection.<br>—— David Wheeler</p>
</blockquote>
<p>分层架构是最常见的软件架构，作为 API Server，一般我们也采用这样的架构，而在 Web 后端架构中最流行的当然是 MVC 的架构模式。不过，View 层对于 API server 是没有的。</p>
<p>先梳理一下操作流程，前端请求 URL 经过 Router 匹配，之后 Controller 层进行数据处理，不过数据处理一般是繁杂的，这里可以再分一层叫 Service 层，处理所有与数据库直接交互的部分，也便于 Controller 层对于相同功能进行再拆分和复用，最后返回。这样的分层模型我们不如叫 MRCS 比较精确。</p>
<p>具体来说：</p>
<ul>
<li>Model：与数据库的数据模型一一对应，定义了整个项目的所有数据操作的模型基础；</li>
<li>Router：API Server 所有定义的路由；</li>
<li>Controller：因为已经有 Service 层，所有这里仅进行一些输入参数的验证和解析以及结果数据的重新组织和返回，更底层的数据库交互交给 Service 层；</li>
<li>Service：所有与数据库和缓存的数据交互都在这里，这里的函数不是与 Controller 层的函数一一对应的，而应该是更细小颗粒功能的划分，让 Controller 层来进行组织，从而实现对底层功能的充分复用。</li>
</ul>
<h2 id="文档与接口参数验证"><a href="#文档与接口参数验证" class="headerlink" title="文档与接口参数验证"></a>文档与接口参数验证</h2><p>一个普通的网站可以没有对外的文档，可是一个 API Server 却一定得有文档，没有文档的 API Server 毫无意义。</p>
<p>而且，文档和接口参数验证是紧密相关的，如果你把这两部分分开了，那说明你一定是在某处重复定义了接口的参数模型。所以这两部分放在一起来讲。这也就是说，不管具体是写在哪，接口参数模型只手写定义一次，文档生成和参数验证都以这同一个定义为依据来进行（这样也极大的增强了文档与代码一致性的可能）。接口参数验证的同时也可以进行部分参数解析的工作，比如还原参数的类型（前端传递过来的都是 String），甚至还可以顺手把数据组织成 Controller 层需要的格式。</p>
<p>程序员一般而言都是不喜欢写文档的，团队也通常没有更多的资源让专人来维护文档，所以如何花费最小的代价完成与代码一致的高质量的文档是一个很重要的课题。</p>
<p>一个好的文档系统应该具备的特性：</p>
<ul>
<li>具有良好的机制尽可能保证代码和文档的一致性；</li>
<li>不同版本之间<code>diff</code>的功能；</li>
<li>每一个定义的接口下面可以直接在线进行类似于 Postman 的接口可用性测试；</li>
<li>需要重复定义的部分可以抽象出来，定义一次，多处复用；</li>
</ul>
<p>如果你时间充裕，并且想做边际效应高的事情，那么你可以考虑使用 Swagger。这是一个庞大的文档框架体系，工具全面且强大，但有些门槛，需要学习一段时间（使用可以参看我的下一篇博文：<a href="http://maples7.com/2016/09/06/build-doc-system-of-express-api-server-with-swagger/">使用Swagger构建Express API Server的文档系统</a>）。类似的还有RAML，这是一门基于 YAML 的文档建模语言，用法灵活，功能强大，但是目前工具还不是很靠谱，或许因为用的人也不是很多，项目显得有些缺乏维护，不过我觉得它对于构建文档系统的指导思想是很先进的。</p>
<p>如果是为了花费最小的成本，可以使用 apidoc，这就是一个普通的 npm 包，你可以直接使用它从函数注释生成 HTML 文档，支持版本对比，支持继承复用，支持接口在线可用性测试。另外，使用这个包的插件可以直接从 json-schema 中导入对参数模型的定义，这样只需要定义一次，就可以同时用 json-shcema 进行接口参数验证和生成文档。<del>目前我一般选择这种方案。</del>不过你也可以反过来，先在注释上定义所有的文档参数模型，然后用一个 Parser 解析从而验证参数（我相信 apidoc 中是有一个这样的 Parser 的，不过对外没有提供参数验证的功能，我也没有找到第三方的插件可以实现，或许有时间可以自己去写一个插件或者直接在 apidoc 上实现）。如果你采用后一种方案，那么分清程序的<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=402003317&idx=1&sn=68dabd5cbf565ab3fd99f90641a01a9f&scene=21#wechat_redirect">「编译时」和「运行时」</a>很重要，因为如果你要从注释解析后验证参数，那么你必须在「编译时」就已经从注释获得了所有的接口参数的定义模型，只有这样在「运行时」才能快速进行接口参数模型的匹配与验证。</p>
<p>文档最后需要部署到一个外部可以查看到的地方供使用者查阅和测试，这时可以借助 gulp 等类似工具来尽可能自动化的实现。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>一般的软件可能需要开发书写单元测试，可是个人觉得 API Server 的单元测试和接口测试实际上做的是很多重复的工作。所以我觉得 API Server 直接对接口进行功能性测试就好。</p>
<p>不过接口测试是非常难写的，一个接口需要完整测试的 test cases 可能高达十几个甚至几十个。除了更好的对接口进行划分外，目前我还没想好如何缓解这个问题。</p>
<p>不管怎么说，需要持续维护的项目都应该写测试，API Server 依然可以用<code>Mocha/should/supertest/istanbul/gulp</code>这套技术栈来书写自动化的接口测试。</p>
<h2 id="统一数据返回"><a href="#统一数据返回" class="headerlink" title="统一数据返回"></a>统一数据返回</h2><p>好的 API Server 应该定义统一的数据返回格式，这应该成为与前端的固定约定，这样前端才能方便的对返回数据进行验证和进一步操作。这就好比浏览器通过 Status Code 来进行对应的后续操作一样。</p>
<p>为了实现这一点，所有的接口调用在返回给前端之前都应该经过至少同一个中间件进行数组格式的重新组织，并且匹配到合适的 HTTP Status Code 以及自定义的返回码（非正常的数据返回时自定义的返回码，这个也是与前端的约定之一）和明确的返回信息，JSON 化之后返回。</p>
<h2 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h2><p>数据序列化分为输入数据的序列化和输出数据的序列化。</p>
<p>输入数据的序列化可以在前文所述的接口参数验证时完成（不复杂的情况下），也可以单独在一个中间件中完成。其实这一步不是必要的，因为通常各个接口的 Controller 需求是各不一样的，这里只能进行一些通用化的序列化操作。</p>
<p>相比于输入数据的序列化，输出数据的序列化要重要得多，而且一般通用性更强。举例来说，你有很多个接口都需要返回数据库中的同一个数据实例，但是不同接口需要返回给前端的字段和内容可能是各不一样的，此时就可以在这一步把输出数据序列化成前端的要求。最后的返回数据都是最精简且语义化良好的。这一步的操作可以有效节省网络流量，对移动端和处女座程序员都很有意义。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存不是必需的，但却是对高性能服务的基本要求。一个好的缓存设计不仅对性能有影响，而且对后期的开发调试也有很大影响。毕竟，解决了缓存，你就已经解决的计算机科学中一半的难题（:D）：</p>
<blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things.<br>—— Phil Karlton</p>
</blockquote>
<p>你可以进行路由层级的缓存设计，也可以进行数据库操作层级的缓存设计。但不管缓存怎样设计，除去基本的可用性和鲁棒性之外，最大的目标应该是对使用者尽可能友好：</p>
<blockquote>
<p>Simplicity is the ultimate sophistication.   - Leonardo Da Vinci</p>
</blockquote>
<p>「对使用者尽可能友好」指的是：</p>
<ol>
<li>接口调用简单，甚至不需要手动调用；</li>
<li>缓存可以自动过期；</li>
<li>尽可能保证已经无效的缓存（缓存数据已经与真实数据不一致，也可以称为旧的缓存）可以无遗漏的尽快被删除；</li>
</ol>
<p>第3点尤其重要，因为如果程序员手动控制缓存删除，那么对同一个数据块缓存的操作代码可能分散在项目各处，很难保证及时和没有遗漏。不过目前我也没有找到比较好的实现方案，初步的想法是如果能实现有一个 watcher 可以监听某一个数据块是否即将被改动（或者是否刚刚已经被改动）就好了。如果即将被更改，那在更改后立刻自动删除旧缓存。其实我觉得这个方案可以在 ORM 中实现，但目前没有发现有 ORM 支持这一点。</p>
<p>与「设计」一样，缓存系统的终极目标应该是使上层使用者根本感觉不到它的存在。这是指，当你调用获取数据的底层接口时，你无需知道数据是来源于真实数据库还是缓存。做到这一点无疑很难，不过你至少可以做到把对上层系统的影响降到最低，也就是说，使用缓存和不使用缓存只需要更改尽可能少的代码即可以轻易实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文没有提到标题中 RESTful 相关的东西，主要是路由设计的时候遵循 RESTful 的原则就可以了，无需多讲。</p>
<p>另外，很多东西还只是提供了一个基本的方向和原则，还有待更多的实践来验证和改进。</p>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><ol>
<li><p>Facebook 提出了一种新的不同于 REST 的 API 数据查询标准——<a href="http://graphql.org/">GraphQL</a>，这套标准可以让前端（广义的，包含移动端）来定义需要获取的数据模型，这样做可以极大的减轻后端对于前文所述的文档、接口参数验证、统一数据返回、数据序列化的工作，看起来很有意思。更多了解除了<a href="http://graphql.org/">官网</a>之外，还可以参考这篇文章：<a href="http://imweb.io/topic/58499c299be501ba17b10a9e">《新一代数据查询语言 GraphQL 来啦！》</a>。</p>
</li>
<li><p>Google 在这方面当然也毫不示弱，它家的 Google+ API 中也有类似的思想：<a href="https://developers.google.com/+/web/api/rest/#partial-response">Partial Responses</a>。具体说，利用请求的参数<code>fields</code>来由客户端决定哪些返回参数是我这次请求所需要的。当然，这没有 Facebook 的 GraphQL 功能系统和强大，只能返回一个API全集数据的一个子集，不过它是完全基于REST的，这意味着你可能只需对你现有的系统做最小的改动即可实现类似的功能，减轻后端对于输出数据序列化的负担。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>RESTful</tag>
        <tag>API</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>用 ES6 特性实现一个标准的轻量级 Promise</title>
    <url>/2016/08/29/implement-a-clean-promise-with-es6-features/</url>
    <content><![CDATA[<p>Promise 应该是目前 JavaScript 中最流行的异步流程控制解决方案，本文将介绍如何使用 JavaScript ES6 的语言特性，实现一个轻量级的通过了所有<a href="https://github.com/promises-aplus/promises-tests">官方测例</a>标准的 Promise 库。了解其原理，深入其实现。实际上，Promise 也早已被写入 JavaScript ES6 的标准，作为官方支持的标准异步流程控制解决方案之一。用 ES6 语法实现一个 ES6 中的 Promise，虽然看似没有必要，不过对于深入理解 Promise 以便更好的使用大有裨益。</p>
<p>为了您的最佳阅读体验，在阅读本文之前，建议您已经做到如下事情：</p>
<ul>
<li>可以熟练使用至少任意一个 Promise 库，如 bluebird、Q 等；</li>
<li>了解 Promise 标准，可以<a href="https://promisesaplus.com/">看这里</a>；</li>
<li>熟悉主要的 JavaScript ES6 特性；</li>
</ul>
<span id="more"></span>
<h3 id="构造函数之前的准备"><a href="#构造函数之前的准备" class="headerlink" title="构造函数之前的准备"></a>构造函数之前的准备</h3><p>我们都知道，Promise 总共有三种状态：pending、fullfilled（resolved）和 rejected。所以我们对于每一个 Promise 实例都需要一个变量记录其现有的状态。</p>
<p>然后还需要一个变量记录其 settled 之后的结果。另外，Promise 作为一个异步流程控制库，在上游的 Promise 还处于 pending 状态时下游 Promise 是不能执行的，所以我们至少需要一个数组来记录当前 Promise 还未 settled 时它后续的一些操作（你可以用两个数组分别记录 resolved 和 rejected 之后不同的操作；也可以用一个数组，然后每个元素都是包含两个属性的对象，分别记录 resolved 和 rejected 之后不同的操作）。</p>
<p>另外，借用面向对象的说法，这些变量对 Promise 而言应该是私有的，即不应该对外界暴露（这也是符合标准的）。所以待会儿构造函数之中应该定义一些私有变量，而 ES6 的 Symbol 类型则可以完美实现我们所需的私有变量。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Promise 状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">STATUS</span> = &#123;</span><br><span class="line">    <span class="attr">PENDING</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">RESOLVED</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">REJECTED</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _status = <span class="title class_">Symbol</span>(<span class="string">&#x27;status&#x27;</span>); <span class="comment">// 用于 status 私有变量的 Symbol</span></span><br><span class="line"><span class="keyword">const</span> _result = <span class="title class_">Symbol</span>(<span class="string">&#x27;result&#x27;</span>); <span class="comment">// 用于 result 私有变量的 Symbol</span></span><br><span class="line"><span class="keyword">const</span> _callbacks = <span class="title class_">Symbol</span>(<span class="string">&#x27;callbacks&#x27;</span>); <span class="comment">// 用于 callbacks 私有变量的 Symbol</span></span><br></pre></td></tr></table></figure>

<p>这里我们将 Promise 状态定义到一个对象之中，并且用属性名语义化状态，值其实没什么意义，但是这样写符合「让错误更早的暴露出来」的编程原则，让编译器（或解释器）去帮我们提前检测错误，总比写在字符串在运行时才把定位还不一定准确的错误暴露出来要好。</p>
<p>其次，还定义了几个用于定义私有变量的 Symbol。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数无非是给变量做一些初始化的工作，然后执行用户传入的函数。关键在于我们需要定义好传入的函数的参数，即<code>resolve</code>和<code>reject</code>函数。</p>
<p>先看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">exec</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">typeof</span> (exec) === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Promise constructor argument exec must be a function.&#x27;</span>) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self[_status] = <span class="variable constant_">STATUS</span>.<span class="property">PENDING</span>; </span><br><span class="line">    self[_result] = <span class="literal">undefined</span>;</span><br><span class="line">    self[_callbacks] = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (self[_status] === <span class="variable constant_">STATUS</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">                self[_status] = <span class="variable constant_">STATUS</span>.<span class="property">RESOLVED</span>;</span><br><span class="line">                self[_result] = value;</span><br><span class="line">                self[_callbacks].<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> cb.<span class="title function_">onResolved</span>(self[_result]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">        <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (self[_status] === <span class="variable constant_">STATUS</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">                self[_status] = <span class="variable constant_">STATUS</span>.<span class="property">REJECTED</span>;</span><br><span class="line">                self[_result] = reason;</span><br><span class="line">                self[_callbacks].<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> cb.<span class="title function_">onRejected</span>(self[_result]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">exec</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数里，首先限制了用户传入的参数必须为函数，然后将状态置为<code>pending</code>，并初始化<code>result</code>和<code>callbacks</code>。</p>
<p>之后，尝试运行用户传入的函数，并提供我们自己定义的<code>resolve</code>和<code>reject</code>函数作为参数。因为运行函数可能会抛出难以预期的错误，所以外面用<code>try...catch</code>包裹一层，并把错误用<code>reject</code>处理，表示当前 Promise 被 reject。</p>
<p>这里的关键在于我们自己定义的<code>resolve</code>和<code>reject</code>函数。</p>
<p>其实<code>resolve</code>和<code>reject</code>的逻辑也很简单，首先因为标准里规定对于<code>resolve</code>和<code>reject</code>的调用必须是异步的，来避免阻塞（<code>.then</code>方法的两个参数同理），所以外面套了一层<code>nextTick</code>（这里对前后端做了兼容，前端指向<code>setTimeout</code>，后端指向<code>process.nextTick</code>）。内层首先保证当前 Promise 还处于<code>pending</code>状态（标准规定状态只能由<code>pending</code>转向其他两个，并且一经转变不能更改），然后分别将状态置为<code>resolved</code>或<code>rejected</code>，最后顺次执行之前由于还未 settled 时存储在<code>callbacks</code>里面的后续回调函数集。</p>
<h3 id="then"><a href="#then" class="headerlink" title=".then"></a>.then</h3><p><code>.then</code>函数接受两个函数作为参数，分别对应前一个 Promise 被 resolve 或 reject 之后的回调。</p>
<p>首先来看一下函数的主逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (self[_status]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable constant_">STATUS</span>.<span class="property">RESOLVED</span>:</span><br><span class="line">        childPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="title function_">childExec</span>(self[_result], onResolved, resolve, reject, childPromise));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable constant_">STATUS</span>.<span class="property">REJECTED</span>:</span><br><span class="line">        childPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="title function_">childExec</span>(self[_result], onRejected, resolve, reject, childPromise));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable constant_">STATUS</span>.<span class="property">PENDING</span>:</span><br><span class="line">        childPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            self[_callbacks].<span class="title function_">push</span>(&#123;</span><br><span class="line">                <span class="attr">onResolved</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="title function_">childExec</span>(value, onResolved, resolve, reject, childPromise),</span><br><span class="line">                <span class="attr">onRejected</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="title function_">childExec</span>(value, onRejected, resolve, reject, childPromise)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>: </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Invalid status value&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前一个 Promise 的状态，分三种情况，其中<code>resolved</code>和<code>rejected</code>时是类似的：<code>new</code>一个新的 Promise 实例作为当前的 Promise，同理异步执行传入的函数（细节见下文<code>childExec</code>函数）。而当状态是<code>pending</code>时，我们只能先把回调函数先压入前一个 Promise 的回调函数队列，等<code>settled</code>后再执行。</p>
<h4 id="childExec"><a href="#childExec" class="headerlink" title="childExec"></a>childExec</h4><p><code>childExec</code>本身是为了最大化复用代码而重构独立出来的一个函数，代码很简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">childExec</span>(<span class="params">value, onDone, resolve, reject, childPromise</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value = <span class="title function_">onDone</span>(value);</span><br><span class="line">        <span class="title function_">solver</span>(childPromise, value, resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下：不管是前一个 Promise 是<code>rejected</code>还是<code>resolved</code>，用传入<code>.then</code>的对应的回调函数执行前一个 Promise settled 之后的结果<code>result</code>，然后执行<code>solver</code>（见下文对<code>solver</code>的分析）。同样的，外面需要包裹一层<code>try...catch</code>。</p>
<h4 id="solver"><a href="#solver" class="headerlink" title="solver"></a>solver</h4><p><code>solver</code>函数是不同的 Promise 实现之间（比如 bluebird 对 Promise 的实现与 ES6 原生对 Promise 的实现）能够无缝调用的关键。对此，<a href="https://promisesaplus.com/#point-45">Promise 标准中也有详述，甚至已经把这个函数的逻辑和流转都已经完完本本的列出来了，任何 Promise 实现只要遵循这个标准，就可以实现不同 Promise 实现之间的交叉调用</a>。</p>
<p>看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solver</span>(<span class="params">promise, result, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> then, settled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (promise === result) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cycle Promises&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result[_status] === <span class="variable constant_">STATUS</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">            result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">solver</span>(promise, v, resolve, reject), reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((result !== <span class="literal">null</span>) &amp;&amp; (<span class="keyword">typeof</span> (result) === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> (result) === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            then = result.<span class="property">then</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> (then) === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                then.<span class="title function_">call</span>(result, <span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (settled) <span class="keyword">return</span>;</span><br><span class="line">                    settled = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_">solver</span>(promise, s, resolve, reject);</span><br><span class="line">                &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (settled) <span class="keyword">return</span>;</span><br><span class="line">                    settled = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_">reject</span>(r);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (settled) <span class="keyword">return</span>;</span><br><span class="line">            settled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>如果上一个 Promise 的<code>result</code>跟子 Promise 还是同一个对象，显然是循环调用了，按标准规定抛出<code>TypeError</code>；</li>
<li>如果上一个 Promise 的<code>result</code>还是本 Promise 实现的实例，那挺好，直接调用它的<code>then</code>就好。不过，上一个 Promise 返回的新 Promise 可能还没有 settled，所以如果没有 settled，我们在它的<code>onResolved</code>函数中直接继续执行<code>solver</code>直到它被 settled（看起来像用递归的形式表现循环迭代）；</li>
<li>如果返回的不是当前 Promise 实现的实例，但是它是一个有<code>.then</code>方法的对象或者函数，那我们直接用它的<code>then</code>方法<code>call</code>在<code>result</code>上，并且在它的回调函数<code>onResolved</code>中用<code>.then</code>传递的<code>s</code>继续调用<code>solver</code>或者在<code>onRejected</code>函数中<code>reject</code>掉这个 Promise。值得注意的是，由于一个 Promise 只能被 settled 一次，而第三方的<code>.then</code>方法我们不知道里面具体是什么内容，所以用一个<code>Boolean</code>量<code>settled</code>来标记，保证它只被 settled 一次，之后的调用都直接被忽略（标准也是这样规定的）；</li>
<li>如果只是一个简单值，直接<code>resolve</code>。</li>
</ul>
<p>另外，尽管在<code>childExec</code>中我们已经用<code>try...catch</code>包裹了一层，但是异步调用的错误依然可能不会被捕获，所以这里依然需要<code>try...catch</code>。</p>
<p>至此，一个符合标准的 Promise 最小化实现就已经完成了。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在你的 Promise 写好后，需要进行测试，至少需要通过的官方测例在这里：<a href="https://github.com/promises-aplus/promises-tests">Promises&#x2F;A+ Compliance Test Suite</a>。通过所有测例之后表明你的 Promise 实现是基本符合标准的。</p>
<p>按其说明，你需要提供一个这样的类静态函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">deferred</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;;</span><br><span class="line">    dfd.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        dfd.<span class="property">resolve</span> = resolve;</span><br><span class="line">        dfd.<span class="property">reject</span> = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数返回一个对象，并用<code>resolve</code>和<code>reject</code>属性引用构造函数中自定义的<code>resolve</code>和<code>reject</code>函数，用<code>promise</code>属性引用一个 Promise 实例。</p>
<p>之后用<code>promises-aplus-tests</code>命令运行测试（需要提前安装<code>promises-aplus-tests</code>包）。</p>
<h3 id="常用的其他辅助接口"><a href="#常用的其他辅助接口" class="headerlink" title="常用的其他辅助接口"></a>常用的其他辅助接口</h3><p>一个成熟的 Promise 包肯定不会只有一个简单的<code>.then</code>方法，不过其他的的辅助接口都是在此最简基础上慢慢迭代出来的，相当于是一些方便用户使用的语法糖。</p>
<p>你可以在下文给出的 GitHub 源码链接中查看我的其他辅助方法的实现，逻辑基本都很清晰，本文不赘述了。</p>
<h3 id="Join-Me"><a href="#Join-Me" class="headerlink" title="Join Me"></a>Join Me</h3><p>目前，我的这个 Promise 实现已经放在了 npm 和 GitHub 上：</p>
<ul>
<li>npm：<a href="https://www.npmjs.com/package/clean-promise">clean-promise</a></li>
<li>GitHub: <a href="https://github.com/Maples7/clean-promise">Maples7&#x2F;clean-promise: a minimal implement of Promise</a></li>
</ul>
<p>Any issues and PRs are welcomed! :D</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果要细致的讲解每一个细节，恐怕 5 篇这样长度的文章还显不够，本文也只是将实现的骨架勾勒了出来。不过，源码是一个软件产品最好的背书，我就不啰嗦了。</p>
<p>个人觉得实现 Promise 的难度在于它本身的逻辑比较绕，因为标准设计得就比较精巧，每一个地方的衔接都经过深思熟虑，往往一个方法就会产生一个新的 Promise，有一种层层迭代的感觉，类似于「蚕」的结构，所以把层次厘清确实需要花一番功夫，要有耐心。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol>
<li><a href="https://github.com/xieranmaya/blog/issues/3">剖析 Promise 内部结构，一步一步实现一个完整的、能通过所有 Test case 的 Promise 类 #3 </a>；</li>
<li><a href="https://promisesaplus.com/">Promises&#x2F;A+</a>；</li>
</ol>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Swagger 构建 Express API Server 的文档系统</title>
    <url>/2016/09/06/build-doc-system-of-express-api-server-with-swagger/</url>
    <content><![CDATA[<p>如<a href="http://maples7.com/2016/09/05/build-qualified-restful-api-server/">上一篇博客</a>所说，好的文档系统对 API Server 至关重要，本文介绍在 Express 框架中使用 Swagger 构建一个良好的项目文档系统的基本流程，同时明确一些实践过程中肯定会遇到的问题的解决方案。本文遵循<code>Swagger 2.0</code>使用规范。</p>
<img data-src="https://i.loli.net/2018/08/06/5b672f1a563d0.png" class="" title="Swagger——The Most Popular Framework for APIs of The World" alt="图片显示错误">

<span id="more"></span>

<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>文档生成的「源」（或者说「依据」）与代码不分离，即直接用<code>jsdoc</code>注释生成文档；</li>
<li>可以用同样的「源」同时实现对接口输入输出参数的验证，最大化保证文档与后端具体实现之间的一致性；</li>
<li>文档在线可用性测试，并且可以完美解决跨域请求的问题；</li>
<li>在后端接口还未完成时，可以 Mock 返回数据；</li>
<li>最好能自动生成一些测试数据甚至自动进行测试；</li>
</ul>
<h2 id="从-JSDoc-到可视化文档"><a href="#从-JSDoc-到可视化文档" class="headerlink" title="从 JSDoc 到可视化文档"></a>从 JSDoc 到可视化文档</h2><h3 id="Step-1：定义接口模型"><a href="#Step-1：定义接口模型" class="headerlink" title="Step 1：定义接口模型"></a>Step 1：定义接口模型</h3><p>在 Controller 层每一条路由的函数注释上（具体来说，Routes 目录下或 Controller 目录下均可，只要配置好<code>Step 2</code>中的<code>swagger-jsdoc</code>，明确「源」所在的目录即可）按<code>Swagger YAML</code>语法定义接口模型，示例如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@swagger</span></span></span><br><span class="line"><span class="comment"> * definition:</span></span><br><span class="line"><span class="comment"> *   Puppy:</span></span><br><span class="line"><span class="comment"> *     properties:</span></span><br><span class="line"><span class="comment"> *       name:</span></span><br><span class="line"><span class="comment"> *         type: string</span></span><br><span class="line"><span class="comment"> *       breed:</span></span><br><span class="line"><span class="comment"> *         type: string</span></span><br><span class="line"><span class="comment"> *       age:</span></span><br><span class="line"><span class="comment"> *         type: integer</span></span><br><span class="line"><span class="comment"> *       sex:</span></span><br><span class="line"><span class="comment"> *         type: string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@swagger</span></span></span><br><span class="line"><span class="comment"> * /api/puppies:</span></span><br><span class="line"><span class="comment"> *   get:</span></span><br><span class="line"><span class="comment"> *     tags:</span></span><br><span class="line"><span class="comment"> *       - Puppies</span></span><br><span class="line"><span class="comment"> *     description: Returns all puppies</span></span><br><span class="line"><span class="comment"> *     produces:</span></span><br><span class="line"><span class="comment"> *       - application/json</span></span><br><span class="line"><span class="comment"> *     responses:</span></span><br><span class="line"><span class="comment"> *       200:</span></span><br><span class="line"><span class="comment"> *         description: An array of puppies</span></span><br><span class="line"><span class="comment"> *         schema:</span></span><br><span class="line"><span class="comment"> *           $ref: &#x27;#/definitions/Puppy&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/api/puppies&#x27;</span>, db.<span class="property">getAllPuppies</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@swagger</span></span></span><br><span class="line"><span class="comment"> * /api/puppies:</span></span><br><span class="line"><span class="comment"> *   post:</span></span><br><span class="line"><span class="comment"> *     tags:</span></span><br><span class="line"><span class="comment"> *       - Puppies</span></span><br><span class="line"><span class="comment"> *     description: Creates a new puppy</span></span><br><span class="line"><span class="comment"> *     produces:</span></span><br><span class="line"><span class="comment"> *       - application/json</span></span><br><span class="line"><span class="comment"> *     parameters:</span></span><br><span class="line"><span class="comment"> *       - name: puppy</span></span><br><span class="line"><span class="comment"> *         description: Puppy object</span></span><br><span class="line"><span class="comment"> *         in: body</span></span><br><span class="line"><span class="comment"> *         required: true</span></span><br><span class="line"><span class="comment"> *         schema:</span></span><br><span class="line"><span class="comment"> *           $ref: &#x27;#/definitions/Puppy&#x27;</span></span><br><span class="line"><span class="comment"> *     responses:</span></span><br><span class="line"><span class="comment"> *       200:</span></span><br><span class="line"><span class="comment"> *         description: Successfully created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/api/puppies&#x27;</span>, db.<span class="property">createPuppy</span>);</span><br></pre></td></tr></table></figure>

<p>一些抽象出来的<code>definition</code>直接在前面的<code>/** */</code>注释中定义即可。</p>
<p>在生成的完整配置中，同一个路径下的配置（比如上述示例中<code>/api/puppies</code>下的<code>get</code>与<code>post</code>）会合并在这同一个路径之下，所以同一个路径下的全局配置只用写一遍就行了（比如下文<code>Mock返回数据</code>小节中使用<code>Swagger Router</code>中间件需要的<code>x-swagger-router-controller</code>配置）。</p>
<h3 id="Step-2：生成-Swagger-接口定义"><a href="#Step-2：生成-Swagger-接口定义" class="headerlink" title="Step 2：生成 Swagger 接口定义"></a>Step 2：生成 Swagger 接口定义</h3><p>用 <a href="https://github.com/Surnet/swagger-jsdoc">swagger-jsdoc</a> 生成 JSON 格式的 Swagger 接口定义。<br>Demo：<a href="https://github.com/mjhea0/node-swagger-api">mjhea0&#x2F;node-swagger-api</a>。</p>
<p>这里不用把生成的 JSON 保存在本地磁盘上，直接用一个变量引用即可。</p>
<h3 id="Step-3：用-Swagger-UI-生成可视化文档"><a href="#Step-3：用-Swagger-UI-生成可视化文档" class="headerlink" title="Step 3：用 Swagger UI 生成可视化文档"></a>Step 3：用 Swagger UI 生成可视化文档</h3><p>在线查看：打开<a href="http://petstore.swagger.io/">http://petstore.swagger.io/</a>，在顶部的 URL 栏输入可以获取<code>Step 2</code>中生成的 JSON 格式的 Swagger 文档定义的 URL，<del>一般来说可以是<a href="http://localhost:3000/swagger.json">http://localhost:3000/swagger.json</a> （需要自己手动在代码中书写路由和请求的返回）</del> 在使用了后文要说明的<a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md#swagger-ui">Swagger UI 中间件</a>之后按照默认配置是 <a href="http://localhost:3000/api-docs">http://localhost:3000/api-docs</a> （注意最后没有<code>/</code>）。这种方式需要解决跨域请求的问题，详见后文。</p>
<p>本地离线查看：<del>直接在本项目 public（静态文件目录）下放置离线版<code>Swagger UI</code>，直接打开即可查看。详见<code>Step 2</code>中的 Demo 及作者的博文说明。</del>使用<code>swagger-tools</code>中的<a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md#swagger-ui">Swagger UI 中间件</a>，如果你直接使用默认配置：</p>
<ul>
<li><a href="http://localhost:3000/docs/">http://localhost:3000/docs/</a> 可以看到完整的可视化文档；</li>
<li><a href="http://localhost:3000/api-docs">http://localhost:3000/api-docs</a> （注意最后没有<code>/</code>）可以看到自己在<code>Step 2</code>中自动生成的 Swagger 接口定义。</li>
</ul>
<p>这个中间件可以让你在开发时再也无需操心可视化文档的前端实现和如何查看自动生成 Swagger 接口定义（以便确定是否符合规范和自己的需求）的问题。</p>
<h2 id="一些常见问题"><a href="#一些常见问题" class="headerlink" title="一些常见问题"></a>一些常见问题</h2><h3 id="解决跨域请求的问题"><a href="#解决跨域请求的问题" class="headerlink" title="解决跨域请求的问题"></a>解决跨域请求的问题</h3><p>官方说明见：<a href="https://github.com/swagger-api/swagger-ui#cors-support">https://github.com/swagger-api/swagger-ui#cors-support</a>。<br>在<code>app.use(&#39;/&#39;, routes);</code>之前加一个如下的中间件设置一些 cors 相关的头可以解决问题:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://petstore.swagger.io&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">setHeader</span>(</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;GET, POST, DELETE, PUT, PATCH, OPTIONS&#x27;</span></span><br><span class="line">  );</span><br><span class="line">  res.<span class="title function_">setHeader</span>(</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type, api_key, Authorization&#x27;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="接口参数验证"><a href="#接口参数验证" class="headerlink" title="接口参数验证"></a>接口参数验证</h3><p>使用<code>swagger-tools</code>中的<a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md#swagger-metadata">Swagger Metadata</a>和<a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md#swagger-validator">Swagger Validator</a>中间件：</p>
<ul>
<li><a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/QuickStart.md">swagger-tools Quick Start</a>；</li>
<li><a href="https://github.com/apigee-127/swagger-tools/tree/master/examples/2.0">Demo</a>；</li>
</ul>
<p>其中 Swagger Metadata 中间件做了匹配请求路由与 Swagger 定义路由以及解析参数的工作，Swagger Validator 中间件做了验证参数类型和其他已定义的参数限制的工作。</p>
<h3 id="Mock-返回数据"><a href="#Mock-返回数据" class="headerlink" title="Mock 返回数据"></a>Mock 返回数据</h3><p>使用<code>swagger-tools</code>中的<a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md#swagger-router">Swagger Router 中间件</a>即可实现。</p>
<p>正常情况下，根据你的 Swagger 定义会返回<code>Response Code</code>为<code>200</code>（当 Swagger 定义中已定义<code>200</code>的返回时）的类似这样的数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sample text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;breed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sample text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sample text&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h3 id="自动生成测试代码"><a href="#自动生成测试代码" class="headerlink" title="自动生成测试代码"></a>自动生成测试代码</h3><p>使用<a href="https://github.com/apigee-127/swagger-test-templates">apigee-127&#x2F;swagger-test-templates</a>可以根据你的 Swagger 定义自动生成对所有接口功能测试的脚手架代码（基本可以自动确定的地方都自动生成了），在你把自动生成的代码写入磁盘文件后，只需修改极少量的地方（一般是提供一些需要测试的参数）就可以使用测试。</p>
<p>自动生成的代码长成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZSchema</span> = <span class="built_in">require</span>(<span class="string">&#x27;z-schema&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> validator = <span class="keyword">new</span> <span class="title class_">ZSchema</span>(&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> supertest = <span class="built_in">require</span>(<span class="string">&#x27;supertest&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> api = supertest(<span class="string">&#x27;http://localhost:3000&#x27;</span>); <span class="comment">// supertest init;</span></span><br><span class="line"></span><br><span class="line">chai.<span class="title function_">should</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;/api/puppies&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">describe</span>(<span class="string">&#x27;get&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&#x27;should respond with 200 An array of puppies&#x27;</span>, <span class="keyword">function</span>(<span class="params">done</span>) &#123;</span><br><span class="line">      <span class="comment">/*eslint-disable*/</span></span><br><span class="line">      <span class="keyword">var</span> schema = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;array&#x27;</span>,</span><br><span class="line">        <span class="attr">items</span>: &#123;</span><br><span class="line">          <span class="attr">$ref</span>: <span class="string">&#x27;#/definitions/Puppy&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*eslint-enable*/</span></span><br><span class="line">      api</span><br><span class="line">        .<span class="title function_">get</span>(<span class="string">&#x27;/api/puppies&#x27;</span>)</span><br><span class="line">        .<span class="title function_">set</span>(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">        .<span class="title function_">expect</span>(<span class="number">200</span>)</span><br><span class="line">        .<span class="title function_">end</span>(<span class="keyword">function</span>(<span class="params">err, res</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">done</span>(err);</span><br><span class="line"></span><br><span class="line">          validator.<span class="title function_">validate</span>(res.<span class="property">body</span>, schema).<span class="property">should</span>.<span class="property">be</span>.<span class="property">true</span>;</span><br><span class="line">          <span class="title function_">done</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">describe</span>(<span class="string">&#x27;post&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&#x27;should respond with 200 Successfully created&#x27;</span>, <span class="keyword">function</span>(<span class="params">done</span>) &#123;</span><br><span class="line">      api</span><br><span class="line">        .<span class="title function_">post</span>(<span class="string">&#x27;/api/puppies&#x27;</span>)</span><br><span class="line">        .<span class="title function_">set</span>(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">        .<span class="title function_">send</span>(&#123;</span><br><span class="line">          <span class="attr">puppy</span>: <span class="string">&#x27;DATA GOES HERE&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">expect</span>(<span class="number">200</span>)</span><br><span class="line">        .<span class="title function_">end</span>(<span class="keyword">function</span>(<span class="params">err, res</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">done</span>(err);</span><br><span class="line"></span><br><span class="line">          res.<span class="property">body</span>.<span class="property">should</span>.<span class="title function_">equal</span>(<span class="literal">null</span>); <span class="comment">// non-json response or no schema</span></span><br><span class="line">          <span class="title function_">done</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>之后可以考虑用 gulp 把测试串联起来进行自动化测试。npm 上已经有<a href="https://www.npmjs.com/package/gulp-swagger-test-templates">这样的包</a>，不过我还没有试过。</p>
<p>目前这个包对于<code>Swagger 2.0</code>的支持还不是很完全，尤其是对<code>$ref</code>不能自动解析，这样的话需要手动改动的测试代码多一些，不过他们正在着力解决这个问题，估计下一个版本（1.3.0）就会加入对<code>$ref</code>的解析，详细的讨论可以<a href="https://github.com/apigee-127/swagger-test-templates/issues/104">看这个 issue</a>。同时，他们还在考虑添加通过 JSON-Schema 自动批量生成测试数据的功能，目测<a href="https://github.com/apigee-127/swagger-test-templates/pull/107">也将在下一个版本中推出</a>，值得期待。</p>
<h3 id="Mock-或-Swagger-UI-失效"><a href="#Mock-或-Swagger-UI-失效" class="headerlink" title="Mock 或 Swagger UI 失效"></a>Mock 或 Swagger UI 失效</h3><p>由于异步的问题，如果你把<code>app.lieten</code>写在<code>swaggerTools.initializeMiddleware</code>的回调函数外面，那很可能在你的应用已经启动时，<code>swagger-tools</code>的中间件并没有加载完毕，导致中间件失效（不会报错）。</p>
<p>鉴于此，应该尽量把<code>swaggerTools.initializeMiddleware</code>写在中间件链的后面部分，然后把位于其后的<code>app.use</code>（比如<code>app.use(&#39;/&#39;, routes);</code>）和<code>app.listen</code>写在<code>swaggerTools.initializeMiddleware</code>的回调函数内部。所以，<code>Express 4</code>中提倡的用<code>./bin/www</code>来启动应用的要求在这里可能无法被遵循了。</p>
<p>更详细的讨论<a href="https://github.com/apigee-127/swagger-tools/issues/328">看这个 issue</a>。</p>
<p>另外，Mock 失效还有可能是你已经提供了对应 Controller 来 Handle 对应的 Route 请求。并不是将 Swagger Router 中间件中的<code>useStubs</code>设为<code>true</code>就一定会启动 Mock，官方对此说明是：</p>
<blockquote>
<p>Stubs only work for requests where the controller and&#x2F;or controller method is missing. Since you have a working controller method, enabling stub mode doesn’t do anything. It’s working as designed.</p>
</blockquote>
<p>更详细的讨论可以<a href="https://github.com/apigee-127/swagger-tools/issues/48">看这个 issue</a>。</p>
<h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><p>使用<code>DEBUG=swagger-tools* node app</code>启动项目，控制台会输出更多详细的信息。</p>
<h2 id="完整的-Demo"><a href="#完整的-Demo" class="headerlink" title="完整的 Demo"></a>完整的 Demo</h2><p><a href="https://github.com/Maples7/swagger-express-demo">Maples7&#x2F;swagger-express-demo</a>： 将前面所讲的内容整合进了一个小示例中，以供参考。</p>
<h2 id="上手必读"><a href="#上手必读" class="headerlink" title="上手必读"></a>上手必读</h2><ol>
<li><a href="http://swagger.io/specification/">swagger-spec</a>；</li>
<li><a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/QuickStart.md">swagger-tools&#x2F;docs&#x2F;QuickStart.md</a>；</li>
<li><a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md">swagger-tools&#x2F;docs&#x2F;Middleware.md</a>；</li>
<li><a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/API.md">swagger-tools&#x2F;docs&#x2F;API.md</a>；</li>
</ol>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>API</tag>
        <tag>Express</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>失落之星</title>
    <url>/2016/09/10/lost-stars/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=28747428&auto=0&height=66"></iframe>
_Life is like a long journey_   
_Some ones get on and some off_   
_Those can accompany me to the destination are rare_   
_Even none_   
_Do not feel bad or complain_    
_Farewell and thanks to each for the company_

<span id="more"></span>  
<p>译自：</p>
<blockquote>
<p>人生就像一场长途旅行<br>有人上车 也有人下车<br>能陪我坐到最后的人少之又少<br>甚至 可能没有<br>所以不要对下车的人太不舍 也不要怨愤<br>要好好跟他们道别<br>感谢彼此陪伴的这一段旅程   </p>
</blockquote>
<p><em>From:</em> <a href="http://m.weibo.cn/5505502029/4018205955518754?uicode=10000002&moduleID=feed&featurecode=10000001&mid=4018205955518754&luicode=10000001&_status_id=4018205955518754&rid=20_0_8_2666547007196013052&fromlog=100013888197280&lfid=100013888197280">Sina Weibo: Pepe佩佩小姐</a></p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>Lost Stars</tag>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title>编程的快感之「易于驾驭的介质」</title>
    <url>/2016/09/20/pleasure-of-programming-media-easy-to-manipulate/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p><em>编程快乐是一种创建事物的纯粹快乐，这种快乐的来源之一来自于在易于驾驭的介质上工作</em></p>
<p><strong>《人月神话》</strong></p>

</blockquote>

<p><a href="https://book.douban.com/subject/1102259/">《人月神话》</a>是几乎每个程序员都或多或少了解过的一本书，著名的<a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">「没有银弹(No Silver Bullet)」</a>的软件工程理论就被其作者<a href="https://en.wikipedia.org/wiki/Fred_Brooks">Fred Brooks</a>收录在这本书中。</p>
<p>这本书的第一章「焦油坑」就讨论了「编程的快感是什么？」这样一个对大多数程序员来说不言而喻，但如果要具体说说或许又难以准确表达出来的一个问题。简要归纳一下，原书提供了这样几个答案：</p>
<span id="more"></span>
<ul>
<li>一种创建事物的纯粹快乐</li>
<li>开发对他人有用的东西</li>
<li>开发过程的强大魅力——将相互啮合的零部件组装在一起</li>
<li>持续学习的快乐以及非重复性</li>
<li><strong>在易于驾驭的介质上工作</strong></li>
</ul>
<p>我对「在易于驾驭的介质上工作」这个原因尤其认同，结合当下的现实，谈谈我的体会和想法。</p>
<h3 id="什么是「易于驾驭的介质」？"><a href="#什么是「易于驾驭的介质」？" class="headerlink" title="什么是「易于驾驭的介质」？"></a>什么是「易于驾驭的介质」？</h3><p>要说这个世界上最易于驾驭的介质是什么，我目前能想到的就是人的大脑（思维）。没有具体的形态，无需任何实体的操作，你想到了什么思维就已经被你操纵到了哪里（我不大确定到底是你在操作大脑还是大脑在操纵你）。你可以在大脑里创造出各种各样没有实体的东西。程序员或者文艺工作者往往有这样的体验，当你才思泉涌时，往往觉得双手都跟不上大脑运转的速度，就好像高速运转的 CPU 无法容忍相对而言低速的 I&#x2F;O 操作一样。</p>
<p>我无法给「易于驾驭的介质」下一个明确的定义，不过如果假设大脑（思维）就是这个世界上最易于驾驭的介质的话，那我可以自然地说能被操纵（manipulate）的速度越接近大脑的速度，这种介质就是越容易被驾驭的。</p>
<h3 id="为什么代码是易于驾驭的介质？"><a href="#为什么代码是易于驾驭的介质？" class="headerlink" title="为什么代码是易于驾驭的介质？"></a>为什么代码是易于驾驭的介质？</h3><p>我的个人经历就可以告诉我，代码绝对是工程领域最易于驾驭的介质。不同于传统的工科领域总是有具体的实体操纵对象或者危险难以控制的操纵对象，编程所操纵的对象——代码——算是太容易操纵的了，这是软件与硬件天然的区别。你无法说你磁盘上的那一串串 0 和 1 是实体的或者是危险的。即使不知名的宇宙射线打过来反转了你电脑内存中的某一个比特位，相信我，也不会有什么东西会爆炸的（或者极小概率）。</p>
<p>基于此，编程工作的易于操作性在于，你只消用你的个人电脑，按照一定的规则在键盘上对代码做出任何你想要的更改，你的程序就可以按照你的预期做出你想要的行为，尽管它没有实体无法给你端茶倒水，但在今天这个互联网时代，却已经创造出了前所未有的价值。</p>
<p>代码之于电脑，就像大脑之于人体一样。</p>
<h3 id="这种易于驾驭的介质带来了什么？"><a href="#这种易于驾驭的介质带来了什么？" class="headerlink" title="这种易于驾驭的介质带来了什么？"></a>这种易于驾驭的介质带来了什么？</h3><ol>
<li><strong>低廉的操作成本</strong>：与世俗的观念还是倾向于不想为看不见的东西的付费有关，操作代码的成本是低廉的，你只需要一台可计算设备即可。</li>
<li><strong>容易传播和产生影响</strong>：下载和使用一个软件现在已经是秒秒钟的事情，好的软件已经非常容易传播和拥有庞大的用户，这同时意味着代码中的任何问题也可能会造成巨大的破坏。</li>
<li><strong>低廉的试错成本</strong>：每一个产品迭代可能需要很多次才能达到用户满意的标准，一个不关键的 bug 可能需要很多次更新才能彻底解决，然而一个医生却无法把病人当成「小白鼠」来多次试验，一个建筑师却难以修补已建成建筑的设计缺陷。（此点灵感来自于：<a href="https://zhuanlan.zhihu.com/p/19690214">程序员混日子不完全手册</a>）</li>
</ol>
<p>把任何实体产业尽量转化为电脑中的 0 和 1，再利用其转化后的优势产生价值，这便是互联网+的本质。<br><br /></p>
<center>**诸位，幸福地来码代码吧！**</center>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>程序员</tag>
        <tag>《人月神话》</tag>
      </tags>
  </entry>
  <entry>
    <title>我心中理想的 Web 开发流程</title>
    <url>/2016/10/19/ideal-web-development-work-flow/</url>
    <content><![CDATA[<p>本文总结一下在几个月的 Web 开发实践后，我认为的<strong>目前</strong>进行 Web 开发的一些<strong>工作流程</strong>上的最佳实践。</p>
<p>需要事先声明的是，「最佳实践」这个词是相对的。一方面，Web 开发的世界纷繁复杂，我仅有的经验还远远只是管中窥豹的水平；另一方面，使用不同技术栈的人对某一些问题的答案往往存在争议，不同的人从不同的视角来了解 Web 开发这个庞大的领域，产生不同的理解和世界观也是十分正常的事情，需要理性看待。</p>
<span id="more"></span>

<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>都已经是 2016 年了，如果你还只是借助模板引擎在做一些前后端不分离的项目那你已经是 Out 了。</p>
<p>相对于传统意义上的 Web 项目，前后端分离的（本文指的不仅仅是开发模式上的分离，代码上同样也进行分离）Web 开发实践主要有以下几个优点：</p>
<ol>
<li><p>前端和后端并行敏捷开发，而不是传统的瀑布式开发模式：大概几年前，主流的 Web 开发模式还是前端基本完成后，后端再在前端基础上进行不分离的开发。而如今，这种开发模式已经跟不上日新月异的互联网世界的步伐。现在，在前后端统一了 API 规范之后，前端和后端的开发完全可以各自独立的进行，甚至是完全不同的立项。不过，在这种模式下，「契约」变得尤其重要。也就是说，一旦前后端对于 API 的约定一旦达成，就不要进行轻易的更改，如果实在是需要更改，则务必及时沟通协调进行修正（关于开发中的「契约」，建议深度阅读<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=402114651&idx=1&sn=a7b891f532e29b73afd83f17ae071023">这篇文章</a>）。在具体的实践上，我建议前后端先使用 Swagger 进行 API 设计和约定，后端迅速搭建出项目框架并定义好 API（但实际功能尚不实现），这样，一个简单的后端框架甚至可以直接作为 Mock Server 提供给前端进行开发使用，进一步降低前后端之间的耦合（关于 Node.js Web 开发下使用 Swagger 进行 API 文档系统的构建的具体实践，可以参考<a href="http://maples7.com/2016/09/06/build-doc-system-of-express-api-server-with-swagger/">我的这篇文章</a>）。</p>
</li>
<li><p>适应现在多形态终端的需求：无论是传统的 Browser 还是如今的各种移动端（手机、平板等），在前后端分离之后，后端都只需要进行统一的一次性开发就可以满足各个终端的数据需求，大大减少了工作量。这才是完完全全的后端只处理纯粹的数据，前端来处理应对各种需求的表现形式。</p>
</li>
<li><p>提高 Web 应用的性能：相对于传统模式，不需要进行模板渲染了，而且分离的模式会更有利于利用 HTTP 头来进行浏览器的页面缓存。</p>
</li>
</ol>
<p>以上还只是从实用主义的角度来看待前后端分离的优点，实际上这种开发方式也符合现在流行的「微服务」的理念。各个模块之间完全只通过 API 跟外界通信。只要 API 约定不变，里面怎么改都可以。高内聚，低耦合。</p>
<h2 id="使用现代化的前端框架"><a href="#使用现代化的前端框架" class="headerlink" title="使用现代化的前端框架"></a>使用现代化的前端框架</h2><p>商业实践目的的后端开发几乎不可能不使用成熟的框架，前端在近几年也频繁涌现出越来越多良好的开发框架。不过，目前前端在是否使用框架这一点上还是仁者见仁、智者见智。就个人而言，我还是推荐使用诸如 Vue.js、Angular.js、React.js 这样的现代化前端框架。原因在于，使用这些框架可以对前端开发进行更好的分层，从而使得项目变得<strong>更加易于维护</strong>。是的，我没有说其他原因，而仅仅是分层模型带来的更易于维护的优势。良好的分层架构可以使前端开发摆脱以前混乱且不统一的布局和架构，使得庞大的项目也能得到有效的维护。</p>
<h2 id="Git-与-Code-Review"><a href="#Git-与-Code-Review" class="headerlink" title="Git 与 Code Review"></a>Git 与 Code Review</h2><p>现代开发团队没有不使用团队协作开发工具的，而这之中最重要的工具就是源代码管理工具。</p>
<p>使用 Git（而不是 SVN）吧！Git 是目前设计理念最先进、使用也最广泛的源代码管理工具，相比一些老式的源代码管理工具有诸多优势（不然 Linus 也不会想去重复造新轮子了）。简单举例来说，Git 创建分支只是添加一个引用，十分迅速，而像 SVN 这样的老式工具，几乎只是在 branch 目录下将当前的主分支复制了一遍。如果你们团队还在使用 SVN 等老式的源代码管理工具，那说明你们的开发团队可能已经掉队很久了。</p>
<p>另一个使用 Git 的好处是，方便团队进行 Code Review。我这里说的 Code Review 不仅仅是很多团队口头上说说、实际却只是有空在代码提交 Log 里面随便看看的那种 Code Review，而是要真正落实到制度和规范上的 Code Review。具体来说，你可以利用一些与 Git 相关的现有的工具来实现一些强制的 Code Review 的规则，比如某个人的代码提交之后，会随机抽取团队中的其他三个人在 48 小时内进行 Review，只有三个人全部都 Review 通过之后，代码才真正提交到测试服务器。团队内部甚至可以做一个绩效考核的应用，可视化的展示团队中人员的代码提交以及 Code Review 的次数等指标（排行榜啊什么的，虽然程序员的绩效实际很难考核，但是不涉及实际利益的绩效展示玩具却可以有效激发程序员的创作欲），这样也可以侧面趣味性的激励团队成员进行 Code Review。</p>
<p>对于团队而言，进行 Code Review 的意义在于：</p>
<ul>
<li>代码质量和软件质量的重要保证；</li>
<li>缩短团队成员之间技术水平上的差距：看优秀的代码可以有效的提高技术水平，Code Review 不仅会促使成员写出高质量的代码，也会迅速把团队中暂时掉队的成员拉到团队的同一水平线上。实际上，软件开发也是有短板效应的，尤其是涉及到安全领域的开发时（Web 安全是 Web 开发中的重要一环），从这一点上看，Code Review 更加具有非凡的意义了；</li>
<li>团队代码风格会更加的统一：简单的制定代码风格规范并不能有效保证团队成员写出风格良好的代码，而 Code Review 机制则可以把良好的代码风格沉淀下去。</li>
</ul>
<h2 id="自动化测试与-CI"><a href="#自动化测试与-CI" class="headerlink" title="自动化测试与 CI"></a>自动化测试与 CI</h2><p>没什么太多可说的，在成熟的团队中，开发人员应该有写单元测试的责任。不写测试的后果是：手动测试浪费大量的人力物力、后期维护极其麻烦且成本高昂（而且任何微小的修改理论上就得手动测试一遍）、代码质量得不到根本上的保证、容易写出架构不合理或者分层不明确的代码。</p>
<p>更进一步来说的话，团队中应该配备有专门的测试人员进行比单元测试层级更高的测试（如集成测试），而且应当尽可能的自动化进行。</p>
<p>如果团队的自动化测试工作做得足够好，那你们应该更进一步考虑整合持续集成（Continuous Integration，简称CI）。这也是前文所说的使用 Git 的优势之一，它对于自动化测试和 CI 都是非常友好的。</p>
<p>至于使用哪种具体的 CI 构建工具，这里没有定论。反正宗旨就是：自动化程度要高、工具鲁棒性要好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下本文提倡的基本的 Web 开发工作流程：前后端制定 API 规范 –&gt; 前后端完全分离开发（使用框架、Git &amp; Code Review） –&gt; 进行自动化测试 –&gt; CI 整合。
 </p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Web 开发</tag>
        <tag>工作流程</tag>
      </tags>
  </entry>
  <entry>
    <title>学生心态与产品演进之路</title>
    <url>/2016/11/22/stay-hungry-stay-foolish/</url>
    <content><![CDATA[<p>对于工作稳定的开发者而言，我们每天大多数时间都是在做着我们熟悉的事情。一个又一个不同的业务丢过来，我们却基本上总是使用着我们早已熟悉的技术栈。很多技术先驱们提倡开发者要学会远离自己的 comfort zone，学习一些新的我们所不曾了解的东西。是的，一个没有更高技术追求的开发者很难长久的在技术这条路上走得长远，更是难以达到一定的技术高度。</p>
<p>选择了开发者这条职业之路，也就同时意味着这将是一条不断学习新知的道路。这篇文章将指出一个已经对自己常用的技术栈熟知的开发者，在学习新知的过程中可能会遇到的一个典型的问题。也许这个问题不仅仅是针对开发者，任何一个对自己常接触的业务领域技能熟知的职业人，在接触到新的知识领域时，都有可能会遇到这样的问题。</p>
<span id="more"></span>

<p>作为开发者，一个典型的场景就是我们需要在已有技术知识的基础上学习一些新的技术。你可能需要学习一个新框架如何使用、一个第三方服务的 API 如何合理的调用，更甚者，你可能得从后端开发转到前端开发、从移动端开发转到后端开发等等。在学习新东西的过程中，我发现我们极易犯一个心态上的错误——即不能正确的以一个小白的心态来学习新的知识。</p>
<p>这样说可能对开发者而言有失公允，实际情况可能是，我们会主动的使用我们已经掌握的知识作为参考和背景知识来辅助学习新的知识，这其实是一件很自然也很正确的事情。然而，不知道有没有人有这样的感觉，一个已经有一定使用某一框架开发经验的程序员，与一个毫无开发经验的毕业生，同时学习另一个新的框架来实现一个不算太有难度的业务，往往那个毕业生可以先交出成品。当然，这件事不尽然，但确实有这样的情况发生。表面上，似乎已有的开发经验成为了我们学习新知的负担，真的是这样吗？</p>
<p>造成这种现象的原因我觉得可能有以下几种：</p>
<p><strong>1. 可能你并没有真正打心底里认同这门新的技术。</strong></p>
<p>你可能一开始只是听别人说，有些好奇，于是尝试着去了解这门新的技术，然而发现它并没有你想像的那么好，很多指导思想十分陈旧，使用起来也不是那么的优雅。情况可能真的就如你想的那样，也许你已经掌握的技术确实比这门新技术设计上要先进一些，但我觉得另一种概率更大的可能是你还没有真正体会到这门新技术的精髓。它可能表面上看起来有一些蠢，和你已有的认知有一些出入，但你不妨再耐心一些，深入进去，多问一些为什么，了解这门技术这样设计的真正动因，当你真正开始认同这门新技术的时候，你可能就真正打开了另一个新世界的大门了。</p>
<p>我之所以说「你可能还没有真正了解新技术的精髓」这种情况的概率更大的原因是，我们在已有技术的基础上，往往能一眼分辨出比这种技术设计更丑陋的技术有哪些，却不能立马分辨出比这种技术设计更优秀的优秀之处在哪里，这是我们所掌握的编程思想所决定的。既然是能诱使你好奇去尝试学习使用的技术，我想一般应该是设计更先进的技术吧。</p>
<p>当然，你也可能完全是因为团队或上级要求，去学习一门新的技术，如果这门技术的确比你已经掌握的技术设计上更糟糕（或者技术社区中确实大部分人都这样认为），那确实挺难打心底里去认同的。这种情况我建议你好好准备准备，充分了解这门新技术比你掌握的技术差在哪里，然后跟团队的技术 Leader 好好谈谈，争取策反他吧。</p>
<p><strong>2. 你对自己的代码质量要求太高了。</strong></p>
<p>这种情况可能更普遍。对于大多数摆正心态的有经验的程序员而言，并不是他们没有认真学习新的知识，而往往是他们对自己的代码质量要求太高。</p>
<p>我们在已有的知识积累中沉淀出了一些做任何类型开发都需要了解的一些知识，并内化到了自己的知识体系中，比如一些软件工程的思想、一些常用的设计模式等，这些经典的思想限制着我们不愿意写出太烂的代码。我们总是想着我们的代码分层良好、复用程度高、易于后期维护、易于扩展、安全性更好等等，然而此时我们对具体的新技术的掌握还并不允许我们写出这个技术领域符合这些通用技术思想要求的代码。这种具体的技术可能是一门新的语言，你在对这种语言的语法都还不熟悉的情况下，是不可能写出高质量的代码的。然而犹如一张白纸的应届生是不会有这样的顾虑的，能够实现功能可能对他们就已经一种全新的尝试了，所以他们往往可能能更快的做出一个成形的东西来。</p>
<p>这可以说是一种「了解得更多的烦恼」，我们唯一能做的就是摆正心态，再脚踏实地一些，不要还没学会走路就企图要跑。新技术在你还没掌握之前对你而言它就是新的。如果你以前用你已经了解过的技术随随便便就能写出高质量的代码，那么在这个全新的领域里，我们还是得从一行行的烂代码开始积累起。</p>
<p>另外需要说明的是，原有的经验积累并不是毫无用处的，我们正是因为了解我们写出的新代码的缺陷可能在哪些地方，我们才能更加明确我们改进的方向。如果要比较谁能把工程代码写得（或改进得）更好，那我想应届生们是断然比不过有经验的老程序员们的。其次，一些其他的软技能，比如查找资料的能力、借助互联网解决问题的能力、对 Bug 可能原因的敏感度等等，这些也是宝贵经验带来的财富。</p>
<p>其实做产品也很容易犯这样类似的错误。</p>
<p>一些没有经验的产品经理或者做自己 Side Project 的程序员，往往一开始就把自己的产品构思得很好，并且企图第一版就把功能做得很完美。这样的想法能好，但是太不现实。「罗马不是一天建成的」，任何伟大的产品也是从一点一滴琐碎的改进中积累来的。一开始，它们可能很烂，性能差、页面分布不合理，甚至有明显的 Bug 等等，但经过不断的迭代与打磨，慢慢的它才会变得优秀、变得无可替代、变得不可或缺。尤其是在这样一个互联网浪潮下，任何的机会都经不起犹豫和等待，一个一开始就追求完美的产品，等不到出生，就已经死了。</p>
<p>说了这么多（甚至个人觉得好像有点儿鸡汤味儿……），其实总结起来也就还是乔布斯的那句话：</p>
<p><em>Stay hungry, stay foolish.</em></p>
<p>不仅仅是在行动上，更是在心态和产品设计理念上，用这句话来武装自己。保持学生心态，一点一滴脚踏实地的积累和迭代，才能调和出不一样的色彩。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>学生心态</tag>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title>从个人经历漫谈传统教育与编程</title>
    <url>/2016/11/27/traditional-edu-and-programming/</url>
    <content><![CDATA[<center>**1**</center>

<p>这一两年以来，我越来越避免在 Web 的公开领域（甚至在微信朋友圈）说一些有关个人经历的事情，即便有时候为了情境必须得说出一些关于自己的东西，也会在事后把它删除或隐藏。不是担心个人隐私什么的（或者只是很小的一部分原因，这个年代还有个人隐私可言吗？），而是在玩遍社交网络之后，我觉得没必要在虚假的网络说上太多个人相关的东西。真实的世界才是真实，对于网上的东西没必要过于认真，很多事情我们永远无法知道背后的真相到底是什么。</p>
<span id="more"></span>

<p>另外一个原因是，我不希望人们通过网络来认识自己，尤其是对于新认识的朋友。更多地，我还是希望相互的了解能尽量通过 one-on-one 的形式来进行，即便是不能线下有约，通过微信<strong>私</strong>聊也会更好。我们在朋友圈或者微博发的东西都是面向所有人的，在某个情境和上下文下，你在网上发表了一些东西，但我不希望人们在看到这些东西的时候会产生对这个人的「刻板印象」，因为那些东西不能代表一个人本身。</p>
<p>所以，在个人博客中我也是如此，都尽量写一些相对客观实在的谓之「干」的东西，能产生一些价值。但是这篇文章我想说说传统教育和编程，会扯上一些个人的经历来背书，内容很湿很不客观，诸位姑且一看。</p>
<center>**2**</center>

<p>我是在进入高中后开始接触编程的，那个时候有幸进入了全省最好的高中（至少是最好的四个之一吧）的理科实验班学习，每个同学都必须在数学、物理、化学、生物以及信息学这五大学科中选择一门作为自己的竞赛科目。基于初中的经验我本来是打算选择物理的，但听说信息学更容易出成绩，年少的我也对这门神秘的学科充满好奇。由于当时做决定的时间很紧张，于是我还没多想就懵懵懂懂的选择了信息学竞赛。这大概是我这辈子在最无知的情况下做出的最正确的决定，如果不是这个选择，我可能还跟很多在校大学生甚至已经毕业了很多年的毕业生一样，完全不知道自己想做什么，想从事什么样的事业，自己真正的兴趣在哪里。</p>
<p>这么多年回过头再去想，即便之后的种种决定都经过了慎重的考虑、广泛的参考，也做出了不少很浑的选择，这之中就包括大学和专业的选择。哈哈，人生有时候就是这么讽刺，上帝他老人家就是很喜欢跟无知的人类开玩笑——「人类一思考，上帝就发笑」。可见，人生很多时候还是需要依赖一些运气和感性的直觉，才不像那些鸡汤中所说的全靠个人的努力和理性的判断，「选择大于努力」，说的就是这样。当然，我现在还不能给每一个选择是对是错下定论，人生一世，谁说得准呢。我只是站在现在这个人生节点上回头望去，非常主观和极其不负责任的对这些选择「狂妄」地评判一番而已。</p>
<p>扯远了。在接触编程之后，我就像 11 岁的 Harry Potter 一样立马被这个「神奇的魔法世界」吸引了。那个时候我们学的是 Pascal 语言（如今这门语言基本只存在于信息学竞赛领域，而且大有被淘汰的趋势），经常解决一个算法问题花费一整天、一晚上而不自知，而且往往还自得其乐。在问题没解决时，它还会萦绕在你的心头，甚至可能在你吃饭时迸发出一些灵感。而在解决问题之后的巨大喜悦，更是让人陶醉。我大概是在编程之后才开始真正学会如何系统地有逻辑地去思考问题的。乔布斯<a href="https://movie.douban.com/subject/6974319/">就在访谈中说过</a>，他觉得每个人都应该学习编程，因为那会教会一个人思考问题的方式，exactly。</p>
<p>虽然高中生参加竞赛本来就是带着很功利的目的的（高考加分和保送政策），但那个时候我却在这件看似功利的事情中找到了真正的快乐。如果现在要来描述这种快乐的话，我推荐你去看看《人月神话》的第一章以及《黑客与画家》，如果没那么多时间也可以看看我的<a href="http://maples7.com/2016/09/20/pleasure-of-programming-media-easy-to-manipulate/">这篇文章</a>，不过我仅仅阐释了能够产生这种快乐的一个方面。</p>
<p>那个时候，比尔盖茨还没有退休，并且常年霸占着福布斯富豪榜头条，苹果和乔布斯在中国还没那么广泛的被人所知，绝大部分人还使用着质量杠杠的诺基亚。那个时候，我深刻的了解到世界上有那么一群人正是在用 IT 技术创造着一些奇妙的东西，他们不用枯燥的背着「之乎者也」「碳氮磷钾」、不用配着莫名其妙的化学方程式、不用算着复杂的二次曲线方程、不用去记可能一辈子用不到的英语单词。他们离我们那么近、那么远……</p>
<center>**3**</center>

<p>与创造和用编程解决具体问题的快乐比起来，高考下机械古板的学业压力就显得没那么「可爱」了。我在我身上发现了一个不大不小的规律，一旦我打心底里接受并认同了的事情，我可以把它做得非常好，甚至是强迫症般的追求完美，然而要是我是被迫着去做某些事情，即便我可以强迫着自己很努力，我也无法在潜意识里欺骗自己，而且其结果往往让所有人失望。这也是我<a href="http://maples7.com/about/">自称是「坚定的理想主义者」</a>的原因之一。</p>
<p>高一结束，因为其他学科被我落下很多，在老师和家长的联合「劝说」下，我极其不情愿地退出了信息学竞赛。那时候还中二的我问自己最多的问题是：为什么一定要高考呢？</p>
<p>之后便是枯燥的高中两年，然后是高考失利。然后是非常幼稚的选择大学和专业——说出来你可能不信，即便是经过了充分地考虑，我却没有在那个时候选择计算机专业，大概是高中后两年已经让我忘记了编程能带来的快乐了吧。然后开始憧憬大学生活，而进入大学之后我才被官僚、照本宣科以及本质上与高中无异依然是为了考试而学习的大学生涯感到彻底失望，还算幸运的是自己加入了某个校级组织的技术团队，才让我又重拾了一些创造的快乐。而在大学期间我也利用 MOOC 平台学习了很多计算机相关的课程，因为是真正喜欢编程，这些课程我都取得了不错的成绩，其中两三门还在下一次的开课中担任了助教。</p>
<p>关于大多数国内大学的转专业制度，我很想问这样一个问题：只有当成绩处于当前专业的前百分之十时才能够转到其他专业，既然我本来就对当前的专业不感兴趣，那为什么要先花费大量时间强迫自己应付考试直到排名至前百分之十才能转到其他专业呢？从兴趣驱动学习的角度来说，这难道不是一个本末倒置的逻辑吗？我现在能想到的原因就只能是，那些不进行一线教学工作的教务行政人员为了简化自己的工作而不得不用利用排名制定的门槛罢了。</p>
<p>从那时候开始，我学会了真正的自己为自己做决定，遵照自己内心最本真的声音，放下桎梏地去探索自己真正想要的东西，去创造属于自己的快乐。</p>
<center>**4**</center>

<p>关于大学，我并没有大多可说的东西，可笑和不那么让人愉快的事情还有很多，我开始认识到这个世界的真实和形色各异的人类。不过，为了能体现自己主观的态度，做到全文皆是「极其不客观的湿货」，引述一下别人的观点：</p>
<ul>
<li><a href="http://baike.baidu.com/view/2564858.htm">阮一峰</a>，上海财经大学世界经济学博士，目前在上海一所大学任教，同时在国内 Web 开发领域颇有名气，中文版《黑客与画家》就是他的译作。他在<a href="http://www.ruanyifeng.com/blog/2016/10/online_education.html">最近的一篇博文</a>中这样说：</li>
</ul>
<blockquote>
<p>当代的大学起源于欧洲修道院的模式。学生要经过多年的苦修，经过考核，才能毕业。如果想成为高级僧侣，就必须再多熬几年。另外，还有导师作为监督人，防止你学到歪门邪说。这种模式的两大弊端，演变到今天，已经越来越严重了：一个是传授的知识老化，另一个是极其浪费学生的时间。</p>
<p>什么知识才是有用的知识？农业社会，上一代人的知识可以一成不变地用在下一代。而在信息社会，前几年的知识，再过几年就不能用了。</p>
<p>这种情况下，大学应该教什么，我们根本不知道。学生毕业后的行业，现在根本还没有出现。因此，大学只能重点教基础类课程，但这样就会学到大量没用的东西。学生感叹，考试一结束，许多课程这辈子再没有用到的机会了。</p>
<p>更糟糕的是，学生的培养计划，都是一些二三十年前毕业、然后一直待在大学里、与社会生产实践脱节的人制定的。他们的知识和思维早已过时了。这样的人指定你应该学习的知识，很可能在你学的时候就已经没用了。</p>
<p>退一步说，就算你在大学里能学到真正的知识，也不应该在那里待四年。如果只学最需要学习的东西，一年就够了。四年时间足以让一个人在任何领域成为资深业者，甚至专家。可是我们的大学生呢，经过本科四年，不要说领域专家，甚至能力强的学生都寥寥无几。我们的大学制度用了四年时间，培养出了大量一无所长的、迷茫困惑的、市场滞销的年轻人。</p>
<p>18 岁是人生最有热情和精力投入一项事业的时候，但是，大学将你一连四年关在教室和图书馆里，把考试和绩点伪装成你奋斗的目标，人为将你与真实世界隔离，引导你去关注那些对未来人生毫不重要的事情。经过这样四年的歧途，等你真正走上社会、要跟全世界竞争的时候，你的竞争力不是变强了，而是变弱了。换句话说，四年制大学很可能是削弱你，而不是让你变得更强。</p>
<p>世界著名程序员 Jamie Zawinski 曾经解释，为什么他只读了一个学期的大学就退学：「进了大学以后，每天 8 点就要起床，开始训练记忆力。有一门课我早就会了，想申请免修。教务长说不行，你必须上，这是政策。见鬼，我为什么要自己付钱，来这种地方。我就退学了，从来没后悔过。」</p>
<p>我们时代的很多成功者—-乔布斯、比尔盖茨、扎克伯格等等—-都是退学生，这绝不是偶然的。不是他们在大学待不下去，而是他们发现，没必要在那个地方待四年。如果他们咬着牙忍受下去，熬到拿到文凭的那一天，苹果公司和微软公司可能都不会有了。</p>
<p>读大学，只是 18 岁时很多种选择中的一种，不是唯一的选择，更谈不上是最好的选择。校园是一个美丽的地方，但是如果一定要在里面待上四年，那还是算了吧。</p>
</blockquote>
<ul>
<li><a href="http://tchen.me/pages/aboutme.html">陈天</a>，北航软件工程毕业，企业家和全栈工程师，现居旧金山。他在 2014 年的一篇微信公众号（programmer_life）文章<a href="http://mp.weixin.qq.com/s/pIJYSOEeaeu6HTobFvg4sw">《谈谈大学》</a>中这样说：</li>
</ul>
<blockquote>
<p>很多课本我自学的效果要比听老师讲还好 —— 其实大部分时间，老师不是在讲，而是在板书。学过的好几门专业课中，老师板书的欲望比小男生们想妹纸的欲望还要强烈。</p>
<p>所以我逃课的概率越来越大，参加科协活动的时间越来越长。我喜欢和一群对技术有着挚爱的人聚在一起，哪怕他们在贬低我的 asp，抬高他们的 php，我也无所谓，只要不要让我听到粉笔敲击黑板的声音就成。</p>
</blockquote>
<blockquote>
<p><em>（另一段）</em> 比赛归来，我正式加入了实验室的 863 项目组，研究扯淡的虚拟企业信息集成。扯淡归扯淡，论文还是要发表滴。经历几次失败后，我摸索出发论文的技巧，成功以第一作者身份在核心期刊「计算机应用」（成都的，好像是这个名字）发了一篇文章。我默默地感觉在国内核心期刊上发表论文也不过如此 —— 精髓就几个字：「把简单问题复杂化」。比如说，一个你跟同学都能说得明白的算法肯定上不了台面，必须将其公式化，公式越复杂越好，最好看的人觉得「哇靠，屌爆了」，那你就成功了。当然，光有公式化的算法还不够，你还要有牛逼的定义，再辅以云里雾里的示意图。示意图和公式要一个德性，不是用来让人看懂的，而是让人看不懂 —— 别人越看不懂，你的逼格就越高。如法炮制，我又发表了两篇核心期刊。</p>
<p>之后再发表就没有意思了。整个学术界的迂腐让我震惊，大家都不得不跟吞了鸦片一样，在烟雾缭绕中极尽浪费生命之能来摧残自己的智商。</p>
</blockquote>
<p>在传统的世俗成败观上，这两人都可以说是在现行大学体制下颇为成功的人物，但他们依然发出了这样的声音。</p>
<p>引述他们的这些文字基本能够表达我主观的意思。传统教育尽管确实问题百出，但我觉得最让人感到绝望的一点还在于，十年前在用的教育制度和理念，十年后居然还是一层不变，看不到一点改观和生机。实在很难让人相信这是被誉为「象牙塔」的大学教育。</p>
<center>**5**</center>

<p>不过，客观地讲，我并不认为大学教育是完全不必要和一无是处的。大学的可取之处不在于它现行的教育体制和教育方式，而是它能够为刚结束高考步入成年社会的少年们搭建这样一个相对自由的平台和环境。在这样的环境中，你第一次开始有了比较充分的自主权，开始认识各种各样的人、经历各种各样事情，开始学会独立思考，开始懂得如何成为一个有血有肉有更高追求的高素质的人。随之而来的眼界的提升、视野的开阔、综合素养的培养等等，不必多说。当然，准确地说，这些好处是这样的客观环境所带来的，而不是现行大学制度主观培养出来的。也就是说，只要客观提供这样的平台和时间（比如四处游历，但我不确定），不一定非得在大学，一样可以得到这样的培养。</p>
<center>**6**</center>

<p>最后，为了避免有人随便看了一眼内容中的几个词就给我主观臆断的随意贴上「反智」的标签，我提前给出我的解释：我推崇纯粹而自由地学习各种各样自己感兴趣的知识，不分文理，不分学科，这些知识不一定非得是客观有用能立即产生价值的，但绝对不是绑定了太多功利目的或因为制度的缺陷和僵化而半被迫的去学的。底线的条件的是，它得是你真正感兴趣并自发的愿意去深入学习的。</p>
<p>编程就是这样一个我愿意自发的去探索的领域，但你的领域可能并不在这里。值得一提的是，随着近年互联网势头的火热，很多人抱着很功利的目的成为了程序员，但他的实际兴趣可能并不在此，工作也只是应付过去，当然也没有更高的技术追求和主动探索的动力。我并不看好这样的人，我只能真心的希望他们能早日听到内心的声音，发现真正的兴趣，早日打开新世界的大门。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>程序员</tag>
        <tag>教育</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员：请不要丢失你的敬畏心</title>
    <url>/2016/12/09/show-your-respect/</url>
    <content><![CDATA[<center>**暗**</center>

<p>或许是因为整天抓着代码里的 Bug 从而锻就了能敏锐发现世界缺憾的能力，抑或是这个世界本来就充满着污秽与糟粕，大多数技术人员都普遍缺乏敬畏之心。</p>
<p>他们习惯性的高高在上俯瞰着众生的琐碎，从不懂得尊重其他人的劳动和创作；<br>他们在自己狭窄可怜的 comfort zone 里游刃有余，认为自己了解到就是全世界，而剩下的全是垃圾；<br>他们自以为是的对待自己所遇到的一切事物，以为看一眼书名就能通晓书中的精华，瞥一眼标题就能知道全文在讲些什么，瞅一眼角色的长相就能知道是好人还是坏人；<br>……</p>
<span id="more"></span>

<p>他们局限在自己固若金汤的生活里，选择性的忽视着他们不擅长的世界的 B 面，一边自得其乐的吐槽着世界的种种不完善，一边心满意足的看着综艺刷着微博写着不思进取的代码。</p>
<p>他们的宗旨是，自己最聪明，别人的产品都充满问题。他们觉得，对于自己了解的部分自己说的都是对的，对于自己不了解的部分根本没有存在的必要，不屑于去了解。无知成为了他们的一种幸福。</p>
<p>这样的人，永远心安理得的停留在原地，嘲笑着汗流浃背奔跑的人。</p>
<p>其实，他们不仅仅是技术工作着，他们可能是我们每一个人。<br><br /></p>
<center>**明**</center>

<p>国人的劣根性也好，人性的自然缺憾也罢，就跟古时候「文人相轻」的现象一样，技术工作者往往也有同源的类似的问题。想想永远活跃于各大社交网络的编程语言之争、技术范式之争、工具链之争等等就不难发现，很多技术工作者都真情实意的认为自己研究的东西最重要、自己写出的代码赏心悦目，而往往对别人的工作和自己尚不了解的领域充满偏见。</p>
<p>诚然，大多数技术工作者确实有着严谨的逻辑思维、强悍的学习能力、不畏艰难的卓绝品质，但也许正是这些表象的或者是世俗眼中的刻板印象，浇灌了技术工作者心里的自我满足感。</p>
<p>最近在看《人类简史》，作者在第十四章中明确指出近代欧洲文明正是在认识到自身的无知之后，才开始对未知的世界进行探索，从而一跃成为世界文明的中心。一个典型的现象是最初欧洲人所测绘的地图事无巨细、没有空白，认为自己所认知的世界就已经是全世界，而他们在探索到新大陆发现了自身的无知之后，地图测绘上开始学会了留白，坦诚的面对自己所还未曾涉足的地域。而同时代的近代中国却固步自封、骄傲自大，之后的故事大家都耳熟能详了。</p>
<p>就像读书的三境界一样，关于认知也有四重境界：</p>
<ol>
<li>You don’t know that you don’t know</li>
<li>You know that you don’t know</li>
<li>You know that you know</li>
<li>You don’t know that you know</li>
</ol>
<p>大多数人都只是在第一重境界，但这之中却有不少人误以为自己在第三境界。放下自己认知上的自我满足感，不断去探求新知，才只是从第一境界过渡到第二境界而已。</p>
<p>果粉熟知的乔布斯关于 “connect the dots” 的论断也有异曲同工之妙，你永远也不会知道现在你所了解到的看似无用的新事物会不会在未来的某个时刻成为组成你的伟大的不可或缺的重要的一部分。</p>
<p>所以，程序员，请不要丢失你的敬畏心，这个世界你不了解的事情不胜枚举。用开放的心态拥抱自己不了解的领域，你会无意中打开更多新世界的大门。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>敬畏之心</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Node.js 正名的二三事</title>
    <url>/2016/12/15/awesome-node/</url>
    <content><![CDATA[<p>这篇文章的起因是《程序员》杂志上的这两天在前端界闹得沸沸扬扬的文章——<a href="http://geek.csdn.net/news/detail/128912">《2016 年前端技术观察》</a>，我在知乎上看到相关文章的时候大概已经是凌晨两点，看完后（准确说，前端我不大了解的部分没怎么细看）「精神抖擞」，当即在知乎写下了这个回答：<a href="https://www.zhihu.com/question/53625757/answer/135902282">如何评价真阿当的文章：《2016 年前端技术观察》？</a>。</p>
<p>前端不够了解就不多说什么的了，但我发现现在确实还有一些不搞 Node.js 的人像上文作者那样把 Node.js 当做「玩具」来看待，所以才想写下这篇文章。</p>
<span id="more"></span>

<p>我是在大一从 PHP 和 Python 入的 Web 后端的坑，当时在学校技术组织还基本是玩票的性质，等真正在工业实践中进行 Web 后端开发，则完全是从 Node.js 开始的（老实讲，我看到的工业实践中的代码还真不一定比在学校的技术组织的代码质量高）。期间也搞过 ASP.NET Core（C#），而且目前大多数时间还是在写 PHP。我之所以要说这些是因为，总是有人会说 Node.js 只是那些前端的人才玩的，说那些人没有后端思维什么的云云。我承认前端开发与后端开发考虑的问题确实很不一样，但如果你硬要认为前端的人来搞 Node.js 不能准确的对 Node.js 在后端开发的表现进行评估，那我可是一开始就真真切切的从一个后端的角度来看待 Node.js 的。</p>
<p>第一个需要为 Node.js 正名的是：Node.js 在目前主要还是后端的技术（至少肯定不是前端的技术）。尽管前端的同学常拿 NPM 来做包管理、用 Node.js 来写一些自动化脚本，也改变不了 Node.js 是为 Web 后端设计的本质。当然，现在 Node.js 跟很多主要用来做 Web 后端的语言一样，也可以来写 PC 端应用，但还不是主流。岗位划分上，很多公司把 Node.js 归类到前端组，这在一定程度上误导了初学者。 </p>
<p>从我在 PHP、Python、ASP.NET Core（C#）、Node.js 这些 Web 后端的体验来看，我非但没有觉得 Node.js 在后端开发上有什么明显的不足，反而觉得在很多方面比那些传统主流的 Web 后端技术要好上不少。下面来一一分析。</p>
<h2 id="不稳定？"><a href="#不稳定？" class="headerlink" title="不稳定？"></a>不稳定？</h2><p>这大概是我最常听到的对 Node.js 的质疑。当跟不熟悉 Node.js 的开发者讨论的时候，他们总是会质疑用 Node.js 写的应用是不是不稳定？能不能写大型应用？有哪些业界有名的公司在使用它？……然而如果问他们为什么说 Node.js 不够稳定时，他们开始变得支支吾吾，说自己不是主要搞 Node.js 的对此并不了解，只是听别人常这么说。</p>
<p>我不知道质疑 Node.js 是否稳定的疑虑是从哪里跑出来的（早期不成熟版本给人的印象？我不知道……），从我个人的开发经验来看，那些写过 Node.js（以下或简称为 Node） 还质疑其稳定性的人往往是因为自己对 Node 的理解不够深。比如经典的异步流程控制问题，在具体写代码时确实需要注意一些细节，但关键还是要理解 Node 异步的本质，这样才能轻松写出符合自己对它的行为期望的代码。但不能因为自己对语言最大的特点理解不够，写出了自己难以解释其行为的代码，就对别人说这门语言（或者说实现）不稳定吧。</p>
<p>如果你还是对 Node 的稳定性有疑虑，你知道 <a href="https://github.com/Unitech/pm2">PM2</a> 吧？那 <a href="https://github.com/foreverjs/forever">Forever</a> 呢？如果你依然不放心，那你还可以在 Node 应用外加一层反向代理，过滤掉网络世界里一些「肮脏」的信息。</p>
<h2 id="性能不够？"><a href="#性能不够？" class="headerlink" title="性能不够？"></a>性能不够？</h2><p>Node 当初就是以单线程异步非阻塞特性在高并发下的优良表现进入大家的视野的，加上 Google 的 V8 JavaScript 引擎，在性能上至少绝对不会成为其短板。虽然微软新推出的 ASP.NET Core 一度宣称<a href="https://blogs.msdn.microsoft.com/dotnet/2016/06/27/announcing-net-core-1-0/#user-content-net-core-usage">其性能是 Node.js 的 8 倍</a>，但脱离的具体的业务场景来谈性能完全就是耍流氓，这种测试与其说是技术上性能的对比，不如说是为了 marketing 的目的而制造的噱头。</p>
<p>进一步说，真实的业务场景中语言（或者说其实现和技术栈，以下同）几乎不可能真正成为性能瓶颈，带来的瓶颈的往往是 I&#x2F;O 部分。注意，这并不说语言对此没有责任，难以优化的 I&#x2F;O 性能瓶颈可能是因为开发人员由于语言特性写出了不易扩展和优化的代码，这往往是对性能产生更大影响也更有意义的方面，所以因此换语言也是有可能的（比如 <a href="https://www.quora.com/Why-did-Twitter-switch-to-a-Java-based-front-end-after-successfully-using-Ruby-on-Rails-with-200-million-users">Twitter 曾经从 Rails 换到 Scala</a>），但不是说语言本身的运行性能有什么太大的问题。</p>
<h2 id="第三方库的质量太差？"><a href="#第三方库的质量太差？" class="headerlink" title="第三方库的质量太差？"></a>第三方库的质量太差？</h2><p>我认为这非但不是 Node 技术生态圈的缺点，反而是其对比其他技术生态圈最大的优势。无非你遇到什么问题，无论你想找什么样的解决方案，在 2016 年接近尾声的今天，你都可以在社区找到灵感、吸收别人的养分、站在巨人的肩膀上。换句话说，你在社区提出一个问题，你可以快速且明显地感受到社区的热情。</p>
<p>截至目前，NPM 上已经有 385684 个 packages。而 GitHub 上 2016 年流行语言排名，JavaScript 更是<a href="https://octoverse.github.com/">超过第二名两倍还不止</a>（当然这之中前端 JS 的贡献也很大）：</p>
<p><img data-src="https://i.loli.net/2018/08/06/5b6730412457a.png" alt="15 most popular languages used on GitHub in 2016"></p>
<p>可以说，目前没有一个技术社区的社区活跃度比得上 Node&#x2F;JS 社区。</p>
<p>而至于质疑第三方包质量太差缺乏审核……诶，你是知道广电的电影审查制度的吧？</p>
<p>正是因为 NPM 使得发布一个包变得如此的简单，才极大的激发了开发者的热情。积木总是越搭才会越高的，需求也总是多种多样的，正是庞大的第三方包的基数使得开发者们有了更多的选择，优秀的第三方包也会在绝对数量上越来越多，从而可以实现更复杂更困难的业务需求。</p>
<h2 id="其他问题……"><a href="#其他问题……" class="headerlink" title="其他问题……"></a>其他问题……</h2><h3 id="自动化文档？参数验证？"><a href="#自动化文档？参数验证？" class="headerlink" title="自动化文档？参数验证？"></a>自动化文档？参数验证？</h3><p><a href="http://swagger.io/">Swagger</a> 不是针对某一门特定语言的（<a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger">ASP.NET Core 的官方文档就是推荐的 Swagger 作为文档系统</a>），也可以参考我的这篇文章：<a href="http://maples7.com/2016/09/06/build-doc-system-of-express-api-server-with-swagger/">使用 Swagger 构建 Express API Server 的文档系统</a>。</p>
<h3 id="Express-不够强大？不够标准？"><a href="#Express-不够强大？不够标准？" class="headerlink" title="Express 不够强大？不够标准？"></a><a href="http://expressjs.com/">Express</a> 不够强大？不够标准？</h3><p>Express 可以很好的让初学者了解一个常规的 Web 框架在底层是怎么处理问题的，甚至还可以阅读其源码了解其实现。但如果你还是因为不管什么原因不喜欢它，你还可以有各种各样的选择：<a href="http://nodeframework.com/">Hand-picked registry of Node.js frameworks</a>。这里我想着重提一下 <a href="http://feathersjs.com/">FeathersJS</a>，如果你觉得 Express 对于 HTTP(S) 或者 REST <strong>标准</strong>的支持不够专一和规范，你可以考虑看看这个框架，个人认为它在很多关键问题的处理上都有很规范的做法（拿 Express 跟它比可能对 Express 不大公平，它本身是基于 Express 的更高层次上的封装）。</p>
<h3 id="自动化测试？"><a href="#自动化测试？" class="headerlink" title="自动化测试？"></a>自动化测试？</h3><p>不必多说什么，mocha&#x2F;should(chai)&#x2F;supertest&#x2F;istanbul 基本已经成为共识，大不了再加个 rewire。而如果这样你还觉得麻烦，社区里已经有各种各样基于这些包的使用更方便的封装了，基本思路大概是像写配置一样写测试样例，然后写 Parser 把这些测例加载并解析再去自动化测试。</p>
<h3 id="……"><a href="#……" class="headerlink" title="……"></a>……</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实上述我说的这些问题早就有技术前辈们的布道和背书，我也不过是拾拾牙慧而已。技术人还是要多保持独立思考，与其道听途说，不如实实在在的自己去了解实践，亲身去感受，得出自己的结论。</p>
<p>哦，对了，<a href="https://www.zhihu.com/question/53625757/answer/135981220">我这篇文章也可能完全都是错的</a>。</p>
<p>:D<br>哦，对了，<a href="https://www.zhihu.com/question/53625757/answer/135981220">我这篇文章也可能完全都是错的</a>。</p>
<p>:D</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Web 开发</tag>
      </tags>
  </entry>
  <entry>
    <title>2016 年书单</title>
    <url>/2016/12/31/2016-booklist/</url>
    <content><![CDATA[<p>从今年开始，打算每年年终的时候总结这一年读过的书的书单，看看我能坚持多少年。不求看书数量上的多少，只求在每本看过的书中都能找到一些能内化成自己所能掌握的东西。这样做也是希望即便已经没有校园里大把的闲散时间读「野书」，也能不放弃这样的习惯。</p>
<p>今年是个人状态变化非常大的一年，走出校园，面向社会，经历了找工作、毕业季的纷扰、实习等等各个阶段，总是有些杂七杂八的事情要处理，看的书也不多。而且基本是初次正式的接触 JavaScript 和 Node.js，也接触了很多商业实践中正在使用的热门的应用类技术，需要学习的东西很多，所以看的技术类的书也会多一些。</p>
<span id="more"></span>

<p>以下书单基本按照今年读过时间顺序排列，每本书配有自己的打分和一两句话（链接大部分指向豆瓣的地址，给出版本和出版社等更多信息），这一两句话可能是对书内容的简要总结，也可能是自己的点评。</p>
<ol>
<li><p><a href="https://book.douban.com/subject/25862578/">解忧杂货铺</a>：★★★★<br>非典型东野圭吾式小说，故事设计精巧，叙述方式是小说的亮点。不过整篇下来感觉有点单薄，没有他巅峰时期写的小说看得过瘾。<br>像豆瓣上有人说的，这是东野圭吾写给成年人看的童话。</p>
</li>
<li><p><a href="https://book.douban.com/subject/20443559/">小王子</a>：★★★★☆<br>读正文之前一定得先读读李继宏写的导读，写得十分出色。<br>这本书一点都不长，任何大人初看起来都会觉得这是写给小孩子看的童话。但如果你不能用心来尊重这部作品，那就像书中所说，「大人是无法看懂的咯」。虽然表明上看是童话，但作者字字珠玑，无处不透露着生活的哲理和对人性的思考。<br>其次，作为诗人的作品，实在文笔简练优美、朴素纯净、充满诗意。<br>永葆童心，在你还能认真对待这本书的时候。<br>「大人们真奇怪。」<br>「真正的东西肉眼是无法看见的，要用心。」<br>我以后一定会给我的孩子读这本书的。</p>
</li>
<li><p><a href="https://book.douban.com/subject/20471120/">打造 Facebook</a>：★★★★<br>在我看来，这本书相当有价值，尤其是对于一线互联网工程师来说。<br>豆瓣的评论中有人说书名「打造 Facebook」写得太大，内容并不是真正教你如何「打造」一个 Facebook 的。我觉得有这样想法的人过于功利和浮躁。<br>实际上，作者已经把他在 Facebook 高速发展阶段的观察和经验，尤其是作为一个「潜在」创业者的角色和心态深入内部来仔细考察这个目前世界上最伟大的互联网公司之一的杰出经验，都写出来了。这些经验不仅有针对工程师（技术）的，也有针对管理者的。    </p>
</li>
<li><p><a href="https://book.douban.com/subject/10546125/">JavaScript 高级程序设计（第三版）</a>：★★★<br>所有与前端相关的部分我都没看，我觉得是一本明显在国内过誉了的 JS 入门书，不如犀牛书讲得透彻。</p>
</li>
<li><p><a href="https://book.douban.com/subject/3590768/">JavaScript 语言精粹</a>：★★★★<br>一本其他与 JavaScript 相关的书籍都会「恭维」一下的 JavaScript 书。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25767596/">了不起的 Node.js</a>：★★★★<br>非常好的 Node.js 实操入门！不过中文版错误有点多，版本有点老。</p>
</li>
<li><p><a href="https://book.douban.com/subject/24697636/">三重门</a>：★★<br>文字过于老成，思想过于中二。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25867920/">Node.js 实战</a>：★★★★<br>实战两字不虚。</p>
</li>
<li><p><a href="https://book.douban.com/subject/10789820/">Node.js 开发指南</a>：★★★★★<br>不如叫《Node.js 入门精粹》吧！</p>
</li>
<li><p><a href="https://book.douban.com/subject/26301434/">Node 与 Express 开发</a>：★★★<br>全、泛、广、浅、新，且翻译不畅，不过算个不错的技术栈索引。</p>
</li>
<li><p><a href="https://book.douban.com/subject/5313010/">Facebook 效应</a>：★★★★<br>Facebook 的人文社科历史进程。</p>
</li>
<li><p><a href="https://book.douban.com/subject/1024570/">编码的奥秘</a>：★★★★★<br>一本足以让国内数电、单片机教材汗颜的书，写了一些程序员必须了解的底层知识。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25891771/">失乐园</a>：★★★★<br>性、爱、死亡与人生。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25786138/">Effective JavaScript</a>：★★★★<br>给《JavaScript 语言精粹》做的完美补充。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26579320/">JavaScript 函数式编程</a>：★★★★<br>打开函数式编程新世界的大门。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25747921/">从你的全世界路过</a>：★★★<br>嗯哼。反正是过了看这种书的年纪了。</p>
</li>
<li><p><a href="https://book.douban.com/subject/1012611/">乌合之众：大众心理研究</a>：★★★★<br>一本百年前写的却依然对现实社会具有诸多指导意义的书。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26351021/">你不知道的 JavaScript（上卷）</a>：★★★★<br>不如叫《JavaScript 语言剖析》吧！<br>作者十分幽默，但是观点也不能全信，不信你可以敲一敲示例代码看看结果。</p>
</li>
<li><p><a href="https://read.douban.com/ebook/20769128/">北京折叠</a>：★★★★★<br>科幻中折射出了最真的现实。<br>一两个小时就可以看完，预计两年之内会被翻拍成电影。</p>
</li>
<li><p><a href="https://read.douban.com/ebook/23111860/">请发猫照片</a>：★★★<br>大概是想说人要对自己负责吧，可是真的没必要套上 AI 的外壳的。     </p>
</li>
<li><p><a href="https://book.douban.com/subject/25127404/">人间失格</a>：★★★★★<br>颓圮就像咖啡色儿的毒药，有一种致命的美。</p>
</li>
<li><p><a href="https://book.douban.com/subject/1102259/">人月神话</a>：★★★★<br>每一个优秀的产品经理或者策划都比程序员更应该好好看看这本书。     </p>
</li>
<li><p><a href="https://book.douban.com/subject/25768396/">深入浅出 Node.js</a>：★★★★★<br>中文出版界 Node.js 第一书！<br>觉得这书写得不好的只是因为自身 Node 的火候还不到而已，源码永远是一个软件最好的背书。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25962533/">神奇动物在哪里</a>：★★★★<br>罗琳是唯一能和魔法世界对话的人，她把她知道的故事讲给麻瓜听。<br>这是一本让麻瓜有魔法世界浸入式体验的神奇动物百科全书，邓布利多亲自作序，适合哈迷细细考究。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26854244/">你不知道的 JavaScript（中卷）</a>：★★★★☆<br>三年前 JavaScript 进阶你可能会推荐看《JavaScript 语言精粹》，但现在我推荐这个系列。<br>实际上中卷对《JavaScript 语言精粹》里的很多偏见做了更辩证更符合当下实践需求的深入阐述。<br>不过，书中观点依然还是要辩证看待，而且还有一些明显的小 bug，但基本不影响阅读。   </p>
</li>
<li><p><a href="https://book.douban.com/subject/26871656/">哈利·波特与被诅咒的孩子</a>：★★★☆<br>时空穿越本身带来的漏洞多得都不敢想，所以罗琳才会机智的在原著第五部中把所有的时间转换器给毁了。而这本书却刻意制造了这样一个 bug。<br>对不起，即便是情怀最多也就三星半。<br>当然，本书也不是一无是处，想看的话随便看看就好，别太当真，但一旦开始看了就坚持到最后，因为后面还是有一些看点的。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25826578/">MacTalk·人生元编程</a>：★★★★<br>一本高质量的博文汇编成的书，非常适合程序员入门 macOS。而且内容干湿比例匀称，更重要的是还有作者作为开发者一路走来的各种心得体会、人生经验，以及人文关怀。<br>可以买来作为睡前读物。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25985021/">人类简史</a>：★★★★☆<br>看完这本书我更加相信，人类从农业革命以来就构建了不正确的社会形态，奠定了阶级与剥削罪恶的源头。<br>看来只有传说中的共产主义社会能够拯救人类了&lt;滑稽脸&gt;。<br>但可悲的是，共产主义社会，也很可能只是我们想象出来的维持现有社会秩序的虚假故事罢了。是的，从农业革命开始，人类就已经不可能脱离想象来构建秩序。<br>第 6 章和第 16 章写得极好。       </p>
</li>
<li><p><a href="https://github.com/addyosmani/essential-js-design-patterns">Learning JavaScript Design Patterns</a>：★★★★<br>这本书的中文译本翻译得实在太烂了，我这么不挑剔的人看了前几十页实在看不下去了。译者态度显然有问题，比机翻的质量好不到哪里去。所以之后果断选择的阅读英文原版（链接给出的是这本书的 GitHub 地址，原版可以随时免费在网上阅读）。<br>反对一切原本适用于 OO 的模式硬往 JavaScript 身上套，但是有常用的设计模式理念和思想确实是有用的。</p>
</li>
</ol>
<p>另外，今年我还重温了一些日久弥新的经典著作，因为是「重温」，就不列举了。</p>
<p>看书不必刻意追求数量和速度（尤其对于技术类书籍），但事后这样一算，今年平均每个月大概是两本多新书，对于今年的状况来说，基本正常。 </p>
<p>实际上，读书也只是学习知识（甚至是消遣和打发时光）的一种方式，在这个时代，还有很多的方式可以选择。对于程序员来说，读一些优质的博客、看技术文档、逛技术论坛、听技术播客，甚至看 MOOC 都有机会可以学到很多东西，有些东西是拓展自己知识的广度（视野）的，有些则可能完全是干货。而一般来说，看电影、看剧、出去旅行都可以提升自己。我这样说的意思是，在这样一个开放多元的互联网时代，思想不要太保守，不必过于迷信一定要通过读书的方式充实自己，找到适合自己的方式就好。</p>
<p>至于是看纸质书还是电子书的争论，我个人的喜好是，技术类书籍有纸质书更好，没有的话电子版也能看下去（重点是边看边实践，旁边有笔电比纸质书更重要）。而对于非技术类书籍，除非是收藏的目的，否则我是不会带着厚厚的纸质书到处跑的。哦，对了，我用 iPad 看电子书，常用的 App 是多看和豆瓣阅读。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>Express 性能调优</title>
    <url>/2017/03/03/express-run-faster/</url>
    <content><![CDATA[<p>最近遇到了一个奇怪的事情，自己负责的一个项目的 RC（Release Condidate）版本突然在某一天打开时访问非常之慢，达到了完全不能接受的程度。奇怪的是，就在前一天，页面的访问速度至少是不会让人觉得不可接受的。更加奇怪的是，代码我完全没有改动过。</p>
<h2 id="NODE-ENV-x3D-production"><a href="#NODE-ENV-x3D-production" class="headerlink" title="NODE_ENV&#x3D;production"></a>NODE_ENV&#x3D;production</h2><p>在查找了一番资料之后，我在 <a href="http://expressjs.com/zh-cn/advanced/best-practice-performance.html">Express 官网上</a>发现了这样一段以前一直没有特别留意过的一段话：     </p>
<span id="more"></span>

<blockquote>
<p>NODE_ENV 环境变量指定运行应用程序的环境（通常是开发或者生产环境）。为了改进性能，最简单的方法是将 NODE_ENV 设置为“production”。     </p>
<p>将 NODE_ENV 设置为“production”会使 Express：</p>
<ul>
<li>高速缓存视图模板。</li>
<li>高速缓存从 CSS 扩展生成的 CSS 文件。</li>
<li>生成简短的错误消息。</li>
</ul>
<p>测试表明仅仅这样做就可以使应用程序性能提高 3 倍多！         </p>
</blockquote>
<p>遂顿悟！</p>
<p>事情是这样的，之前我们项目的 RC 版本都是使用的 production 作为环境变量，而且与正式发布的版本使用的是同样量级的数据大小，但最近我们项目有一个相对较大的版本更新，于是我为了配置一些特殊的变量供需求方能方便的检查效果和进一步评估改动，所以把 RC 版本所在服务器的 NODE_ENV 变量改成了其他值（为了适配另外的一套配置）。而测试环境下由于数据量非常小，所以根本察觉不到这个问题。</p>
<p>为了验证这个有文档说明来佐证的原因，我使用 ab（<a href="https://en.wikipedia.org/wiki/ApacheBench">ApacheBench</a>，一般用来做压力测试）进行了 A&#x2F;B 测试（<a href="https://en.wikipedia.org/wiki/A/B_testing">A&#x2F;B testing</a>，与前文的 ApacheBench 不是同一个概念）。</p>
<p>需要提前说明的是，为了尽可能排除网络环境的干扰，我是在内网环境下测试的，两次测试完全只有环境变量不同（也就是说里面的配置、所用的数据库、是否有缓存等都完全是一样的）。而且测试的是项目的一个主要接口，这个接口提供了页面的大部分数据，内部的业务逻辑也比较复杂，做的事情比较多。</p>
<p>测试结果如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># NODE_ENV=development</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">$ &gt;&gt; ab -c 10 -t 3 http://localhost:3000/XXXXX                                                     </span><br><span class="line"></span><br><span class="line">This is ApacheBench, Version 2.3 &lt;<span class="variable">$Revision</span>: 1706008 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking localhost (be patient)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:</span><br><span class="line">Server Hostname:        localhost</span><br><span class="line">Server Port:            3000</span><br><span class="line"></span><br><span class="line">Document Path:          XXXXX</span><br><span class="line">Document Length:        42477 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      10</span><br><span class="line">Time taken <span class="keyword">for</span> tests:   3.002 seconds</span><br><span class="line">Complete requests:      124</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      5467136 bytes</span><br><span class="line">HTML transferred:       5437056 bytes</span><br><span class="line">Requests per second:    41.31 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       242.097 [ms] (mean)</span><br><span class="line">Time per request:       24.210 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          1778.48 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.3      0       1</span><br><span class="line">Processing:   191  231  20.2    230     300</span><br><span class="line">Waiting:      191  230  20.0    229     296</span><br><span class="line">Total:        191  232  20.2    230     300</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    230</span><br><span class="line">  66%    234</span><br><span class="line">  75%    235</span><br><span class="line">  80%    238</span><br><span class="line">  90%    246</span><br><span class="line">  95%    285</span><br><span class="line">  98%    294</span><br><span class="line">  99%    298</span><br><span class="line"> 100%    300 (longest request)</span><br><span class="line">Finished 124 requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># NODE_ENV=production</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">$ &gt;&gt; ab -c 10 -t 3 http://localhost:3000/XXXXX                                                     </span><br><span class="line"></span><br><span class="line">This is ApacheBench, Version 2.3 &lt;<span class="variable">$Revision</span>: 1706008 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking localhost (be patient)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:</span><br><span class="line">Server Hostname:        localhost</span><br><span class="line">Server Port:            3000</span><br><span class="line"></span><br><span class="line">Document Path:          XXXXX</span><br><span class="line">Document Length:        42477 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      10</span><br><span class="line">Time taken <span class="keyword">for</span> tests:   3.006 seconds</span><br><span class="line">Complete requests:      209</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      8926808 bytes</span><br><span class="line">HTML transferred:       8877693 bytes</span><br><span class="line">Requests per second:    69.53 [<span class="comment">#/sec] (mean)</span></span><br><span class="line">Time per request:       143.828 [ms] (mean)</span><br><span class="line">Time per request:       14.383 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          2900.06 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.3      0       1</span><br><span class="line">Processing:   113  142  17.5    137     189</span><br><span class="line">Waiting:      112  141  17.5    137     188</span><br><span class="line">Total:        114  142  17.5    137     189</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  50%    137</span><br><span class="line">  66%    143</span><br><span class="line">  75%    156</span><br><span class="line">  80%    160</span><br><span class="line">  90%    168</span><br><span class="line">  95%    179</span><br><span class="line">  98%    183</span><br><span class="line">  99%    185</span><br><span class="line"> 100%    189 (longest request)</span><br><span class="line">Finished 209 requests</span><br></pre></td></tr></table></figure>

<p>可以看见，对比 QPS（或 RPS，Requests per second），<code>development:production = 41.31:69.53 [#/sec] (mean)</code>；对比平均用户请求等待时间（Time per request），<code>development:production = 242.097:143.828 [ms] (mean)</code>。基本上单个请求快了 100 ms 左右。</p>
<p>虽然没有官网上说的「3 倍」那么夸张，不过按文档上说还会「高速缓存视图模板」和「高速缓存从 CSS 扩展生成的 CSS 文件」，而我测试的是一个纯 API 接口，只返回 JSON 数据，所以理论上 HTML 页面打开的速度的对比应该会更加明显（之后也测试了这种情况，速度要快 1&#x2F;3 左右）。</p>
<h2 id="其他-Express-性能调优技巧"><a href="#其他-Express-性能调优技巧" class="headerlink" title="其他 Express 性能调优技巧"></a>其他 Express 性能调优技巧</h2><p>总结一下官网上所说的关于性能调优的基本还有以下几条：</p>
<ul>
<li><strong>使用 gzip 压缩响应</strong>：用 <a href="https://www.npmjs.com/package/compression">compression</a> 中间件；</li>
<li><strong>代码中不使用同步函数</strong>：项目启动时可以一次性使用同步函数进行一些有时序性的操作（比如加载路由），但在之后的长期运行过程中，具体对外的接口执行流程中不应该存在同步函数；</li>
<li><strong>正确进行日志记录</strong>：不要简单的用 <code>console</code>（都是同步函数）或自己写文件操作，直接用成熟的日志包（如 Winston、Bunyan、log4js 等），必要的情况下可能还需要使用消息队列；</li>
<li><strong>使用进程管理器</strong>：除了提高应用的可用性之外，还可以根据 CPU 核心数生成相应的应用实例，充分利用 Node.js 的优势压榨 CPU 的资源，常用的有 StrongLoop Process Manager、PM2、Forever；</li>
<li><strong>使用反向代理</strong>：直接用 Nginx 做反向代理吧，一方面可以做 CDN 缓存静态资源，另一方面还能够利用它做简单的负载均衡。不过需要注意的几点是：<ul>
<li>多实例下「粘性会话」需要把状态存储在第三方高速介质中，一般用 Redis 就好；或者，采用 JWT 鉴权方案实现接口无状态（更推荐，同时为了安全站点一定要强制使用 HTTPS）；</li>
<li>Nginx 做反向代理时不应该将其与应用放在同一台主机上，原因可以看这里：<a href="https://www.zhihu.com/question/19761434">Nginx 反向代理为什么可以提高网站性能？</a></li>
</ul>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://expressjs.com/zh-cn/advanced/best-practice-performance.html">生产环境最佳实践：性能和可靠性 - Express 官方文档</a></li>
<li><a href="https://www.zhihu.com/question/19761434">Nginx 反向代理为什么可以提高网站性能？</a></li>
</ul>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 慢查询优化</title>
    <url>/2017/03/08/mysql-run-faster/</url>
    <content><![CDATA[<p>在前一篇博客<a href="http://maples7.com/2017/03/03/express-run-faster/">《Express 性能调优》</a>中，我讲述了 Express 项目应该如何进行性能优化，但那些基本都只是官方文档上就已经明确指出的东西，也是对一个 Express 项目<strong>在性能上的基本要求</strong>。如果你已经足够仔细的阅读过文档，那么上一篇文章对你的收益几乎是 0。</p>
<p>除了规范所指出的基本要求，要优化一个 Web 项目的方法还有很多，比如合理的在后端给返回数据加缓存、充分利用浏览器的前端缓存、CDN，实在不行甚至需要「劳师动众」的部署多台机器做集群和负载均衡等等。这一篇博客的重点将放在数据库慢查询的优化上，这个话题对于 Web 项目而言更具有普适的意义。一方面它不局限于任何一种技术栈（当然这一篇以使用最普遍的 MySQL 为例），另一方面它更是直接在业务逻辑层面从代码本质上来优化你的项目性能，这往往也是单实例服务下性能的瓶颈所在。</p>
<span id="more"></span>

<p>实际上，这也是上一篇博客所讲的的同一个实践项目性能优化的深入。本来那个项目已经基本按文档规范进行了部署（<code>NODE_ENV</code> 的问题只是为了新版展示的临时修改），在那些方面能够对其进行优化的空间已经有限了，所以这个话题才是长期的项目维护实践中更有意义的部分。</p>
<h2 id="开启-MySQL-慢查询日志"><a href="#开启-MySQL-慢查询日志" class="headerlink" title="开启 MySQL 慢查询日志"></a>开启 MySQL 慢查询日志</h2><p>一个起步就不简单的原因是，我们如何才能定位到那些真正形成瓶颈的慢查询。一个普通项目中的 SQL 可能就有大几十甚至上百个，而「凶手们」就藏匿其中。</p>
<p>一个朴素的想法是在项目中每一个 SQL 执行前后打上时间戳来估计执行时间，暂且不论由于各种因素的影响这种估算可能不准确，更让人不可接受的是这对原始代码造成的极大的侵入。</p>
<p>好在 MySQL 提供了慢查询日志。这个日志会记录所有执行时间超过 <code>long_query_time</code>（默认是 10s）的 SQL 及相关的信息。</p>
<p>在 MySQL 的 Console 中：  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;long_query_time&#x27;</span>;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like <span class="string">&#x27;slow_query%&#x27;</span>;</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| Variable_name       | Value                                |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                  |</span><br><span class="line">| slow_query_log_file | /var/log/mysql/log-slow-queries.log  |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure>

<p>在这里，<code>slow_query_log</code> 指的是慢查询日志是否开启，<code>slow_query_log_file</code> 指明了日志所在的位置。</p>
<p>在 MySQL 的配置文件 my.cnf 的 <code>[mysqld]</code> 项下可以配置慢查询日志开启，一般来讲如下配置即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log=1</span><br><span class="line">slow_query_log_file=/var/log/mysql/log-slow-queries.log</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure>

<p>需要注意的是，应该赋予 <code>slow_query_log_file</code> 指向的目录 mysql 用户的写入权限：<code>chown mysql.mysql -R /var/log/mysql</code>，一般用默认的目录就好。详细的文档可以看这里：<a href="https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html">6.4.5 The Slow Query Log</a>。</p>
<p>之后需重载 MySQL 配置生效：<code>/etc/init.d/mysql reload</code>。</p>
<h2 id="分析慢查询日志"><a href="#分析慢查询日志" class="headerlink" title="分析慢查询日志"></a>分析慢查询日志</h2><p>在开启了 MySQL 慢查询日志一段时间之后，日志中就会把所有超过 <code>long_query_time</code> 的 SQL 记录下来。另一个有用的相关 MySQL 命令是 <code>mysqldumpslow</code>：由于慢查询日志可能很大或者很难分析，使用它可以获得 MySQL 对慢查询日志的一个总结报告，直接获得我们想要的统计分析后的结果。详细的文档可以看这里：<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldumpslow.html">5.6.8 mysqldumpslow — Summarize Slow Query Log Files</a>。</p>
<p>当然，你也可以打开日志文件自己来查询、分析。</p>
<h2 id="优化-SQL"><a href="#优化-SQL" class="headerlink" title="优化 SQL"></a>优化 SQL</h2><p>在得知哪些 SQL 是慢查询之后，我们就可以定位到具体的业务接口并针对性的进行优化了。</p>
<p>首先，你要看是否能在不改变现有业务逻辑的前提下改进查询的速度。一个典型的场景是，你需要查询数据库中是否存在符合某个条件的记录，返回一个布尔值来表示有或者没有，一般用于通知提醒。如果程序员在撰写接口时没把性能放在心上，那么他就有可能写出 <code>SELECT count(*) FROM tbl_xxx WHERE XXXX</code> 这样的查询，当数据量一大时（而且索引不恰当或没有索引）这个查询会相当之慢，但如果改成 <code>SELECT id FROM tbl_xxx WHERE XXXX LIMIT 1</code> 这样来查询，对速度的提升则是巨大的。这个例子并不是我凭空捏造的，最近在实际项目中我就看到了跟这个例子一模一样的场景。</p>
<p>能够找到上述的通过改变查询方式而又不改变业务逻辑的慢查询是幸运的，因为这些场景往往意味着只需重写 SQL 语句就能带来显著的性能提升，而且稍有经验的程序员在一开始就不会写出能够明显改良的查询语句。在绝大多数情况下，SQL 足够复杂而且难以做任何有价值的改动，这时就需要通过优化索引来提升效率了。</p>
<p>如何更好的创建数据库索引绝对是一门技术活，我也并不觉得简简单单就能厘得很清楚，很多时候还是得具体 SQL 具体分析，甚至多条 SQL 一起来分析。可以先读一读这篇美团点评技术团队的文章：<a href="http://tech.meituan.com/mysql-index.html">MySQL索引原理及慢查询优化</a>，更深入的了解则可以阅读<a href="https://book.douban.com/subject/23008813/">《高性能MySQL》</a>一书。引用一下美团点评技术团队文章中提到的几个原则：</p>
<blockquote>
<ol>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整；</li>
<li>&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式；</li>
<li>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)&#x2F;count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录；</li>
<li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’);</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
</ol>
</blockquote>
<p>常用的套路是在定位到慢查询语句之后，使用 <code>EXPLAIN</code> + <code>SQL</code> 来了解 MySQL 在执行这条数据时的一些细节，比如是否进行了优化、是否使用了索引等等。基于 <code>Explain</code> 的返回结果我们就可以根据 MySQL 的执行细节进一步分析是否应该优化搜索、怎样优化索引。</p>
<p>就在这几天，美团技术团队开源了一款用于分析如何优化 SQL 的工具——<a href="https://github.com/Meituan-Dianping/SQLAdvisor">SQLAdvisor</a>，有兴趣可以试试。</p>
<p>优化索引也并不是万能的，这种情况下只能考虑通过其他方式来缓和性能上的瓶颈了。</p>
<blockquote>
<p>查询容易，优化不易，且写且珍惜！</p>
</blockquote>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>译文 | 入门概念：CSS 选择器是如何工作的</title>
    <url>/2017/03/13/how-css-selectors-work/</url>
    <content><![CDATA[<blockquote>
<p>作者：<a href="https://twitter.com/chriscoyier">Chris Coyier</a><br>参考原文地址：<a href="https://css-tricks.com/how-css-selectors-work/">Beginner Concepts: How CSS Selectors Work</a>。</p>
</blockquote>
<p>你刚接触 CSS 吗？这篇文章就是为你准备的！也许理解 CSS 最关键的就是理解「选择器」。选择器可以让你定位到具体的 HTML 元素并且把样式应用于它们之上。不过现在让我们暂时忘掉「样式」，而只是专注于「选择」。</p>
<p>在接下来的例子中，CSS 将会存在于一个被命名为 <code>style.css</code> 的文件中，并且被叫做 <code>index.html</code> 的 HTML 文档所引用。HTML 与 CSS 是分离的，这样能将「设计」与「内容」分离，这也是 CSS 出彩的地方。</p>
<span id="more"></span>

<p>HTML 文件看起来会像是这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>We&#x27;re learning selectors!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;yay&quot;</span>&gt;</span>Yay<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 文件则只会包含选择器的代码区块，就像你接下来会看到的一样。</p>
<h2 id="ID-选择器（ID-Selector）"><a href="#ID-选择器（ID-Selector）" class="headerlink" title="ID 选择器（ID Selector）"></a>ID 选择器（ID Selector）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#happy-cake</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;happy-cake&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">id</span>=<span class="string">&quot;happy-cake&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sad-cake&quot;</span>&gt;</span>Wrong ID!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;happy-cake&quot;</span>&gt;</span>That&#x27;s not an ID!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>根据 <a href="https://css-tricks.com/specifics-on-css-specificity/">CSS 选择器优先级（CSS specificity）</a>，ID 选择器是优先级最高的选择器类型。这意味着它「打败」了其他的选择器类型和「以胜者姿态」而定义的样式。听起来很棒，但是那也是<a href="https://css-tricks.com/a-line-in-the-sand/">被诟病的地方</a>，因为在我们需要的时候，使用那些低优先级的选择器会更容易重载值。</p>
<h2 id="类选择器（Class-Selector）"><a href="#类选择器（Class-Selector）" class="headerlink" title="类选择器（Class Selector）"></a>类选择器（Class Selector）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.module</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;country module iceland&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;.module&quot;</span>&gt;</span>The dot is for CSS, not HTML<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bigmodule&quot;</span>&gt;</span>Wrong class<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>类选择器是你的朋友。它们很可能是这里最有用和最全能的选择器。其一，是因为它们在所有浏览器中都得到了很好的支持；其二，你还可以在 HTML 元素中添加多个「类」（class）（只需要用一个空格分开）；其三，你可以用 JavaScript 来明确地的操作类。</p>
<h2 id="元素选择器（Tag-Selector）"><a href="#元素选择器（Tag-Selector）" class="headerlink" title="元素选择器（Tag Selector）"></a>元素选择器（Tag Selector）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hi, Mom<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Anywhere<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;h2&quot;</span>&gt;</span>Wrong tag, can&#x27;t trick it<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line">&lt;h2class=&quot;yolo&quot;&gt;Make sure that tag has a space after it!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当改变某个独一无二的 HTML 元素的属性时，元素选择器是最有用的，比如在 <code>&lt;ul&gt;</code> 上设置 <code>list-style</code> 或是在 <code>&lt;pre&gt;</code> 上设置 <code>tab-size</code>。同理，在<a href="https://css-tricks.com/poll-results-what-css-reset-do-you-use/">重新设定</a>某个元素的浏览器默认样式时也很有用。</p>
<p>但不要太过于依赖它们。通常来说，写一个类来定义样式可以作用于任何 HTML 元素，这会更有用。</p>
<h2 id="属性选择器（Attribute-Selector）"><a href="#属性选择器（Attribute-Selector）" class="headerlink" title="属性选择器（Attribute Selector）"></a>属性选择器（Attribute Selector）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[data-modal=<span class="string">&quot;open&quot;</span>]</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-modal</span>=<span class="string">&quot;open&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&#x27;closed&#x27;</span> <span class="attr">data-modal</span>=<span class="string">&#x27;open&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-modal</span>=<span class="string">&quot;false&quot;</span>&gt;</span>Wrong value<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-modal</span>&gt;</span>No value<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-modal-open</span>&gt;</span>Wrong attribute<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可能会争论说<a href="https://css-tricks.com/attribute-selectors/">属性选择器</a>比类选择器更有用，因为它们有一样的优先级但是前者却可以是任何属性（不仅仅是 <code>class</code>），这个属性的值你还可以进行选择。</p>
<p>你说得没错，但是属性选择器 IE6 不支持。</p>
<h2 id="位置选择器（Positional-Selectors）"><a href="#位置选择器（Positional-Selectors）" class="headerlink" title="位置选择器（Positional Selectors）"></a>位置选择器（Positional Selectors）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>nope<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>yep, I&#x27;m #2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>nope<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了 <a href="https://css-tricks.com/how-nth-child-works/"><code>:nth-child</code></a>，还有几种不同的位置选择器。使用简单的表达式（比如 <code>3n</code>&#x3D;”every third”），你可以基于它们在 HTML 中的位置来选择元素。你可以<a href="https://css-tricks.com/examples/nth-child-tester/">在这里测试你的想法</a>或者<a href="https://css-tricks.com/useful-nth-child-recipies/">在这里了解更多的实例</a>。</p>
<h2 id="其他的伪选择器（Pseudo-Selectors）"><a href="#其他的伪选择器（Pseudo-Selectors）" class="headerlink" title="其他的伪选择器（Pseudo Selectors）"></a>其他的伪选择器（Pseudo Selectors）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:empty</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">data-blah</span>&gt;</span><span class="comment">&lt;!-- nothin&#x27; --&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>:empty</code> 是<a href="https://css-tricks.com/pseudo-class-selectors/">众多伪选择器</a>中的一个，你可以凭借冒号 <code>:</code> 来识别它们。它们通常代表着你不能仅仅通过元素和属性就能定位到的东西。</p>
<p>请注意，它们与用双冒号（<code>::</code>）来识别的<a href="http://css-tricks.com/pseudo-element-roundup/">伪元素（pseudo elements）</a>有一点不同。伪元素负责借助它们选择的内容来往页面添加东西。</p>
<h2 id="更多提升内容"><a href="#更多提升内容" class="headerlink" title="更多提升内容"></a>更多提升内容</h2><p>选择器可以被组合到一起使用。比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.module</span><span class="selector-class">.news</span> &#123;  </span><br><span class="line">  <span class="comment">/* Selects elements with BOTH of those classes */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#site-footer</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="comment">/* Adds content after an element with that ID */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span><span class="selector-attr">[data-open]</span> &#123;</span><br><span class="line">  <span class="comment">/* Selects only section elements if they have this attribute */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也有像 <code>~</code>、<code>+</code> 和 <code>&gt;</code> 这样的<a href="https://css-tricks.com/child-and-sibling-selectors/">选择器组合运算子（selector combinators）</a>可以用来对选择器造成影响，就像这样：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.module</span> &gt; <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="comment">/* Select h2 elements that are direct children of an element with that class */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">h2</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="comment">/* Select p elements that are directly following an h2 element */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span> ~ <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="comment">/* Select li elements that are siblings (and following) another li element. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 CSS-Tricks，这里有<a href="https://css-tricks.com/almanac/">一个完整的索引</a>，覆盖了 CSS 中的所有的选择器及其属性。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>译文 | 为什么面向对象很糟糕</title>
    <url>/2017/02/09/why-oo-sucks/</url>
    <content><![CDATA[<blockquote>
<p>作者简介：Joe Armstrong，编程语言 Erlang 之父。<br>参考原文地址：<a href="http://harmful.cat-v.org/software/OO_programming/why_oo_sucks">Why OO Sucks by Joe Armstrong</a>。</p>
</blockquote>
<p>当我第一次接触到面向对象编程的概念时，我是持怀疑态度的，可是我并不知道这是为什么——我就是觉得哪里不大对。在面向对象编程的概念面世后，它很快变得非常流行（稍后我会解释这是为什么），而对它的批评之声就像是「教堂里的誓言」（译注：形容微不足道）。面向对象的特性变成了每个受人尊敬的编程语言都不得不拥有的东西。</p>
<p>在 Erlang 变得越来越流行的过程中，我们经常被人问：Erlang 是面向对象的吗？好吧，尽管正确的答案是「不，当然不是」，但我们并没有当面大声的说出来。我们发明了一系列独创的方式来回答这个问题，以便给人 Erlang 是（有几分）支持面向对象但又不真的是的印象。</p>
<span id="more"></span>

<p>此刻我想起了在巴黎第七届 IEEE 逻辑编程大会上， IBM （法国）的老板在演讲中向听众强调的事情。IBM 的 prolog 已经被加入了很多面向对象的扩展，当问起为什么时他回答说：</p>
<blockquote>
<p>我们的顾客想要面向对象的 prolog，所以我们创造了面向对象的 prolog。</p>
</blockquote>
<p>我始终记得如此简单的回答，没有良心不安，也没有灵魂拷问，更没有问一句：面向对象真的是正确的做法吗？</p>
<h2 id="为什么面向对象很糟糕"><a href="#为什么面向对象很糟糕" class="headerlink" title="为什么面向对象很糟糕"></a>为什么面向对象很糟糕</h2><p>对于面向对象，我主要的反对点要落实在相关的基础概念上，我将会列出这些概念和我反对的理由。</p>
<h3 id="反对点-1：数据结构和函数不应该被绑定在一起"><a href="#反对点-1：数据结构和函数不应该被绑定在一起" class="headerlink" title="反对点 1：数据结构和函数不应该被绑定在一起"></a>反对点 1：数据结构和函数不应该被绑定在一起</h3><p>对象在不可分割的微小单元里把函数和数据结构绑定在一起。我认为这是一个根本的错误，因为函数和数据结构完全属于不同的世界。为什么呢？</p>
<p>函数用来做事情，它们有输入和输出。输入和输出是数据结构，并且被函数所改动。在大部分编程语言里，函数由一系列指令组成：先做这个然后去做那个事情。为了理解函数，你必须理解事情被完成的顺序（在惰性函数式编程语言和逻辑语言里，这个限制没那么严格）。</p>
<p>数据结构就是数据结构，它们不做事情。它们本质上是声明式的。理解一个数据结构比理解一个函数要简单得多。</p>
<p>函数被视为转换输入成输出的黑匣子。如果我理解了输入和输出我就理解了这个函数，但这并不意味着我已经能够写出这个函数了。</p>
<p>函数通常通过观察来理解，它们是计算系统中的一部分，这个系统的工作就是把类型为 T1 的数据结构转换为类型为 T2 的数据结构。</p>
<p>因为函数和数据结构是完全不同的东西，所以把它们硬绑定在一起在根本上就是错误的。</p>
<h3 id="反对点-2：万物皆对象"><a href="#反对点-2：万物皆对象" class="headerlink" title="反对点 2：万物皆对象"></a>反对点 2：万物皆对象</h3><p>我们来考虑一下「时间」。在一门面向对象的语言里，「时间」必须是一个对象。但是在一个非面向对象的语言里，「时间」是一种数据类型的实例。例如，在 Erlang 里，有许多不同种类的时间，它们能够用类型声明来清清楚楚的定义出来，就像下面这样：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">-deftype day<span class="params">()</span> = 1..<span class="number">31</span>.</span><br><span class="line">-deftype month<span class="params">()</span> = 1..<span class="number">12</span>.</span><br><span class="line">-deftype year<span class="params">()</span> = int<span class="params">()</span>.</span><br><span class="line">-deftype hour<span class="params">()</span> = 1..<span class="number">24</span>.</span><br><span class="line">-deftype minute<span class="params">()</span> = 1..<span class="number">60</span>.</span><br><span class="line">-deftype second<span class="params">()</span> = 1..<span class="number">60</span>.</span><br><span class="line">-deftype abstime<span class="params">()</span> = &#123;abstime, year<span class="params">()</span>, month<span class="params">()</span>, day<span class="params">()</span>, hour<span class="params">()</span>, min<span class="params">()</span>, sec<span class="params">()</span>&#125;.</span><br><span class="line">-deftype hms<span class="params">()</span> = &#123;hms, hour<span class="params">()</span>, min<span class="params">()</span>, sec<span class="params">()</span>&#125;.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>注意这些定义不属于任何特定的对象。它们无处不在，并且用数据结构来表示的时间能够被系统中的任何函数操作。</p>
<p>这里没有与之相关联的那些方法。</p>
<h3 id="反对点-3：在一门面向对象的编程语言里，数据类型定义散落在各个地方"><a href="#反对点-3：在一门面向对象的编程语言里，数据类型定义散落在各个地方" class="headerlink" title="反对点 3：在一门面向对象的编程语言里，数据类型定义散落在各个地方"></a>反对点 3：在一门面向对象的编程语言里，数据类型定义散落在各个地方</h3><p>在一门面向对象的编程语言里，数据类型定义属于对象。所以我不能在某个地方找到所有的数据类型定义。在 Erlang 或者 C 里，我可以在一个简单的 include 文件或者数据字典里定义我的所有的数据类型。在面向对象语言里我不能这样做，数据类型定义散落在各个地方。</p>
<p>我来举个例子。假设我要定义一种无处不在的数据结构。「无处不在」指的是在系统的各个地方都有可能出现。</p>
<p>Lisp 程序员可能早已知道，相比于大量的数据类型和一小撮作用于它们的函数来说，定义一小部分无处不在的数据类型和大量作用于它们的函数会更好。</p>
<p>一种无处不在的数据结构是那种类似于链表、数组、哈希表或者时间、数据或文件名这样更高级的对象的东西。</p>
<p>在面向对象编程语言里，我不得不选择某个基础的对象去定义普遍存在的数据结构，所有其他想要使用这些数据结构的对象都必须继承这个基础对象。假设我现在想要创造某个「时间」对象，它应该属于哪里呢……</p>
<h3 id="反对点-4：对象有私有状态"><a href="#反对点-4：对象有私有状态" class="headerlink" title="反对点 4：对象有私有状态"></a>反对点 4：对象有私有状态</h3><p>状态是万恶之源。在特定的有副作用的函数里应该被避免。</p>
<p>虽然编程语言中的状态可以是不可获得的，但现实世界里的状态却十分之多。我对我银行账户的状态十分感兴趣，并且当我从中存入和取出一些钱的时候，我也希望我的银行账户的状态能够被正确地更新。</p>
<p>提出一个问题：在现实世界里存在的状态，一门编程语言应该提供什么工具来处理它们呢？</p>
<ul>
<li>面向对象编程语言说：从程序员那里隐藏这些状态。这些状态被隐藏并且只能通过特定的访问函数来获得。</li>
<li>传统的编程语言（比如 C，Pascal）说：状态变量的可见性由语言的作用域规则来控制。</li>
<li>纯粹的声明式语言说：这里没有状态一说。</li>
</ul>
<p>系统的全局状态从各个函数中进进出出。像单体结构（对于函数式编程语言）和分布式结构（对于逻辑语言）这样的机制被用来从程序员手中隐藏状态，这样他们就可以像「状态似乎不重要」一样来编程。不过，拥有对系统状态的全部访问权限是必要的。</p>
<p>面向对象编程语言选择「从程序员手中隐藏状态」是十分糟糕的选择。它们不但不展现状态和找到减少令人讨厌的状态的方法，反而把它们都藏了起来。</p>
<h2 id="为什么面向对象如此流行？"><a href="#为什么面向对象如此流行？" class="headerlink" title="为什么面向对象如此流行？"></a>为什么面向对象如此流行？</h2><ul>
<li>理由一：它被认为是容易学习的</li>
<li>理由二：它被认为可以使代码更易复用</li>
<li>理由三：是炒作</li>
<li>理由四：它创造了一个新的软件产业</li>
</ul>
<p>我没有明白理由一和理由二为什么成立。理由三和四似乎是技术背后的驱动力量。如果一门语言技术是如此糟糕但是它却创造了一个新的产业来解决它自己产生的问题，那对于很多想赚钱的人来说一定是个好主意。</p>
<p>这就是面向对象背后真正的驱动力量。</p>
<blockquote>
<p>译注：文章观点仅供参考，作者本人后来也说自己的观点或许有些不成熟。</p>
</blockquote>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>Erlang</tag>
      </tags>
  </entry>
  <entry>
    <title>印象青岛</title>
    <url>/2017/03/14/qingdao/</url>
    <content><![CDATA[<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b673241202ea.jpg" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b6732410961d.jpg" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b6732411fb6a.jpg" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b673241122ee.jpg" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b67324124390.jpg" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b673241310f1.jpg" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b67324137461.jpg" /></div></div></div>

<span id="more"></span>

<br />

<p>图片已经过裁剪与压缩，原图在这里：<a href="https://maples7.tuchong.com/12595727/">https://maples7.tuchong.com/12595727/</a></p>
]]></content>
      <categories>
        <category>视觉动物</category>
      </categories>
      <tags>
        <tag>Sony DSC-RX100</tag>
        <tag>城市</tag>
        <tag>风光</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业一周年 | 山大印象</title>
    <url>/2017/05/07/grad-anniversary/</url>
    <content><![CDATA[<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b6730d2d2f42.jpg" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b6730d352fa4.jpg" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b6730d370941.jpg" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b6730d33957c.jpg" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b6730d363eec.jpg" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2018/08/06/5b6730d371069.jpg" /></div></div></div>

<span id="more"></span>

<br />

<p>图片已经过裁剪与压缩，原图在这里：<a href="https://maples7.tuchong.com/13114728/">https://maples7.tuchong.com/13114728/</a></p>
]]></content>
      <categories>
        <category>视觉动物</category>
      </categories>
      <tags>
        <tag>Sony DSC-RX100</tag>
        <tag>山东大学</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存可以用来做些什么</title>
    <url>/2016/10/08/what-can-cache-do/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p><em>There are only two hard things in Computer Science: cache invalidation and naming things.</em><br>—— <strong>Phil Karlton</strong></p>

</blockquote>
<p>缓存是高性能 Web 服务的基本要求，然而对缓存的处理和使用不当将带来一系列的副作用，尤其是同时考虑到服务的高可用性和同步的问题时。</p>
<p>本文将简单探讨 Web 服务中哪些功能适合用缓存（此文均指 Web 后端自行实现的缓存，如使用 Redis）来完成。</p>
<span id="more"></span>

<h2 id="提高性能"><a href="#提高性能" class="headerlink" title="提高性能"></a>提高性能</h2><p>提高服务的性能是缓存最原始的目的，对于数据库中查询频繁而改动不频繁的数据都可以使用缓存以提高服务的性能，这往往是低成本大幅度提高服务性能的手段之一，收效也会非常明显。</p>
<p>对于一个 Web 服务而言，缓存可以从不同的层级高度来展开：</p>
<ul>
<li><strong>路由层级的</strong>：如果是前后端不分离的 Web 服务，可以直接把某个路由下的静态页面缓存（比如未登录情况下具有高访问量的主页，并且不经常被更改时）；如果是前后端分离的 API Server，则是从 API 层级进行的缓存，此时需要注意缓存的 key 一定需要涵盖所有会控制 API 输出的参数。</li>
<li><strong>单个数据库查询层级的</strong>：我们可以把缓存细化到某个数据库查询操作后的数据返回，这样缓存的数据将更细化和可控，缓存的 key 也可以直接对应 SQL 语句中某些关键的参数。此时需要注意的是，被缓存的数据在其他路由或 API 下被更改时，需要即刻删除（对于一般具有实时性要求的服务，否则可以把过期时间设短一些），这样设置缓存操作和删除缓存操作往往分离在不同的路由或 API 中，需要良好的机制来进行一致性的管理和维护。</li>
<li><strong>数据库单条记录层级的</strong>：层级再向下，我们甚至可以从数据库中的单条记录为单位进行缓存。此时缓存数据库实际已经变成了总的持久性数据库的一个子集。这种情况下其实可以把缓存操作从应用层开发隐藏，直接在 ORM 中进行完整闭合的操作，也就是说，应用层无需再关心数据是从缓存来的还是从持久性数据库来的，ORM 在持久性数据库的基础上自行维护好的缓存，这将极大的降低应用层开发的缓存维护工作，同时也可以在一定程度上提高性能。不过相应的，应用层也失去了对缓存的控制力。</li>
</ul>
<p>在一个应用中，可以混合不同层级高度的缓存，以达到服务性能和开发维护成本之间的平衡。</p>
<h2 id="优雅实现指定间隔时间后的内容更新"><a href="#优雅实现指定间隔时间后的内容更新" class="headerlink" title="优雅实现指定间隔时间后的内容更新"></a>优雅实现指定间隔时间后的内容更新</h2><p>一个典型的场景是新浪微博的热门话题：每隔十分钟更新一次，而且访问量极高，此时我们可以把该数据完全用缓存来存储，并且把过期时间设置为十分钟，这样每十分钟缓存失效后，自动从数据库获取（组装）新的热门话题数据并存入缓存，在下一个十分钟内，所有的对热门话题的访问都是直接从缓存中拉取数据的。这样利用过期时间的合理设置来实现完全服务业务需求的功能，连手动删除缓存都免了。</p>
<p>当然，这样的业务需求可遇不可求，遇到一次就要好好把握充分利用。</p>
<h2 id="作为定时器"><a href="#作为定时器" class="headerlink" title="作为定时器"></a>作为定时器</h2><p>相比上一点的业务需求，定时器的需求要常见得多，比如每天定时进行数据同步、日志导出等等，都需要用到定时任务。从 Node 生态来看，实现定时任务的方式很多，最常见的莫过于使用社区提供的<a href="https://github.com/kelektiv/node-cron">cron库</a>。我不知道 cron 库是如何来实现定时任务的，这里仅探讨定时任务的缓存实现。</p>
<p>用缓存实现定时任务其实很简单，本质上跟在程序中设置一个 flag 的思想是一致的，当 flag 的状态翻转时，相当于触发了一个事件，此时响应这个事件来执行一些任务。不同的是，程序中的 flag 是没有过期时间的，它只能在一些特定情形下或者另一些事件后改变状态。而利用缓存的过期时间，我们就可以完成一些定时任务了。</p>
<p>具体来说，我们在缓存中设置一个 flag，并且把过期事件设置为我们需要的定时时间，然后视具体业务对定时的容错情况不断来访问缓存中的这个 flag（为了不阻塞主线程，可能需要多线程支持），当该 flag 不存在后，便执行所需的任务。这样就用缓存实现了定时任务。</p>
<h2 id="node-redis-cache"><a href="#node-redis-cache" class="headerlink" title="node-redis-cache"></a>node-redis-cache</h2><p>在用 Express 开发 API Server 时，没有在 Github 和 NPM 上找到满意的缓存库，于是想自己来重复造轮子了。</p>
<p><a href="https://github.com/Maples7/node-redis-cache">node-redis-cache</a>是我建立并想持续维护的一个缓存库，目前基于<a href="https://github.com/luin/ioredis">ioredis</a>并且被设计成单个数据库查询层级，已经实现了一些常用的兼容原生 Redis 接口的 API，具体使用时只需要在对应的数据库查询外面包裹（wrap）一层即可。</p>
<p>欢迎加入并共同完善！</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>缓存</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa2 源码赏析</title>
    <url>/2017/04/09/koa2-src/</url>
    <content><![CDATA[<p>随着 Node 新版本开始支持 async&#x2F;await 异步控制写法，Koa 也相继发布了它的 2.0 版本。用 async&#x2F;await 写法的 Koa 来开发项目，Node 开发者再也没有任何理由不「拥抱变化」——从 Express 转到 Koa 上来。实际上，对于普通 Node 开发者——Express 框架的用户——而言，从 Express 转到 Koa 没有任何技术壁垒，当然前提是你至少得知道 ES2017 中 async&#x2F;await 是个什么东西。</p>
<img data-src="https://i.loli.net/2018/08/06/5b6731c4b534a.png" class="" title="Koa——next generation web framework for node.js" alt="图片显示错误">

<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有了 Express 的积累，以 <a href="https://github.com/tj">TJ</a> 为首的 Express 开发团队对于 Koa 的设计也更加的得心应手、游刃有余。从源代码来看，Koa 看起来甚至比 Express 更加简洁和灵活，然而在功能上却丝毫没有让步，甚至更胜一筹。一方面，这得益于 JavaScript 越来越方便好用的各种「语法糖」；另一方面，也在于 Koa 本身简洁强大的设计：它不再绑定任何特定的中间件，也去掉了其他任何多余的设计（连路由系统都抽象成了第三方中间件），而只是简单的提供了一个优雅管理各种中间件的约束系统，用户的所有挂载都是中间件。</p>
<p>TJ 大神的代码一向简洁强大，Koa 的源码也是如此。如果你<a href="https://github.com/koajs/koa">去 GitHub 上查看 Koa 的源码</a>，你同样会被其简洁所震撼，核心代码不过 4 个文件，平均每个文件代码行数也就四百来行，看似简简单单，却天才般的把 Express 线性的中间件控制流转变为「洋葱体」结构，从而解锁了更多的姿势和玩法。本文就直接深入 Koa 的源码（v2.2.0），来欣赏 Koa 的曼妙身姿。</p>
<h2 id="代码大体结构"><a href="#代码大体结构" class="headerlink" title="代码大体结构"></a>代码大体结构</h2><p>lib 目录下总共就四个文件：<code>application.js</code>、<code>context.js</code>、<code>request.js</code> 和 <code>response.js</code>。入口文件是 <code>application.js</code>，导出的是一个继承了 Node 内建模块 Events 的 Class，构造函数中进行了必要的参数初始化，并且把 <code>context</code>、<code>request</code> 和 <code>response</code> 属性指向了原型链指向其他三个文件导出对象的实例。</p>
<p>然后是类方法，主要的几个 public 的方法如下：</p>
<ul>
<li><code>listen</code>：一个简单的对 <code>http.createServer(this.callback()).listen(...)</code> 的封装。</li>
<li><code>callback</code>：在 <code>listen</code> 中有调用，返回一个用于 <code>http.createServer</code> 的回调函数 <code>handleRequest</code>，在这个函数中创建了主角 <code>ctx</code>，并做了一些原型链继承和 aliases。<strong>更重要的是</strong>，<a href="https://github.com/koajs/compose/blob/master/index.js">调用的 <code>koa-compose</code> 返回了一个 <code>fn</code> 函数，负责了整个中间件「洋葱体」流程的实现和控制</a>。在所有中间件执行完之后，做了一些返回之前的琐碎诸如设置必要的返回头等的工作。</li>
<li><code>use</code>：把中间件参数放入 <code>this.middleware</code> 数组，并返回 <code>this</code> 以便链式调用。</li>
</ul>
<p>结合 Koa 文档和 <code>application.js</code>，基本就可以对整个框架的处理流程有个整体的把握了。其中最主要的部分还是 <code>callback</code> 函数中的内容，看完之后对整个基于 Node HTTP 模块封装的中间件处理的流转过程都清楚了。</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>这里是对 <code>this.context</code> 的原型对象的实现。</p>
<p>没有太多值得一提的东西，基本是对上下文对象 <code>ctx</code> 提供几个必需的原型接口以及一个缺省的错误处理函数 <code>onerror</code>。有意思的是，利用 <code>delegates</code> 包，把对 app 的一些属性的访问直接对应的代理到 <code>response</code> 和 <code>request</code> 上，这也就是<a href="http://koajs.com/#request-aliases">文档上所说的 <code>Request aliases</code> 和 <code>Response aliases</code> 的具体原因</a>。</p>
<h2 id="Request-amp-Response"><a href="#Request-amp-Response" class="headerlink" title="Request &amp; Response"></a>Request &amp; Response</h2><p>这俩文件是对 <code>this.request</code> 和 <code>this.response</code> 的原型对象的实现。</p>
<p><code>this.request</code> 和 <code>this.response</code> 中都有大量属性的 getter 和 setter 方法，这些可用的属性在 Koa 文档中都已经列出，代码在这里对它们的读写操作进行了实现。这些属性基本是对 Node HTTP 包中 req 和 res 属性的封装。</p>
<h2 id="「洋葱体」带来了什么"><a href="#「洋葱体」带来了什么" class="headerlink" title="「洋葱体」带来了什么"></a>「洋葱体」带来了什么</h2><p>你固然还是可以像在 Express 中一样把 <code>next();</code> 都放在每个中间件的末尾来线性的传递控制权，但「回形针」式的控制流带来了更多的可能。一个最典型的的例子就是 <code>response-time</code> 中间件的实现。</p>
<p>在 GitHub 上用 <code>response-time</code> 关键字搜索，前两个 Repo 就分别是 Express 和 Koa 中对这个中间件的实现。</p>
<p>Express 中的实现其实是 hack 了被 Express 用到的 Node.js 内部 HTTP 模块的 <code>res.writeHead</code> 方法（实际实现细节在 <code>response-time</code> 中间件调用的 <code>on-headers</code> 包中），使得在这一层注入了一小段代码用于在数据返回前计算时间差并写入 Response Headers。这样虽然可以实现，但显然不够好。它 hack 了框架底层的一个内部方法，虽然也巧妙，但代码本身并不是在给它天生就安排好的合适的地方来实现的，可以视为晦涩的「奇技淫巧」，而且与 Express 的内部实现强耦合，指不定哪天 Express 改了 <code>res.writeHead</code> 调用时机，这个中间件的返回值可能就有所不同了（当然按实际情况来说 Express 此处应该也不会改了，而且 Express 的 <code>response-time</code> 最初也是 TJ 写的）。</p>
<p>Koa 的 <code>response-time</code> 实现自不必多说，官方文档上就有，来欣赏它的简洁优雅：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="keyword">new</span> <span class="title class_">Date</span>() - start;</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&#x27;X-Response-Time&#x27;</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>总结来说，Koa 的「洋葱体」结构使得<strong>每个中间件能够在同一次请求的前后对称的部分提供相同的上下文环境</strong>，这样就让实现像 <code>response-time</code> 这样的中间件变得相当简单。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/26063036">编写可维护代码之“中间件模式”</a></li>
</ul>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>程序与人生</title>
    <url>/2017/05/24/programming-and-life/</url>
    <content><![CDATA[<p>最近趁着离职的一点空隙，稍微能有些时间和心情来思考一些更有深度和更长远的问题，这篇文章的内容算是我近期开的小小脑洞之一。</p>
<p>越来越发现，前人总结的一些众所周知并经过时间验证过的关于写代码的道理，只要我们换个角度来类比和思考，同样可以适用于我们人生历程的一些方面。这篇文章就是我想到的一些例子，小标题都是写代码时所谓的一些「金科玉律」，而我会试图通过这些相通的「规律」，衍生出个人对人生某个方面的思考，可能小到微不足道的个人习惯，大到能够决定人生方向的人生观。</p>
<span id="more"></span>

<h2 id="做好垃圾回收"><a href="#做好垃圾回收" class="headerlink" title="做好垃圾回收"></a>做好垃圾回收</h2><p>任何使用 C&#x2F;C++ 写代码的程序员都会在编码时尤其注意一个问题，那就是及时进行垃圾回收。具体来说，由于 C&#x2F;C++ 本身不具有自动垃圾回收的机制，所以但凡程序向操作系统「借用」了一块内存来存放新生成的对象，都必须在对应对象的生命期结束之后的某个时刻主动的进行内存释放，即手动进行垃圾回收。如果没有进行合适的垃圾回收，则系统会陷入了我们常说的「内存泄漏」的问题——由于无用的内存得不到及时的释放，导致程序占用的内存越来越多，最后导致内存不足而整个系统无法正常运行。</p>
<p>一个合格的 C&#x2F;C++ 程序员会把主动进行垃圾回收的习惯带到生活中，小到随手关灯、随手关门、把用过的会议室恢复原样，中到把借来的东西物归原主，甚至大到整个人类对发展过程中对生态环境破坏的及时弥补，其内在其实都是自然的「垃圾回收」原则。</p>
<h2 id="永远不忘把错误默默吞掉"><a href="#永远不忘把错误默默吞掉" class="headerlink" title="永远不忘把错误默默吞掉"></a>永远不忘把错误默默吞掉</h2><p><em>“Errors should never pass silently”</em> 是<a href="https://en.wikipedia.org/wiki/Zen_of_Python">《The Zen of Python》</a>中重要的一条，它告诉我们永远不要忽视代码中的「异常」（Exception）。无论你是像目前大多数语言或框架所设计的把「异常」向上「抛」到一个足够高的层次然后统一记录日志并做处理然后程序继续运行，还是像 Erlang 那样崇尚 <em>let it crash</em> 的思想把所有被「异常」所「感染」到的轻量级 Process 全部挂掉，其相同的基点都是不能把异常默默的忽视掉。</p>
<p>其内在的逻辑在于，我们绝不能忽视系统中的任何一个错误，把问题暴露出来总是比隐藏问题要更好。任何一个不加处理和纠正的错误，对于有状态的系统而言，可能导致系统处于一个完全失常的状态，其行为得不到有效的控制；对于无状态的系统而言，则可能使得任何触发了这个错误的用户请求都产生错误的结果和返回，即便不直接把 Process 挂掉，也至少把错误捕捉到且记录日志并视问题严重程度适当进行告警，否则问题将永远得不到解决。</p>
<p>生活中其实也是如此。当我们遇到问题时，人的本能反应都是逃避的，但逃避永远解决不了我们遇到的问题。选择直面问题和困难是强者和自信者的逻辑和选择，人生也只有在不断的打怪升级中进阶成为更好的自己。具体来说，学习时遇到难点要想办法去弄懂原理，人际交往中遇到误会要及时沟通，工作时遇到阻碍要直面解决等等。</p>
<h2 id="分工明确，关注点分离"><a href="#分工明确，关注点分离" class="headerlink" title="分工明确，关注点分离"></a>分工明确，关注点分离</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">SoC（Separation of Concerns）</a>是面向对象程序设计的核心概念之一，它强调把业务逻辑的代码与解决特定领域问题的代码分离，这样才能使得代码具有「高内聚，低耦合，分层明确」的特点，也就是使得日后由于需求变动带来的维护修改能够以尽可能小的影响面来进行。其实 Erlang 的 actor 并发模型设计对此也有所体现，整个系统任务被拆分成一个个不同的小任务，被大量的轻量级 Work Process 来执行，而 Process 之间唯一的交互方式是通过 messages（这就是好比各个子系统通过 API 来进行黑盒交互），这样的并发模型就完全避免了传统的共享内存式并发的 data race、死锁等固有问题。</p>
<p>人类社会整个就是一个分工明确的动态系统，不同人一定会有不同的专长和兴趣，在走向社会之后也一定会或主动或被动的走到合适自己的岗位上去。而整个人类社会系统是不断动态发展的，正是由于明确的分工机制，客观世界的某个具体的变化不必需要人类全体都进行调整来适应，这样人类社会总体上才得以能够勉力跟上客观世界变化的速度。其实道理很简单，就拿最近影响面极广的 WannaCry 勒索病毒事件来说，即便微软早在两三月前就已经推送了补丁修复漏洞，但由于需要调整的用户数量太大（即便假设所有用户对系统更新都持开放态度），所以肯定还是会有大量来不及进行调整的用户中招。更明确的说，个体数量越多，则所有个体都从当前状态调整到另一个确定状态所遇到的阻力就越大。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实如果有心，还可以发现很多沉淀下来的技术「准则」都可以有更哲学更生活化的解读和理解，也欢迎留言提供你的「新发现」。</p>
<p>程序与人生，不仅仅是写程序的人生，更是透着程序思想哲思的人生。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>被分化的树叶</title>
    <url>/2017/07/15/diversified-leaves/</url>
    <content><![CDATA[<p>窗外是早晨浓重的雾。那的确只是雾，而不是在这座城市常见的霾。</p>
<p>窗子属于道路边一幢十多层高的居民楼，楼的西边儿有一棵不知名的树。树长得很高，树顶已经没过了两旁的建筑。虽然高，但看起来并不显得十分茂盛。树枝均匀的分布在树干上，让树整体上显得很有层次，像二十多岁少女的身姿。</p>
<p>透过洒落在晨雾里的朦朦胧胧的阳光，还是可以勉强从树下看到树上叶子的形状。椭圆形的树叶，面积并不大，长度只及人类中指的二分之一左右。叶片边缘有细小的锯齿，但在这么大的雾里肯定是分辨不出的了。或许是因为阳光的缘故，树南侧的叶子明显比北侧要茂密一些。</p>
<span id="more"></span>

<p>树叶们早已经被分化了。</p>
<p>那是很多年以前，这棵树还只是南方某森林里不知名的小树苗，树叶也不多，但它们在各个方向的长势却基本一致。然而，从它被种到这座北方城市的这一隅开始，树叶们的分化就命中注定般的开始了。自然环境基本决定了每一片叶子未来的大小和形状，无一幸免，无一例外。</p>
<p>太阳越升越高，雾也开始渐渐散去。</p>
<p>树的正西侧中上部位有一片很普通的叶子，大小在这棵树的所有树叶中居中，可是身材已经完全走了样。尽管它很努力的想要保持自己沿中茎两侧的部分对称且均匀，甚至曾经不惜费尽心思借住风的力量让自己的右半边多接触些阳光，然而还是可以明显看出它的左半边比右半边要大一些，而且中茎也已经被左边压弯了，呈现出指向北边的弧度。这片叶子很不喜欢自己失衡的身材，它觉得很失落，也很苦恼。</p>
<p>从树所在的地方再往西边走十几米，是一个十字路口。这个路口是这座城市繁华的缩影，每天从这经过的人和车成千上万，附近的地铁站里也无时无刻不挤满了人。那片身材走样了的叶子每天除了绞尽脑汁的想着如何让自己的右半边的大小能追上自己的左半边之外，就是从这些在它跟前经过的形形色色的人身上找些乐子了。它认为其他树叶肯定也跟它一样，只是都不好意思说。</p>
<p>这么多年过去了，叶子早已经阅人无数了。它看过各种不同年纪的人、各种不同长相的人、各种不同打扮的人、各种不同身材的人、各种不同职业的人、各种不同心情的人、使用各种不同交通工具的人，甚至是在各种不同天气下的各种各样的人。叶子觉得自己已经不能更了解人类了。</p>
<p>然而在这个平凡的大雾的早晨，叶子感觉自己还是在人类身上发掘出了不一样的东西。</p>
<p>以往的叶子总是把它有限的注意力都放在经过它前面的它感兴趣的某一个人类个体上。虽然它的注意力很有限，但它总是能把个体观察得格外细致。经过它长年累月不断打磨的关于人类的经验，它现在已经能从一个人经过它跟前的短短几秒到十几秒钟内，判断出这个人的职业和大致的社会地位。这种判断几乎是瞬间做出的，叶子知道它现在都已经不必经过叶脑思考了。</p>
<p>这个关于人类的新发现正是发生在叶子一如既往百无聊赖地观察人类的时候。这片因身材而犹豫的叶子大概是心情过于郁闷，想找点事情转移一下自己关于自身身材的注意力，于是尝试着强迫自己重新带上自己的脑子去观察人类，很快，它产生了新的思考。</p>
<p>今天的叶子萌芽出了一种更宏观的思维，它开始思考它所观察到的人类样本总体，于是它很顺理成章地就发现了人类个体之间巨大的差异性。它以前只是能把某个人类个体的特征描述完整，从而形成对这个个体的画像，但今天经过它自己的思考，它发现原来人与人之间是那么的不同，这种差异之巨大应该是它们树叶所完全不能理解也无法想象的。</p>
<p>它当然知道树叶们都已经是各不相同的了，即便它和它的兄弟姐妹们都生长在同一颗树上，也已经产生了很大的不同，而且他还知道世界上还有其他树的存在（这是它对侧的兄弟告诉它的，那个兄弟说它对面就有另外一棵树，树上也长满了叶子）。有的叶子色泽光鲜、叶片饱满、茎脉挺拔，有的则显得相对孱弱，甚至还有的叶片都已经有部分残缺了。但从人类之间的差异性上看，它突然觉得它们树叶之间的差异根本算不上什么，因为树叶之间的差异再怎么大也不至于连一丁点儿相似的地方也找不出吧，然而从人类身上它却可以轻松地从记忆中找到两个没有半点特征一样的人。</p>
<p>这样想着，它觉得它自己左半边和右半边之间的差异好像也不那么可恨了。它不知道这是不是它为了自我合理化所找的借口。</p>
<p>太阳好像已经快到树的正上方了，大雾也基本已经散去。</p>
<p>突然，一阵儿微风吹过，这片爱思考的叶子条件反射般地借着风的力量努力扭转着自己的身姿，想尽量让自己相对瘦小的右半边能多接触到一些正午的阳光。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>意识流</tag>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>独立书店的生存困境</title>
    <url>/2017/08/23/arduous-independent-bookstores/</url>
    <content><![CDATA[<p>独立书店，<a href="https://www.wikipedia.org/">维基百科</a>给的描述是<a href="https://zh.wikipedia.org/wiki/%E7%8B%AC%E7%AB%8B%E4%B9%A6%E5%BA%97">「主要以当地人拥有、经营的书店」、「可以是连锁书店的相反词」</a>，这个描述多半还给「独立书店」这个词涂抹上了一点纸质书年代的理想主义色彩。在电商平台、互联网经济大行其道的今天，甭说是「当地人经营」的书店了，即便是那些可以给不同地域的人留下共同回忆、实力还算雄厚的半独立半连锁书店，其生存状态同样不容乐观。又或者说，作为一家「书」店，单看其书籍的销售量，基本已经可以用「垂死挣扎」来形容了。本文就着眼于这些宽泛定义的独立书店的生存困境。当然，新华书店至少是不在这个讨论的范围之内了。</p>
<span id="more"></span>

<p>讲到中国内地的书店，目光自然首先要聚焦到文化中心——北京。</p>
<p>在被戏称为「宇宙中心」的海淀区五道口，高校环伺，不少别具一格的独立书店藏匿其中，这之中最有名的要数目前位于<a href="http://www.tsinghua.edu.cn/">清华</a>南门附近的<a href="http://www.allsagesbooks.com/GUANYU/JIANJIE.HTM">万圣书园</a>。如果你第一次来这个书店，很可能会感到失望——「名声在外的万圣书园原来就是这个破败的样子？」。这也侧面反映出了大环境下独立书店的生存不易。北京的房价自不必多说，更何况是在五道口，2012 年的搬迁直接就让万圣书园的面积缩水了 300 多平米。目前，万圣书园凭借着创办人<a href="https://zh.wikipedia.org/wiki/%E5%88%98%E8%8B%8F%E9%87%8C">刘苏里</a>在文化圈的影响力，依然吸引着众多爱书之人慕名前来，而且这里还时不时会举办一些新书发布会、读书会等活动，客流量还算可观，依傍其旁的醒客咖啡也势必把客单价提高了不少。万圣书园最大的优势就在于其书籍收录之广泛全面，这从店面内直接码放到天花板的书架就可以看出。如果你想找别的书店找不到的书，如果你想找某个品类下一系列相关的书，<del>如果你还想逗一逗书店里的万圣猫，</del>来万圣书园看看吧。</p>
<p>与万圣书园隔街相望的是<a href="https://baike.baidu.com/item/%E8%B1%86%E7%93%A3%E4%B9%A6%E5%BA%97">豆瓣书店</a>。这个书店的店面就更小了，总共也就约五十平米。它最大的特色就是专营旧书，这也可能是它至今还能在著名的万圣书园对面存活下来的原因。旧书并不是指二手书，而是指那些出版年代久远，可能即将被出版社销毁的库存书。但可别因为这样就小看了这些书的质量，能进入豆瓣书店的书都是店长去北京的各大出版社收罗的。因此，你总是能在豆瓣书店找到很多奇特又便宜的旧书，它们可能出版了 5-20 年甚至更长的时间，但你还是很有可能在它们中发现你感兴趣的东西。豆瓣书店每个月还会设计不一样的书签放在门口，供顾客随意取用收藏。值得一提的是，豆瓣书店跟<a href="https://www.douban.com/">豆瓣网</a>没有任何关系，纯粹只是起名的巧合而已<del>，不然店面就不会这么小了（甚至有热心的豆瓣网友呼吁豆瓣网收购豆瓣书店）</del>。</p>
<p>另一个在<a href="http://www.pku.edu.cn/">北大</a>师生心中拥有崇高地位的书店是<a href="http://www.jiemian.com/article/1426822.html">野草书店</a>。本来它已经在北大校园内呆了 14 年了，但因为今年初夏的店面招标失败，被迫搬离了北大，来到了万圣书园附近的一个地下超市的旁边。野草书店可能是这三个书店里网络营销做得最好的。书店经理赵亮用几个手机几个微信号在网上维护着一两万个野草书店的忠实客户，微博上也会时常更新最新到货的新书（可网购邮寄），再配合令人难以想象的折扣力度，野草书店在线上线下应该都还经营得不错。听北大的朋友说，他们以前经常拿着老师开的书单来野草书店购书。</p>
<p>位于成府路上的这三个独立书店可以说是北京众多独立书店的代表，它们各有各的特色，能够在艰难环境中存活下来的原因更是各不相同。</p>
<p>跳出北京，南方的一些半独立书店就和北京这几个书店的经营策略不完全相同<del>，至少它们的店面都有着现代化的精致装修和室内设计</del>。</p>
<p>拿 2015 年年底在苏州开业的<a href="https://www.esliteliving.com/store/store.aspx?a=CN&l=gb&storeno=201511180004">诚品书店</a>来说，它已经被打造成集潮流生活、风格美学、创意设计于一体，照顾现代人品质生活方方面面的一个联合体。这里不仅仅做到了藏书丰富（尤其是一些外文书和台版书），是爱书之人的首选，同时也吸引了一群对生活品质有要求的人。和诚品有着类似经营策略的还有<a href="https://zh.wikipedia.org/wiki/%E6%96%B9%E6%89%80">方所</a>，目前总共只有四家，分别位于广州、成都、重庆和青岛。方所甚至比诚品有着更高的「艺术」和「审美」追求，基本都开在奢侈品林立的中心商务区。</p>
<p>另外一些规模相对小一些的半独立书店，像<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E8%A5%BF%E5%BC%97%E4%B9%A6%E5%BA%97">西西弗书店</a>、广州北京路上的<a href="https://baike.baidu.com/item/%E8%81%94%E5%90%88%E4%B9%A6%E5%BA%97">联合书店</a>，虽然还没有达到像苏州诚品这样多位一体的状态，但靠着经常举办的特色活动，也吸引着一批对特定领域感兴趣的人群的光顾，再加上店内的饮品店和一些其他的配套服务，应该也都还有尚可观的经营状态。</p>
<p>综合来看，虽然本文所列出的书店有的似乎还活得不错，但整个实体书店行业一定是一年不如一年了。高昂的地价成本，加上纸质书相对于电子书的固有成本，以及电商时代人们购书习惯的逐渐变化，使得这些书店不得不树立自己的特色、塑造自己别具一格的品牌形象，来吸引那些有特定需求的人群。好在，这个时间节点上，有不少人还是偏爱纸质书阅读的。</p>
<p>很多爱书之人都有这样的一个梦想，那就是退休之后开一家有个性的书店。随着时间的推移和时代的发展，这个梦想可能会变得越来越遥不可及。对于现有的这些独立书店来说，如果不迅速找准自己的特色和定位，扬长补短，那它们的命运都值得让人担忧。</p>
<p>或许，在独立书店这个领域，光有一点点理想主义情怀，还远远不够。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>独立书店</tag>
      </tags>
  </entry>
  <entry>
    <title>如何系统地学习一门编程语言？</title>
    <url>/2017/07/13/comprehensively-learn-a-new-programming-lauguage/</url>
    <content><![CDATA[<p>「学习一门新的编程语言」是每个程序员都必然会面对的一个课题（注：本文特指工程实践中常用的高级编程语言）。自从高一开始编程到现在，我也接触了不少的编程语言，有的语言已经能在工作中得心应手的使用；有的语言用的不多，但大概了解其设计，也能在官方文档的帮助下简单使用；还有的则之前很了解，但很长时间没有使用过了。</p>
<p>换一份新的工作是最有机会让程序员接触到新的东西的，最近我就应工作需求开始接触一门新的编程语言，学习过程中难免会和已经熟悉的编程语言进行对比，然后发现其实编程语言的学习完全是有「套路」可循的，这篇博客试图总结一下这种「套路」。</p>
<span id="more"></span>

<p>总的来说，编程语言各种各样的特性共同决定了这门语言，这样的特性可能大到并发模型的设计，小到某个具体的语法特性。学习一门编程语言的过程就是不断了解这些语言特性并进行实践应用以及工程化使用的过程。系统性地把语言的主要特性明确清楚，可以快速地建立对一门语言的基本认识，并能做到胸有成竹地深入和细化。</p>
<p>下面就一一说明学习一门新的编程语言至少需要明确的语言特性有哪些，供参考。</p>
<h3 id="编译型-or-解释型"><a href="#编译型-or-解释型" class="headerlink" title="编译型 or 解释型"></a>编译型 or 解释型</h3><p>如今一门语言是编译型语言还是解释型语言似乎对工程开发的影响越来越小（而且大有相互靠拢之势，界限也变得越来越不清晰），这或多或少得益于各种编辑器和 IDE 对于中间过程的自动化处理。不过，明确一门编程语言是编译型还是解释型依然是基础且非常有必要的，这对于理解一些程序的深层行为逻辑会很有帮助。</p>
<p>其实对于语言设计者来说，编译型和解释型从根本上是语言开发自由度和性能优化能力之间的博弈。</p>
<h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>基本地，需要了解该语言都原生支持哪些数据类型，而其中哪些是简单／基础类型，哪些又是复杂／复合类型，各个类型之间又有哪些区别等等。</p>
<p>更抽象来看，类型系统又可以从两个维度来定义：</p>
<ul>
<li>强类型 or 弱类型：核心的区别在于语言<strong>是否偏向于容忍隐式的类型转换</strong>。一个常见的错误理解是「C&#x2F;C++ 是强类型语言」，实际上，在 C&#x2F;C++ 中隐式类型转换很常见，它们是弱类型语言。与之相对的，Python 则是强类型语言。</li>
<li>动态类型 or 静态类型：核心区别在于<strong>是否在编译时就能明确每一个变量的类型</strong>。对于静态类型来说，如果编译时存在类型错误，是无法编译通过的，而对于动态类型来说，由于程序运行时才能明确类型，所以类型错误通常不会导致编译出错（错误会在运行时暴露出来）。Python 就是动态类型，而 C&#x2F;C++ 则是静态类型。</li>
</ul>
<h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><p>如今的高级语言基本都会有成熟的模块系统，好的模块系统对于构建大型工程项目来说必不可少，它可以大大提高程序的可复用能力和模块化能力。</p>
<p>了解一门编程语言的模块系统大概至少需要了解这些细节：</p>
<ul>
<li>依赖的路径是如何解析的？</li>
<li>如何引用自定义模块（文件）？</li>
<li>如何引用第三方的模块或包？</li>
</ul>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>与模块系统相关的一个很影响实际开发的问题是「变量的作用域（scope）是怎样的」。常见的可以自己问的问题是：</p>
<ul>
<li>什么情况下是全局作用域？</li>
<li>什么时候又会是函数作用域？</li>
<li>块作用域又是怎样的？</li>
</ul>
<p>不过，不同的语言对于作用域的定义和分类可能不同，需要具体情况具体了解。</p>
<p>另外，明确语言是「动态作用域」还是「静态（词法）作用域」也非常重要：与动态类型和静态类型的区别类似，静态作用域是在<strong>书写代码</strong>或者说定义时确定的，而动态作用域是在<strong>运行时</strong>确定的。静态作用域关注函数在<strong>何处声明</strong>，而动态作用域关注函数从<strong>何处调用</strong>，其作用域链是基于运行时的调用栈的。可以看看<a href="https://www.zhihu.com/question/20032419/answer/112564460">这个例子</a>做进一步的区分。</p>
<h3 id="支持的编程范式与特色"><a href="#支持的编程范式与特色" class="headerlink" title="支持的编程范式与特色"></a>支持的编程范式与特色</h3><p>编程语言支持哪样的编程范式对于工程项目也非常重要，这也基本和语言设计上的一些别具一格不那么常见的特色相关。比如函数式编程中的「函数是一等公民」、面向对象中的「封装、继承和多态」对应到编程语言上应该如何具体实现、面向并行的语言又是如何实现并发的等等。</p>
<p>了解了这些特色你才能更清楚这门语言在工程中更擅长做哪样的事情，更适合哪些项目。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>基础的你需要了解基本的语法规则和特性，比如分支、循环、函数等等。更深入一些的时候则可以了解一下语言的架构设计、那些语言特性为什么会这样设计以及它们都是如何被实现的。了解实现不一定非得去看源码，搞清楚语言大体上的实现过程还是比较简单的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，把前文的部分<a href="https://www.processon.com/chart_image/595f2e79e4b0a77c5aeb50d7.png">总结成一张思维导图</a>，希望能够让开始学习新编程语言的过程更清晰快速。</p>
<img data-src="https://i.loli.net/2018/08/06/5b6731fe12be8.png" />
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>程序员</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>今晚月色真美</title>
    <url>/2017/12/21/love/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=5099468&auto=0&height=66"></iframe>

<p>这个世界上最复杂、最难以捉摸的事情是什么？</p>
<p>有人说，永远不要在晚上做任何一个决定，因为那是人一天中最不理性的时候。<br>我并不赞同。<br>如果所有的事情都由理性思维来主导，那这个世界上不会有音乐和诗歌，<a href="https://www.youtube.com/watch?v=L9jiPQAuTBw">约翰·列侬、爱因斯坦、乔布斯、黑泽明也不会被人们传颂和铭记</a>。<br>夜深人静，是一个人能与自己对话的时候，也是最能看清自己心意的时候。</p>
<span id="more"></span>

<p>有一种感觉，我遗失了很久，最近又开始出现了。<br>也可能并不是我遗失了她。她一直在那儿，但我以为她已经不存在了。<br>这是一种什么样的感觉？<br>她会让人开始做奇怪的事情。<br>她会让头脑里产生更多的臆想和猜测。<br>她会让你的心时而悬着、时而放下。</p>
<p>人的一生中存在命中注定吗？<br>存在一个对其他人而言「正确」的人吗？<br>右边是被保护的位置吗？<br>人与人都是如何相遇的？<br>人的意识是怎样产生的？<br>地球为什么是圆的？<br>…………<br>噢，不，这些问题都太俗气了……</p>
<p>人为什么活着？<br>只能也只有唯一一个答案——好奇心，对尚未知世界的好奇心。<br>世界上唯一不变的事情就是永远在变，是好奇心让你想知道世界下一秒会变成什么样子。<br>嗯，这是我上一秒钟的答案。<br>可是事情似乎已经超出了「好奇心」可以解释的范畴。<br>真的超出了吗？</p>
<p>云朵本来是没有形状的，有人赋予了它们形状。<br>流星本来是没有寓意的，有人相信它们有寓意。<br>世界依然是概率的。<br>今晚的月色是美的。</p>
<p>我，好像是你的。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>感情</tag>
      </tags>
  </entry>
  <entry>
    <title>2017 年书单</title>
    <url>/2017/12/31/2017-booklist/</url>
    <content><![CDATA[<p>今年太「荒废」了。无论是工作还是生活，已经发生的事情之丰富复杂相比去年完全有过之而无不及，自己心态上的改变也是不少。这种内省式的变化会直接导致个人情绪的变化。用一个烂俗的比喻来说，如果去年的心情像一汪平静的湖水，那今年则可以用海啸来形容<del>（夸张到油腻了）</del>。</p>
<p>我不是一个喜欢制定目标的人，因为无论事情是否达到了你的目标，这个设定都会让你对于自己所做的事情产生反向的反馈：完成了会开始沾沾自喜、放松警惕，没完成则会开始怀疑人生、消极懈怠。当然，这可能只是一个现实的悲观主义者的惯性思维，不足以为参考。</p>
<p>即便如此，年初也制定了一些小目标，明确了一下「即将过去的这一年」的大致方向。写博客的目标是超额完成了，导致我后几个月的博客更新都放缓了（应证了我上一段的描述），可是看书的目标远远没有达到。这意味着今年是个「输出」大于「输入」的一年。</p>
<span id="more"></span>

<p>开篇不多说，今年的书单如下：</p>
<ol>
<li><p><a href="https://book.douban.com/subject/27013716/">沉默的大多数</a>：★★★★★<br>每一句话的笔触都轻，但合起来的力道却很重。三观正得惊人，王小波手执着民族的警钟。    </p>
</li>
<li><p><a href="https://book.douban.com/subject/26729776/">雪人</a>：★★★★☆<br>其实不能算典型的推理小说吧，不过读起来非常爽，文字画面感极强。虽然反转设计的痕迹很重，但非常有效的加强了故事的戏剧张力，自然就在一堆老掉牙的传统推理小说中脱颖而出了。    </p>
</li>
<li><p><a href="https://book.douban.com/subject/26835090/">软技能：代码之外的生存指南</a>：★★★★<br>我是听了译者在某个播客节目的介绍才了解到这本书的，而这本书的内容完全超出了我的预期。<br>首先，这本书的内容不是鸡汤，而是从作者的亲身体验给程序员打造的全方位工作、生活、学习、健身等等各个方面的实用建议。更重要的是这些建议中体现出的作者的技术价值观，我个人也非常认同。<br>目前市面上这类书不多，能跟上时代而不流于形式和灌鸡汤的就更少了。而且译者翻译的中译本很用心，强烈推荐。    </p>
</li>
<li><p><a href="https://book.douban.com/subject/25910698/">迷人的假象</a>：★★★★<br>一本现代大众心理学读物。<br>这个社会很多看似神秘的现象或许都可以从心理学的角度找到科学的解释，甚至可以加以利用。<br>而客观世界的大多数情况下，随机、偶然、无意义才是背后最大的真相，这样的真相又乏味又动人。    </p>
</li>
<li><p><a href="https://book.douban.com/subject/26739566/">途客圈创业记：不疯魔，不成活</a>：★★★★<br>对创业的描写可以说非常真实了，很多事情即便是我这种才进创业公司几个月的人都有些体会，或许大部分人心里都有一个创业梦吧。<br>作者及其团队包括复盘在内一些方法很值得学习，他写过的公众号文章我之前也基本是一篇不落的都看过，非常好。<br>创业维艰，一切都值得好好珍惜。    </p>
</li>
<li><p><a href="http://survivor.ruanyifeng.com/">未来世界的幸存者</a>：★★★☆<br>阮一峰老师还未出版的新书。<br>虽然不是所有的推论过程都十分赞同，但内容还是有一定的启发性，阮一峰老师能够看到事物之间的联系。      </p>
</li>
<li><p><a href="https://book.douban.com/subject/25892728/">Erlang 程序设计（第二版）</a>：★★★★★<br>其实并没有太深入扣代码细节的东西，但惊艳到我的还是 Erlang 实现并发的「与众不同」的设计思路，值得每一个后端程序员了解：<a href="http://maples7.com/2017/06/10/awesome-erlang/">《了不起的 Erlang》</a>。    </p>
</li>
<li><p><a href="https://book.douban.com/subject/27059884/">碟形世界：猫和少年魔笛手</a>：★★★☆<br>固然是好的童话故事，也明显可以看出作者就是在暗讽成人世界的一些事情（我愈发开始对这种用童话故事讨好成年世界的做法的动机变得敏感和怀疑，或许是受近年某些国产作品的影响，而且大多时候这些暗讽的内容已经被各种作品说了太多遍了，也没什么意思了），但腰封上宣传的「比《哈利·波特》和《魔戒》加起来还好看的」，仅就这一本来说，哪里来的自信？    </p>
</li>
<li><p><a href="https://book.douban.com/subject/11941213/">Learn Python the Hard Way(3rd Edition)</a>：★★★<br>一本非常适合新手入门的书，但我开始越来越不赞同用所谓的 “hard way” 的方式去学习新知，我觉得那只是对自己放弃更进一步去探索的借口和让自己心安的理由。知识是没有边界的，尽管放开了去学就好了，何必用 “hard way” 这种外在方式上的、形而下的枷锁来束缚自己呢？<br>Anyway, 今年大部分的工作时间是在用 Python 的，但对这门语言的自信程度还远不如 Node.js，甚至我并不确定它是否真的能让我达到对 Node.js 那样的感觉。依据我有限的经验，Python 在工程化上的实践成熟度比 Node.js 还是差了不少。</p>
</li>
</ol>
<p>人是复杂的，与人相关的所有事情都复杂，人的复杂之处体现在人性上；但「人群」却是简单的，因为你永远只需要往最坏的方向去想就好了。</p>
<p>我为什么在最后还莫名其妙的抛出这样的观点？你可以说世界是一直在向前发展的，也可以鸡贼的说世界是「螺旋式上升」的，但在大众认知领域，世界的发展其实是循环的。这大概是我所看到的 2017 年的最大的特征。</p>
<p>大众认知的底线无疑是在提高，但讨论的实质内容却并没有什么变化。大众热衷于讨论的不是知识，而是观点，而且是些早已经被无数前辈所表达的观点，绝大部分人只是在简单的跟随和重复。知识在信息洪流中的传播天生必然会败给观点，越来越多的人会选择「美味的糖果」而不是「苦口的良药」，依然是人性使然。大众永远在追逐社会热点，而社会热点的发生近乎「随机」。</p>
<p>不过说到这里，<a href="http://maples7.com/2016/11/27/traditional-edu-and-programming/">再一次</a>为了避免误会，还是得区分一下上文所说的「知识」与「观点」。知识是客观的、量化的、难以简单表达的，而观点则完全相反。只有知识才能产生创造，而观点并不能，甚至可能会扼杀创造。</p>
<p>所以，新的一年的一个大的方向就是——更多的学习知识，不要热衷于讨论观点。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>了不起的 Erlang</title>
    <url>/2017/06/10/awesome-erlang/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p><em>Shared mutable state is the root of all evil</em><br><em>共享的可变状态是万恶之源</em></p>
<p><strong>Pete Hunt</strong>      </p>

</blockquote>

<p>大概是从去年年底开始，我开始断断续续地了解 Erlang 这门语言。之所以会想要去学习它，是因为它跟我已经比较熟悉的任何一门语言都有着截然不同的设计理念，而且我了解得越深，就越为其设计思想所折服。</p>
<p>虽然这门语言的年纪早已不算年轻，而且似乎从未「大众流行」过，但在如今 CPU 多核化和云计算的时代背景下，Erlang 却焕发出了不一样的生机。</p>
<span id="more"></span>

<p>Erlang 在构建高可用服务上有其独特的优势，这与 Web 服务的要求不谋而合，其设计理念值得每一名 Web 后端开发工程师去了解。</p>
<p>在介绍 Erlang 的几个核心概念之前，需要先说明的是，本文所指的 Erlang 不仅仅指这门语言本身，而是指整个构建于 Erlang 虚拟机之上的技术体系，这就至少包括了 Erlang 语言、Elixir 语言及围绕它们所展开的技术模型的设计。</p>
<p>语言并不那么重要，重要的是蕴含在语言之中的设计理念和设计思想。</p>
<h2 id="不可变状态"><a href="#不可变状态" class="headerlink" title="不可变状态"></a>不可变状态</h2><p>Erlang 是一种一次性赋值（single-assignment variable）的动态类型函数式编程语言。单次赋值意味着每个变量只能被赋值一次，如果试图在变量被赋值后改变它的值，程序会出错。</p>
<p>如果你初次接触单次赋值这个概念，可能会感到很难理解，但这并不是 Erlang 的原创。函数式编程的重要特点之一就是「不可变状态」（immutable state），Erlang 正符合这个特点。</p>
<p>实际上，在 Erlang 里，变量获得值是一次成功模式匹配操作的结果。如果你有着 C-like 编程语言的背景，你一定知道 <code>=</code> 表示的是一个赋值语句，而且大有各种入门书籍告诉你务必要与数学中的 <code>=</code> 符号区分开来，并很可能会举出 <code>i = i + 1</code> 这样在 C-like 语言中很常见，但在数学中明显不存在的式子（除非是在反证法中）。而在 Erlang 里，<code>=</code> 是一次模式匹配操作，<code>Lhs = Rhs</code> 的真正意思是：计算右侧（Rhs）的值，然后将结果与左侧（Lhs）的模式相匹配。这更多的像是<strong>回归了数学中 <code>=</code> 符号的本意</strong>。实际上，这也并不奇怪，函数式编程这种编程范型就是为了将电脑运算视为数学上的函数计算，同时还要避免使用程序本身的状态和易变的对象。</p>
<p>那为什么「不可变状态」会让编程变得更美好呢？</p>
<p>一个表面上明显的好处是让调试程序变得更简单。引起程序出错的常见原因就是变量得到了意料之外的值，为了防止意料之外的状态进入内部，我们可能不得不在 API 入口处进行参数校验，这意味着我们不得不写出大块的「防御式编程」的代码（这与后文要讲到的 “Let it crash” 特性一脉相承）。在 C-like 的语言里，变量可以被多次修改，因此每一个修改了变量值的地方都有可能是错误产生的地方，而在 Erlang 里，检查这样的错误只需要 check 一处即可。</p>
<p>另一个更深层次的好处是，「不可变状态」是使得程序运行不会产生副作用的保证之一，而<strong>没有副作用意味着可以让程序并行</strong>，这与后文的 Actor 并发模型又是一脉相承的。</p>
<h2 id="Actor-并发模型"><a href="#Actor-并发模型" class="headerlink" title="Actor 并发模型"></a>Actor 并发模型</h2><p>并发模型有很多种，大多数人最熟悉的还是 Java 所采用的基于锁和线程的并发模型，但也有其他的如 Golang 采用的 CSP 模型和 Erlang 的 Actor 模型，如果你对并发模型感兴趣，可以参阅<a href="https://book.douban.com/subject/26337939/">《七周七并发模型》</a>这本书。</p>
<p>如果是传统编程语言来为多核 CPU 编程，就不可避免的需要程序员去对付共享内存的问题。进而为了不破坏共享内存，自然而然地又产生了「锁」的概念，即在必要的时候给这些内存加锁来解决共享内存的问题，而且访问这些共享内存的程序在操作共享内存时还万万不能崩溃，否则很可能产生难以追踪且无法预料的错误（可以与后文的 “Let it crash” 特性对比）。这就跟《人类简史》中所说的「农业社会是人类构建错误社会形态的开始」的概念类似，我们很可能从一开始就构建了不正确的模型，从而只能滚雪球式的将错就错、一错到底。而在 Erlang 里，没有可变状态，没有共享内存，也没有锁，这使得要让程序并行变得很简单。</p>
<p>Erlang 的基本并发单元是进程（Process），它们是一些独立的小型虚拟机。但这与操作系统的进程并不相同，Erlang 的进程是是隶属于编程语言而不是操作系统的。一方面，这意味着 Erlang 是跨平台的，而且它在任何操作系统上都会具有相同的逻辑行为，使得编写可移植的代码完全不是问题；另一方面，这些进程是 Erlang 虚拟机自身实现的，所以它们非常的轻量，创建和销毁都十分快速，占用的资源也非常小，这意味着大量的进程可以并存。</p>
<p>当然，Erlang 的进程是不共享任何内存的，它们相互之间完全独立，而唯一的交互方式是消息（CSP 模型也是如此）。</p>
<p>到此为止，我想题记中的那句「共享的可变状态是万恶之源」就不难理解了。</p>
<h2 id="Let-it-crash"><a href="#Let-it-crash" class="headerlink" title="Let it crash"></a>Let it crash</h2><p>在一般的传统语言里，我们总是被教导着要写「防御性代码」。那可能意味你代码中任何层次抽象出的每一个接口都应当检查传入的参数、可能意味着代码中需要大量的与业务逻辑交织在一起的错误检查代码。这是可以理解的，因为在基于锁和线程的并发模型中，编写多进程代码极其困难，多数程序都只有一个进程，所以如果这个进程随随便便就会崩溃，用专业的话说那就是程序的「鲁棒性」太差了。</p>
<p>而在 Erlang 里对于错误的处理方式与在传统顺序编程的处理方式完全不同。</p>
<p>在 Erlang 里，由于我们有大量的轻量级进程可供支配，所以任何的单进程的故障都不会那么重要。一般情况下，在 Erlang 里我们只需要编写极少量的防御性代码（注意，这里有个过犹不及的误解，在编程时我们不能把 <em>Let it crash</em> 当成一个可以被滥用的特性，也就是不要明知道某个地方可能 crash 却不予理睬），而可以把重点放在纠正性代码上。</p>
<p>在 Erlang 里，系统中的 Process 会划分为两个角色：一部分负责解决业务问题，另一部分则负责在错误发生时纠正错误。负责解决业务问题的部分会尽可能少的使用防御性代码，同时也会假设传入函数的所有参数都是正确的。而纠正错误的部分不会与解决业务的部分耦合在一起，所以这也意味着它们在大部分情况下是<strong>可以被复用</strong>的。</p>
<p>抽象来说，传统的错误处理方式与 Erlang 的错误处理理念实际上是对于问题发生时解决问题的两种不同思路。传统的方式强调尽可能的避免错误发生的可能，但有过编程经验的人基本都知道，要想避免所有错误发生的可能，这是不可能的。而 Erlang 处理错误的角度则不同，它是在错误已经发生后，不管这个错误是怎样的产生的（当然事后还是要具体分析原因的），或者是什么类型的错误，我们都把 A 进程发生的错误交由与之相关的 B 进程来处理，来试图纠正这个错误，使得整个系统恢复到一个我们已知的可控的状态。同时 A 进程直接 crash 掉就好。Erlang 把错误处理的注意力放在的错误发生后的清理工作上。这一点，其实与 Node.js 集群部署时的理念有类似之处，进程分为主进程和工作进程，但 Erlang 在这一点上做得更为彻底，而且在语言层面上就是这样设计的。</p>
<p><em>Let it crash</em> 所带来的好处其实有很多，除了前面已经说到的不用写大量与业务代码交织在一起的防御性代码和在错误发生时可以不管原因统一处理之外，他还能使得发生的错误不至于被恶化造成不可控的更严重的后果，因为发生错误的 Process 已经被 crash 了。它也使得错误能够立即被上述的 B 进程处理，而且错误不会继续运行导致调试也变得困难。更深入地，它还使得我们在设计系统时可以有意识地把业务部分和错误恢复部分当成两个独立的问题来思考，这一点是非常符合 <a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">SoC（Separation of Concerns）</a> 的要求的（我在上一篇博文<a href="http://maples7.com/2017/05/24/programming-and-life/#%E5%88%86%E5%B7%A5%E6%98%8E%E7%A1%AE%EF%BC%8C%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">《程序与人生》</a>中也有提到这一点），即特定问题由特定专业分工明确的不同代码来解决。</p>
<h2 id="GitHub-语言颜色"><a href="#GitHub-语言颜色" class="headerlink" title="GitHub 语言颜色"></a>GitHub 语言颜色</h2><p>最后，说一个 tricky 的理由，在 GitHub 上代表 Erlang 和 Elixir 的颜色是紫色（Elixir 的颜色更深一点），这个已经暗示了这门技术的尊贵之处了。</p>
<p>哈哈，开个玩笑。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>希望这篇文章能真正引发你对于 Erlang 这门设计优秀的语言的兴趣与关注，并同时推荐你看<a href="https://book.douban.com/subject/25892728/">《Erlang程序设计（第2版）》</a> 这本书，它是由 Erlang 的设计和发明者、「Erlang 之父」Joe Armstrong 亲笔撰写的，所以在语言的诸多设计理念上都有非常清晰的讲解。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
        <tag>函数式编程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>长按是好的交互方式吗？</title>
    <url>/2018/12/19/long-press-sucks/</url>
    <content><![CDATA[<p>长按是好的交互方式吗？</p>
<p>这个问题虽然微小但其实困扰了我本人很久。每当我拿起索尼头戴式耳机，忍受着右手以一种不那么舒服的姿势，心里充满不确定性和不安全感地用自己的大拇指紧紧按住电源键几秒钟试图开机或关机时，我都会反复的问自己：长按是一种好的交互方式吗？</p>
<p>智能手机时代，最开始接触到「长按」这种交互方式，大概始于智能手机的电源键。记忆里，在 iOS 系统中，「长按电源键」一开始是唤出关机界面「滑动已关机」的交互方式，而在新款 iPhone 搭配的 iOS 中，「长按电源键」是唤醒 Siri 的一种方式。</p>
<span id="more"></span>

<p>除了平时最长接触到的手机，「长按」交互在各种音乐相关的电子设备上也常见，比如各种便携式音箱和头戴式耳机<del>（也不知道是音箱「抄」了耳机，还是耳机「抄」了音箱）</del>。在我的索尼 SRS-X11 小音箱上，「短按电源键」是开关，「长按电源键直到听到哔声」会进入蓝牙配对模式。而在索尼 WH-CH500 头戴式耳机上，「长按电源键约 2 秒」是开关耳机，「长按电源键约 7 秒」会让耳机进入蓝牙配对模式，这几乎是目前我所有电子设备中让我最想吐槽的交互方式。</p>
<p>不管是 iPhone 还是索尼的这两款音乐电子设备，都是大众电子消费品。对于我个人而言，长按的交互方式在 iPhone 和 SRS-X11 上的设计是合格的，在 WH-CH500 上的设计则完全不合格，这几乎是初级产品经理或交互设计师都不应该犯的设计错误。</p>
<p>作为一名软件开发工程师，我并不知道「长按」在交互设计上是否有硬件技术或工程上的考量，这里仅从用户体验的角度来妄自品评一下。</p>
<p>首先，「长按」交互本身是一种怎样的体验？</p>
<p>第一，「长」不是一个可以量化的形容词。我并不知道我需要按多久才算「长」，每个人对于「长」的理解是不一样的，用户由此在心中产生的不确定性疑惑和不安全感最终会转化成对产品的不信任，使得用户体验大打折扣。更不用说「长按 2 秒是 A 操作而长按 7 秒是 B 操作」这种失败设计了：我要是不小心长按了 3.5 秒会怎么样？多长时间是 7 秒呢？我需要用秒表数吗？现在我已经按几秒了？</p>
<p>第二，「长」这个字首先就说明了这是一个需要用户<strong>持续</strong>用力的<strong>过程</strong>，可以说非常不友好。在这个快节奏的社会，人们都在追求<a href="http://maples7.com/2016/08/24/understand-sync-async-and-blocking-non-blocking/">「异步非阻塞」式的交互方式</a>：所谓「异步」，我希望我调用了任务之后可以在它完成后主动通知我；所谓「非阻塞」，在这个任务执行的过程中我希望我自己是自由的，可以去做任何我想做的事情，我作为独立个体是完全解放的。虽然「长按」交互本身是一个时间上并不算长的交互，但它几乎带给我几秒钟的「同步阻塞」的体验，这意味着我的 CPU —— 大脑 —— 甚至需要一直关注在我的长按操作上，并且要不断的 check 我的操作是否成功了。这简直「反现代人类」。</p>
<p>第三，「长按」的重试成本很高。「长按」本身就是一个耗时操作，假设在我的一阵不安的惊恐长按操作之后，产品并没有实现我预期的效果，我首先可能会怀疑 —— 是它还在「反应中」吗？操作本身的延时性会让人怀疑是不是这个操作产生的结果也是耗时的，这意味着我需要等。如果稍等片刻之后大概率确信是刚才的操作失败，我就需要不断的重试，这是一个接一个「同步阻塞」的耗时操作。</p>
<p>对于 C 端产品而言，好的交互应该是自然而然的，在你进行过操作之后你不需要意识到你做过了什么，也不需要怀疑自己，产品就已经给了你想要的东西。而「长按」的交互方式违背了这一点。</p>
<p>那「长按」交互的设计初衷是什么呢？我想本质上是为了使得操作本身不那么容易被触发。所以接下来，我们再结合具体产品的使用场景来琢磨一下这个交互方式。</p>
<p>在 iPhone 上，无论是「开关机」操作还是「唤醒 Siri」的操作，都不算是常用操作，而且由于电源键的位置正好是单手拿起握住时食指所在的位置，削弱了「长按」操作本身的「存在感」；在 SRS-X11 上，「长按」仅用于蓝牙配对，这本身也是一个很低频的操作；而在 WH-CH500 上，「长按」居然被用在了耳机开关这种高频操作上，在有时不确定设备是否是开启状态而又不想把它从头上摘下来看指示灯的状态的时候，我甚至需要先长按试试耳机是开机状态还是关机状态，如果不幸把它按关机了我还需要再长按一次来开启它。更不必说「长按不同时间产品会响应不同的操作结果」了，这几乎是一个类似于用多进制计算机取代二进制计算机的失败设计，加剧了系统的不稳定性和用户体验的不确定性。似乎几乎所有的索尼头戴式耳机都是采用的「长按电源键进行开关」的交互设计，我非常希望他们能仔细考虑一下这一点。在我看来，即便是拨动式的开关设计也比长按来开关耳机的交互体验要好。</p>
<p>综上所述，从具体产品的使用场景上来说，「长按」其实类似于软件开发中日志等级的 WARNING 级别，不是日常信息且需要一些用户的注意力，如果用户需要使用到这个操作，那希望他是有一定的意识清楚自己在做什么的。按这个类比，日常的点按、滑动等无意识操作算是 INFO 级别的日志；而非紧急情况下不应该使用的操作，比如 iOS 里的「SOS 紧急呼叫」、楼道里需要砸破玻璃才能按下的消防按钮等，应该归类到 ERROR 级别。</p>
<p>希望以后的产品设计师在选择使用「长按」作为交互方式时都能走点心，而不仅仅是按照所谓的「传统如此」。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>交互设计</tag>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title>完全理解并发</title>
    <url>/2018/10/21/understand-concurrency/</url>
    <content><![CDATA[<p>越是往后端深入到 Web 开发和分布式系统，就越会觉得把「并发」理解清楚是多么重要，而每天的日常工作中很多时候都需要处理与并发有关的话题，大到整个系统架构层面的并发考量，小到某一段代码的并发控制。</p>
<p>本来不想把这篇文章加入到<a href="http://maples7.com/tags/%E3%80%8C%E5%AE%8C%E5%85%A8%E7%90%86%E8%A7%A3%E3%80%8D%E7%B3%BB%E5%88%97/">「完全理解」系列</a>，因为觉得「并发」涉及到的东西实在是很多，而我想凭借一篇博客企图「完全理解」那是不现实的。但虽然不能做到「完全理解」，但我还是会尝试尽力提纲挈领的把「并发」相关的话题都理清楚，把脉络勾勒出来，让它尽可能对得起「完全」吧。<del>毕竟，如果以后我有了一些更深的理解，我还可以继续迭代这篇文章。</del></p>
<span id="more"></span>

<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>在开始正式的话题之前，我们先来厘清两个概念——「并发」与「并行」。</p>
<p>Erlang 之父 Joe Armstrong 曾经用一张非常简单易懂的图解释了「并发」与「并行」的区别：</p>
<p><img data-src="https://i.loli.net/2018/08/06/5b67309e4d019.jpg" alt="Joe Armstrong 解释「并发」与「并行」"></p>
<p>「并发」是同学们排成两队，然而却只有一个咖啡机在工作，所以两个队列排在前面的同学交替使用咖啡机；「并行」则是两台咖啡机分别服务两个独立的同学队列，它们同时进行，互不干扰。</p>
<p>这样的例子简单易懂，但依然还需要更进一步说明的是，「并发」与「并行」其实并不是同一个维度上非黑即白的两个对立的概念。「并发」更多的强调的是有没有这样的能力或特征，它是从事物的性质和对外表现上来说的，它不在乎你内部是如何实现「并发」的，相对而言是在更高层次上的概括，而「并行」则规定了它们在物理上一定是同时进行的，相对而言更严格。</p>
<p>具体从编程的角度来说，「并行」甚至可以是实现「并发」的一种手段，比如用下文所要讲的「多线程」或「多进程」的方式来赋能某一段程序的「并发」能力：为了使程序具备「并发」的能力，采用「多线程」或「多进程」在应用层面上可以「并行」运行的具体实现手段来为其赋能。</p>
<h2 id="计算机操作系统发展史"><a href="#计算机操作系统发展史" class="headerlink" title="计算机操作系统发展史"></a>计算机操作系统发展史</h2><p>要追根溯源的来理解「并发」，我们首先应该了解一下计算机操作系统的发展历史。因为回顾整个计算机操作系统的发展历史，我们就会发现，几乎所有的关键历史节点，都是因为它使得计算机系统拥有了更强的并发处理能力而变得重要的。</p>
<p>在计算机诞生之初，是没有操作系统这种东西存在的，当时人们只能先把打孔纸带通过输入机将程序传入计算机，再启动运行。在程序执行完毕之后，打印机把计算结果输出，在现场监督程序执行的程序员再取走纸带。在这个时期，同一个计算机系统在同一时间只能处理唯一确定的一件事情。</p>
<p>后来人们发明了批处理系统。批处理系统相当于计算机上的一个任务监督程序，在它的控制和调度下，计算机能够自动的、成批的处理一个或多个用户的任务。在批处理系统的帮助下，各个任务之间可以自动衔接，减少了需要人工建立任务和手工操作的时间，提高了计算机的利用效率。</p>
<p>再后来，随着 CPU 性能的不断提升，出现了分时系统和实时系统。分时系统是把 CPU 的运行时间分成很短的时间片，按时间片轮流把 CPU 分配给各联机任务使用。若某个任务在分配给它的时间片内不能完成其计算，则该任务暂时中断，把 CPU 让给另一任务使用，等待下一轮调度时再继续其运行。由于计算机速度很快，各个任务之间轮转得也很快，给每个用户的感觉是他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。为了解决分时系统不能及时响应用户指令的情况，又出现了能够在严格的时间范围内完成事件处理、及时响应随机外部事件的实时系统。</p>
<p>IBM 于 1964 年伴随着大型机 System&#x2F;360 推出了通用操作系统 OS&#x2F;360，这个通用的操作系统使得不同型号的计算机设备也可以在同样的操作系统控制下使用同样的外部设备（如打印机）和更上层的软件，并且这些设备之间可以相互连接，共同工作。通用操作系统使得不同型号的计算机设备之间能够真正组成网络来处理复杂的任务。<del>软件工程领域的著作<a href="https://book.douban.com/subject/2230248/">《人月神话》</a>也是诞生于 IBM 的这个项目。</del></p>
<p>再往后就是我们相对更加熟悉的 Unix&#x2F;Linux&#x2F;Windows&#x2F;OS X 这些现代操作系统诞生、迭代、版本更替的历史，目前这些操作系统的并发能力已经远远超出了当时的 OS&#x2F;360，而现代计算机网络的加持更是使得理论上的计算机并发处理能力几乎已经没有了上限。</p>
<p>从整个计算机操作系统的历史我们可以清晰的看到历史上的计算机科学家们是如何一步一步来提升计算机处理任务的效率的。从一开始需要手工的开启、监督、结束单一任务，到使用批处理系统来自动化的监督任务流水线，再到使用分时系统来让 CPU 在多个任务之间不停的轮转，然后用后文要详述的多 CPU 使用多进程和多线程的方式来进一步提升多任务的执行效率，最后我们使用通用计算机系统来组成庞大的计算集群来处理复杂的各种各样需要随机响应的任务，并发能力一次比一次有了质的提升。</p>
<p>如果说<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B">「摩尔定律」</a>使得 CPU 的性能可以指数级的增长来从单机速度上提升任务完成的效率，那么不断的提升并发能力则是更高屋建瓴的考虑如何不间断不浪费的来「压榨」CPU 的高性能，这种思考问题的维度比一门心思的考虑提升单 CPU 的速度更具有现实意义，对于解决现有问题来说是更加高明的选择。尤其是在「摩尔定律」行将失效的今天，采用分布式的方式提高整个系统的并发处理能力几乎成了唯一的选择。</p>
<h2 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h2><p>让我们先回到单机时代，来了解目前主流的并发模型——多进程与多线程。现代操作系统早已进入多 CPU 时代，自然会支持多进程和多线程。「进程」就是操作系统中一个具有独立功能的程序，操作系统管理所有进程的执行并且以进程为单位分配存储空间。一个进程还可以拥有多个并发的执行流程，这些并发的执行流程是可以获得 CPU 调度和分派的基本执行单元，也就是线程。</p>
<p>进程是计算机资源的拥有者，创建、切换和销毁都有较大的时空开销，而一个进程内的所有线程共享这个进程的资源，更轻量级，对其的相关操作也开销更小。需要注意的是，对于单核 CPU 系统而言，并行其实是不存在的，任何时刻 CPU 其实只能被一个线程所获取，线程之间共享了 CPU 的执行时间。由于切换的速度很快，对外表现为并发执行的样子。</p>
<p>多进程和多线程是如今高级编程语言中实现并发的常规模型，比如 C++、Java、Python。同时为了解决程序中多个进程和线程对资源的抢占问题，还引入了「锁」的概念。在这个并发模型中，需要开发人员利用「锁」来处理资源抢占的问题，也就是不让某一个资源同时被多于一个进程（线程）所处理而带来不可预期的后果。</p>
<p>既然有多进程和多线程，那么「锁」自然也有「进程锁」和「线程锁」。我们知道两个进程其实是相互独立的，各自拥有操作系统分配的独立资源，而「进程锁」是为了防止两个进程对他们所占用的资源以外的共享资源同时访问，一般可以使用操作系统级别的信号量来实现。相对应的，「线程锁」则是保证同一段代码在同一时间只有一个线程在执行，一般各语言本身或类库会提供实现方式。</p>
<h2 id="分布式并发锁"><a href="#分布式并发锁" class="headerlink" title="分布式并发锁"></a>分布式并发锁</h2><p>「分布式锁」跟「进程锁」和「线程锁」很像，不过它更多的是使用在计算集群的场景中。在本质上，进程锁、线程锁和分布式锁的作用都是一样的，只是作用的颗粒度不一样。线程锁作用于单一进程的范围，进程锁作用于单一操作系统的范围，而分布式锁则可以作用于网络结构中。在分布式集群当中，我们使用分布式锁来保证不同线程对代码和资源是独占的。</p>
<p>如何实现一个完美的分布式锁呢？我们先来分析一下实现一个好的分布式锁应该满足什么需求：首先这个加锁操作应该是原子性的，否则这个锁是有可能被「击穿」的；其次锁一般还需要有过期时间，使得某一次执行异常没有移除锁的情况下也能自然过期然后重试。</p>
<p>以大多数人都熟悉的 Redis 为例，我们可以使用 Redis 的 set 指令，把 key 作为锁的标志。尤其注意的是，这个操作原子性包含了查看锁存不存在、加锁和设置过期时间三步操作，它们合在一起应该具有原子性（至少前两步）。也就是说，如果我们需要先使用 get 指令查看锁存不存在再决定是否加锁，这个锁已经不是一把好「锁」了。好在 <a href="https://redis.io/commands/set">Redis 2.6.12 以上的 set 指令</a> 支持了同时加参数设置过期时间和判断 key 是否存在，比如使用 <code>SET lock_key lock EX 5000 NX</code>，NX 保证了锁不存在时才上锁，而 Redis 指令本身具有原子性，这样就实现了一把看起来还不错的锁。在任务执行完毕后我们还需要用 del 指令主动把锁删掉以释放资源。</p>
<p>上述例子只是一个简单的场景，这个锁其实还并不是完美的。思考这样的问题：如果某一次操作线程 A 执行的特别慢，超过了过期时间，这个时候锁已经自动过期失效了，这样就有可能两个线程同时在执行了。如何避免这样的问题这里不再详述，感兴趣的同学可以参考末尾 References 里面的内容。总之，实现一把完美的分布式锁可能并没有想象中那么简单。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>对于高级编程语言而言，多进程和多线程的并发模型更多的还是与操作系统底层对于并发的实现是保持一致的。也就是说，在它们的抽象层级上，实现并发的方式基本只是复刻了操作系统底层的并发模型。而 JavaScript 却不一样。</p>
<p>JavaScript 在诞生时就被定位为在网页前端执行的脚本，为了保证线程安全，而且主线程也不会被 I&#x2F;O 等待所阻塞而失去响应，JavaScript 在设计阶段就采用了「异步事件模型」。这个模型并不是 JavaScript 独有的，它只是借用了这个古老的模型来解决它自身的问题。</p>
<p>在实际情况中，异步事件模型也是采用多线程的方式来实施的。但是对于开发人员而言，你永远只需要跟主线程打交道，而所有的这些交互都是所谓「异步」的，也就是说，你调用的任何一个 API 都在执行成功后主动告知你执行结果，这样你就可以不必被任何 I&#x2F;O 所堵塞（详细的关于异步、同步、阻塞和非阻塞的辨析可以看这里：<a href="http://maples7.com/2016/08/24/understand-sync-async-and-blocking-non-blocking/">《完全理解同步&#x2F;异步与阻塞&#x2F;非阻塞》</a>）。既然不会被阻塞，那么你可以以很快的速度调用很多个你需要调用的 I&#x2F;O，这些 API 在自己执行完毕后会主动返回结果，你可以拿着结果来继续做后续的事情，而其他时刻你完全是「自由」的。</p>
<p>在这个并发模型中，你不再需要处理各种「锁」的问题，因为真正和你交互的只有主线程。可是作为开发者，你可能需要考虑如何处理代码中的各种异步流程。因为在异步的世界里，代码不再是简单的按照书写顺序来顺序执行的，如何在工程中清晰合理的组织这些流程是在这个并发模型下需要考虑的问题。</p>
<h2 id="各种各样的并发模型"><a href="#各种各样的并发模型" class="headerlink" title="各种各样的并发模型"></a>各种各样的并发模型</h2><p>这个世界上除了多进程&#x2F;多线程的并发模型和异步事件并发模型，还有很多其他的并发模型，比如 Erlang 的 Actor 并发模型和 Golang 的 CSP 并发模型。在 Erlang 的并发世界里，有很多比内核线程还要轻量级的对象，它们之间通过各种 Message 来进行数据共享。这些对象非常轻，可以同时成千上万的被创建出来实现并发，而对象之间都通过发消息来进行数据交换，根本不需要「锁」。</p>
<p>在一个没有「锁」的世界里，并发的效率是可以大大的提升的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每一个并发模型都有其存在的意义和价值，不过在具体的业务场景下，采用不同的并发模型的好坏却是客观的。</p>
<p>真理是存在的，可以被不断逼近却永远无法被任何事物所完美诠释。在技术的领域里，没有永恒的真理，但是真理永远值得被追求。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://book.douban.com/subject/26337939/">《七周七并发模型》</a></li>
<li><a href="https://github.com/jackfrued/Python-100-Days">Python-100-Days</a></li>
<li><a href="https://www.itcodemonkey.com/article/3934.html">漫画：什么是分布式锁？</a></li>
</ul>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>「完全理解」系列</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 MySQL 的热数据与冷数据分离设计与实现</title>
    <url>/2018/12/25/hot-cold-data-based-on-mysql/</url>
    <content><![CDATA[<p>作为<a href="https://www.seniverse.com/">一家提供商业气象数据服务的创业公司</a>，我们一直都有一项「欠交的作业」没有完成，那就是合理的数据规划和数据治理规范。对于早期的初创公司而言，可能很难从一开始就能构想到需要对数据存储进行合理的规划并制定长期规范，大多都是简单使用单实例的数据库，直到随着业务增长数据量累积到一个不得不严肃考虑这个问题的地步。</p>
<h2 id="数据库发展简介"><a href="#数据库发展简介" class="headerlink" title="数据库发展简介"></a>数据库发展简介</h2><p>数据量的增长其实一直是随着互联网的发展呈现爆发式增长的，因为各种各样的数据都在不断的被原样或者是经过少量的更改和增补后拷贝到互联网的各个角落。为了适应互联网数据的海量增长，在后端和架构意义上而言，数据库的发展也大致经历了「单库单表 -&gt; 主从读写分离 -&gt; 分表分库 -&gt; NoSQL -&gt; NewSQL」这样的过程。</p>
<span id="more"></span>

<p>一开始，我们把数据都堆在一个数据表里；后来为了提高性能、增加数据扩展的能力，采用了「主从读写分离」和「分表分库」的方式，前者只需要在主从实例之间做数据同步而不会对既有业务有较大的影响，后者则需要用一套切合业务逻辑的方式合理的制定分表分库的策略；再后来出现的 NoSQL，打破了传统关系型数据库固有的一些限制，它们有不同的类型，有的是为了解决高性能读写的需求，有的则是为了解决海量数据存储的需求，还有的需要数据结构本身具备可扩展性；NoSQL 的不同类型在不同的侧重点解决了不同的问题，而如今出现的 NewSQL 则倾向于把数据库看作是一个黑匣子服务，你还是可以遵照传统的数据库协议的使用方式（比如传统 MySQL 的使用方式）来使用它，但数据存储服务本身既可以同时具备较高的读写性能又可以轻易的实现横向扩展。NewSQL 并不是一个全新的东西，我们可以把它看作是之前积累的数据库技术结合分布式技术的集大成解决方案，它使得使用数据服务的人几乎不需要再考虑性能和扩展问题，而尽量在数据服务内部实现高可用、高性能、可扩展。</p>
<h2 id="「热数据」和「冷数据」"><a href="#「热数据」和「冷数据」" class="headerlink" title="「热数据」和「冷数据」"></a>「热数据」和「冷数据」</h2><p>在简单了解了数据库发展历程之后，再介绍一下我们目前在数据存储上遇到的问题和一些业务背景。</p>
<p>作为气象大数据服务商，随着我们积累的数据量和数据种类越来越多，我们发现我们已经迫切需要一个在全局层面统一的数据路径规划和规范。很多时候，我们从数据源获取到的数据，既需要马上分发给线上用户，也需要被内部项目使用，如果只是简单的按需实现，那数据流转会非常混乱。基于这种考虑，我们引入了「热数据」（「在线数据」）和「冷数据」（「离线数据」）的概念：</p>
<ul>
<li><p>「热数据」指的是需要即时对用户进行分发的数据，即从数据源抓取之后经过数据清洗，需要即时存储到可以快速分发的存储介质（如 Redis）供 API 或直接面向用户的系统使用。「热数据」线需要重点保障服务质量和稳定性，为了保证数据的时效性，在数据处理上也是优先级高的数据。「热数据」可能是临时或短期存储的，后来的数据可能会覆盖已有的数据。</p>
</li>
<li><p>「冷数据」指的是不需要即时分发给用户的数据，这些数据甚至可能永远都不会原样分发给用户的，但它们需要经过长期的积累，使我们可以从中得出基于此的更高 level 的分析。「冷数据」典型的使用场景是供内部数据评估系统做数据准确度的评估分析，同时也可以给算法团队建模使用。设立这个数据线的原则是不影响「热数据」的服务质量，尤其是时效性和稳定性，同时也满足一些非线上项目的数据使用需求。</p>
</li>
</ul>
<p><img data-src="https://i.loli.net/2018/12/25/5c213783d5c3e.png" alt="热数据线和冷数据线设计"></p>
<p>这其实也不是什么新鲜的概念，很多做数据服务的公司都有类似的设计，我们只是根据我们的业务特点借用了这样的概念，不过它们的含义可能与你在其他地方看到的类似概念的含义有所不同。</p>
<p>结合我们具体的业务场景来说，「热数据」线其实已经一直在有效运转了，即我们从数据源获取到数据然后尽快存储到高性能存储介质中，再通过 HTTP 协议分发出去，这些数据都是即时更新的最新的数据。而其中有一些类型的数据，我们还需要在可视化项目中查看历史变化情况，并能进行简单的聚合和计算，这意味着数据需要积累一段时间，那我们也需要一些可以持久化存储的介质。</p>
<p>拿天气实况来举例，我们在采集完数据之后，随即就存储最新的一份数据到 Redis，而出于数据积累的角度考虑，我们同时也把新数据写入 MySQL。这是之前我们的做法，然而随着数据量的极速扩大，问题很快就会出在 MySQL 上。对于「亿」级别行数往上的 MySQL 单表，操作会变得越来越困难，而大范围的抽数或者插入数据的操作都可能使得整个 MySQL 无法提供服务，这对于线上业务而言是不可接受的。</p>
<h2 id="离线数据中心的实现"><a href="#离线数据中心的实现" class="headerlink" title="离线数据中心的实现"></a>离线数据中心的实现</h2><p>在提出了「冷数据」的概念之后，我们意识到那些久远的历史数据其实需要存放到「冷数据」的数据中心池子里，而线上 MySQL 只需要保留最近一段时间的数据即可。另外，为了不改变现有项目使用数据的方式，降低数据库使用者的门槛，不管是对于线上数据库还是「离线数据」的数据中心，我们都需要兼容 MySQL 单表的使用协议。</p>
<p>很快我们就开始考虑 NewSQL 的方案，<a href="https://github.com/pingcap/tidb">TiDB</a> 很自然地进入了我们的视野，这是一个既可以兼容现有数据使用方式，又可以实现数据横向扩展的完美方案，但无奈搭建一个最小版本的 TiDB 数据集群的成本，相比于目前我们把它作为一个「离线数据」存储中心的角色而言，还是有一些偏高，而我们的存量服务也基本都是基于阿里云的，所以最终我们选择了阿里云推出不久的云数据库 <a href="https://www.aliyun.com/product/polardb">PolarDB</a>。其间我们还研究了很多其他数据库方案，比如 <a href="https://www.aliyun.com/product/drds">DRDS</a>、<a href="https://oceanbase.alipay.com/">OceanBase</a>、<a href="https://cloud.google.com/spanner/">Google Cloud Spanner</a>、<a href="https://aws.amazon.com/cn/rds/aurora/">Amazon Aurora</a> 等。</p>
<h2 id="数据同步和数据过期"><a href="#数据同步和数据过期" class="headerlink" title="数据同步和数据过期"></a>数据同步和数据过期</h2><p>有了离线数据存储中心之后，我们开始考虑如何把「热数据」转化为「冷数据」，同时也使得线上数据库可以自动过期超出时间窗口的历史数据。另外，由于内部可视化项目也希望看到实时的实况数据，所以离线数据最好也能很快获得最新的实况数据。</p>
<p>既然是两个 MySQL（集群）之间的实时数据转移，很自然的就想到了我们可以做类似主从节点之间通过 binlog 的数据同步机制，这个同步可以做到秒级延迟，在实时性上是完全可以接受的。不过这不能是简单的数据同步，因为离线数据是不能同步线上数据的过期操作的。更具体的，我们可以概括成：MySQL 从节点同步主节点所有数据增添和数据修改的操作，而对于数据的删除操作不做同步。</p>
<p>在调研之后，我们发现 TiDB 提供的同步工具 <a href="https://pingcap.com/docs-cn/v3.0/reference/tools/syncer/">Syncer</a> 可以实现这一点，我们只需要在配置注明过滤掉 DELETE 的 DML 语句即可，示例如下：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[[skip-dmls]]</span></span><br><span class="line"><span class="attr">db-name</span> = <span class="string">&quot;weather_data&quot;</span></span><br><span class="line"><span class="attr">tbl-name</span> = <span class="string">&quot;weather_now_history&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;delete&quot;</span></span><br></pre></td></tr></table></figure>

<p>而数据过期方案则可以直接借助 MySQL 本身的 EVENT 和 PROCEDURE 机制完成。首先我们可以创建一个删除数据的 PROCEDURE：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`weather`@`<span class="operator">%</span>` <span class="keyword">PROCEDURE</span> `weather_data`.`del_old_data`(<span class="keyword">IN</span> `date_inter` <span class="type">int</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">from</span> weather_data.weather_now_history <span class="keyword">where</span> datetime <span class="operator">&lt;</span> date_sub(curdate(), <span class="type">interval</span> date_inter <span class="keyword">day</span>);</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>这个 PROCEDURE 功能是删除 <code>weather_now_history</code> 表中 <code>date_inter</code> 天之前的数据。然后我们再创建一个 EVENT：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EVENT del_old_data</span><br><span class="line"><span class="keyword">ON</span> SCHEDULE <span class="keyword">EVERY</span> <span class="number">1</span> <span class="keyword">DAY</span></span><br><span class="line">STARTS <span class="string">&#x27;2018-12-25 10:08:35.000&#x27;</span></span><br><span class="line"><span class="keyword">ON</span> COMPLETION PRESERVE</span><br><span class="line">ENABLE</span><br><span class="line">DO <span class="keyword">call</span> del_old_data(<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<p>这个 EVENT 则会每天调用一次名为 <code>del_old_data</code> 的 PROCEDURE，并同时把 <code>date_inter</code> 赋值为 <code>30</code>。这意味数据库每天会删一次数据，使得线上数据库一直只保留最近 30 天的数据，而全量的数据是在数据写入时就实时同步到了离线数据中心，可谓完美。</p>
<h2 id="持续改进"><a href="#持续改进" class="headerlink" title="持续改进"></a>持续改进</h2><blockquote>
<p>All problems in computer science can be solved by another level of indirection.<br>—— David Wheeler</p>
</blockquote>
<p>上述的具体业务场景更多的还是 case by case 的解决了「热数据」和「冷数据」的分离和转化问题，这意味着方案并不具有普适性，以后我们遇到其他的数据库或者不同的数据使用场景可能就不再适用。另外，很多时候，「热数据」和「冷数据」的划分并不是那么明晰的，对于「冷数据」的需求有可能转变为「热数据」需求，我们需要可以灵活切换的机制，做到数据源只抓取一次（「热数据」和「冷数据」不要分别抓取），而抓取到的数据可以任意自由的流淌到「热数据」或「冷数据」线使用，这意味着我们在数据抓取和数据存储之间应该再做一层隔离。</p>
<p>要实现数据抓取和数据存储之间的隔离，我们可以采用「发布&#x2F;订阅模式」：简单说，数据抓取服务在获取数据之后将数据发布到消息队列，后面的存储服务任意订阅这个消息队列再做存储，这样数据源只需要抓取一次，我们可以把它作为热数据使用，也可以作为冷数据使用，甚至可以即作为热数据又作为冷数据使用，切换起来也十分简单。这是后续系统架构可以改进的一个地方。</p>
<p>另外，离线数据中心仅仅使用 PolarDB 对于我们可能产生的数据量级而言也是远远不够的，我们还需要更低成本的数据存储方案来存储时间更久远、平时几乎不大会访问的一些需要被「归档」的数据，这个时候，一些基于列存储的 NoSQL 数据库可能可以派上用场。</p>
<p>数据治理需要一个长期持续的过程，我们还在结合自身的业务场景不断的摸索当中。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/36112488">TiDB 在饿了么归档环境的应用</a></li>
</ul>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>热数据</tag>
        <tag>冷数据</tag>
        <tag>在线数据</tag>
        <tag>离线数据</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 年书单</title>
    <url>/2018/12/31/2018-booklist/</url>
    <content><![CDATA[<p>今年的个人状态要比去年好多了，好在心态的逐渐平和。毫无疑问，今年要比去年忙很多，工作和生活都是如此，不过事情也开始越来越聚焦，大概是一种越来越明白自己在做什么以及为什么要这样做的状态。</p>
<p>回到「书单」的正题。在<a href="http://maples7.com/2016/12/31/2016-booklist/">之前的年终书单总结</a>中，我说过一般用 iPad 看电子书，今年引入了一个新设备 —— <a href="https://www.amazon.com/All-new-Kindle-Paperwhite-Waterproof-Storage/dp/B07CXG6C9W">Kindle PaperWhite 4</a>（官方名称是 “All-new Kindle Paperwhite”），这是目前为止最轻的一款 Kindle。之前我一直不理解用 Kindle 看电子书比用 iPad 看电子书好在哪里 —— 忍受着上世纪电子设备的响应速度，使用着非常有限的功能，就为了墨水屏？不用不知道，在真正使用了 Kindle 之后我发现，所有的「轻薄」、「有限的功能」、「电子墨水屏」等特性，都是为了让你在阅读时更加专注 —— 避免打扰、减少疲劳感。从中我体悟到一个道理，任何细微而又专注于目标的优势都不应该被忽视，它可能是一个产品制胜的关键。Kindle 所有的设计都是为了「阅读」这一场景而设计，尽管 iPad 有着丰富得多的功能，但对于体验敏感的用户来说，在「阅读」这件事情上还是会为了用户体验而买一个 Kindle。细小而专注的优势，很重要，不仅仅适用于电子设备产品，也适用于每一件事、每一个人本身。</p>
<span id="more"></span>

<p>废话先不多说，还是按老规矩先列今年看过的书的书单。</p>
<ol>
<li><p><a href="https://www.zhihu.com/pub/book/19550356">设计之美</a>：★★★☆<br>前言写得是真好，整本书写得最好的部分也是前言。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26320659/">万物生长</a>：★★★★<br>冯唐的文字远比<a href="https://zh.wikipedia.org/wiki/%E7%8E%8B%E5%B0%8F%E6%B3%A2">王小波</a>的瑰丽绚烂，像被一个习惯了炒食堂大锅菜的师傅炒出的菜，加足了各种重口的佐料，分明就是他自己前不久写的那篇在朋友圈疯转的文章所说的「油腻」。<br>被称为「某某第二」的人永远不能成为「某某」，也永远达不到世俗意义上「某某」的高度，这一点，几乎是一条铁律。号称「王小波第二」的冯唐永远也成不了王小波，是因为他的文字看不到王小波能看到的东西，技巧十足，却没有让人想去细细揣摩的深意。<br>然而这个世界上没有谁需要去成为谁，冯唐不必易老，照样会让世界变得更丰富。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26943161/">未来简史：从智人到智神</a>：★★★★<br>第一部分基本是在重复<a href="https://book.douban.com/subject/26953606/">《人类简史》</a>的观点；第二部分写得比较有意思，把人文主义主导世界的现实情况剖析得鞭辟入里；第三部阐述了数据宗教的概念，基本也没有什么新东西。<br>预言未来当然比叙述历史要难很多，没有《人类简史》那么脉络清晰且具有说服力，不过书中的很多观点都是值得了解的。</p>
</li>
<li><p><a href="https://book.douban.com/subject/27085265/">北京，北京</a>：★★<br>「年轻人没了幻想，一不小心就俗了」；<br>作家要是没了追求，文字一不小心就俗透了。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25881855/">大教堂与集市</a>：★★★★☆<br>可以和<a href="https://book.douban.com/subject/26358448/">《人月神话》</a>一起看。<br><a href="https://en.wikipedia.org/wiki/Fred_Brooks">Brooks</a> 证明了「人月」在软件工程领域的非线性叠加性，而 <a href="https://en.wikipedia.org/wiki/Eric_S._Raymond">Eric S.Raymond</a> 则告诉我们「开源」大概是破局的唯一方式。<br>这部二十多年前写就的作品在如今看来也毫不过时，甚至书中的一些预言都一一应验。开源运动绝对是上世纪末以来黑客们最伟大的宗教活动。</p>
</li>
<li><p><a href="https://book.douban.com/subject/27070488/">围城</a>：★★★★★<br>钱钟书太厉害了，把人物形象简直刻画得惟妙惟肖，个个都像是生活中栩栩如生的样子。<br>一个围城，围住了中国人的人情、世俗、琐碎与人生的苍凉。<br><a href="https://zh.wikipedia.org/wiki/%E9%9F%A9%E5%AF%92">韩寒</a>的所谓<a href="https://book.douban.com/subject/24697636/">《三重门》</a>不及《围城》的 0.01%。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26663519/">MacTalk 跨越边界</a>：★★★☆<br>比前作的干货更少，也看得出对于书本身的内容而言所体现出的作者的野心更少，基本都是些日常感悟和书评。大概已经无需再考虑要证明什么，可以放开手脚写想写的东西。<br>在我所接触到的所有技术人的自媒体当中，不管技术如何，<a href="http://macshuo.com/?page_id=2">池建强</a>和<a href="https://www.zhihu.com/people/tchen/">陈天</a>算是文字写得流畅优美、可读性非常强的两位了。<br>作为枕边读物还行。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26997376/">我是猫</a>：★★★☆<br>简直就是夏目漱石的自嘲式自传。这本书在浮躁的时候是不能读的，只有在悠闲的时候静下心来慢慢跟随「猫」的视野，才能感受到作为一个旁观者的乐趣。跟《围城》的写作手法和主旨其实有一些类似，但可读性并没有那么高，独特的视角也是本书的特色之一吧。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26984868/">神奇动物在哪里（原创电影剧本）</a>：★★★★<br>看完电影再看剧本画面简直扑面而来，第一部无论是剧本还是电影都很不错啊，好奇<a href="https://movie.douban.com/subject/26147417/">第二部</a>的剧本到底是怎么样的，至少从电影的观赏程度上肯定不如第一部，当然也有可能第二部的定位就是为了挖大坑。<br>不过呢，出版的剧本其实并不是为了拍电影工作的原始剧本，而是根据已上映电影内容的再编辑，这样看估计出版的剧本也不会很好了。<a href="https://www.jkrowling.com/">罗姨</a>的确是应该找个专业剧作家一起合作啊。</p>
</li>
</ol>
<p>今年看完的书差不多就是这样了，另外我是那种齐头并进看多本书的类型，每天看心情选择一本想看的书，投入也开心。而书单只会列出在当年看完的书，那些可能看了一半的书不好评价故不在此列，有些书甚至可能会持续一两年还没看完，但最终基本还是会有所了结。以后我也会慢慢把所有在看的书都转移到 Kindle 上去。</p>
<p>2018 年年初其实制定了一个非常高难度的计划，实现了其中最核心的部分，我个人觉得是幸运且满足的。2018 年似乎也是一个大环境非常不好的一年，「经济衰退」、「资本寒冬」在 2018 年的冬季被各种媒体频频提起，这似乎让 2019 更加让我期待，因为那意味着更加强烈的变化。变化和起落才是世界的真相，而太多人对自我、对世界有太大的误解，对人性和环境有太高的期待，太执拗于自我而丧失了格局。这也是今年我自我感觉更成熟的地方之一，经历得更多也越来越包容，接受各种各样的不同、缺憾、丰富和可能性，但同时也有了更坚定的自我意识。</p>
<p>另一个今年值得一提的收获是开始探索了一个全新的领域并乐在其中，这也是一个很可能对人生有很大影响的领域。我一直推崇「顿悟」式的习得方式，因为大部分事后复盘看起来比较重要的「获得」其实都非常偶然，可遇不可求，不管这背后的原因是来自于你长期的努力和平时的积累、目前所到达的境界和眼界还是纯粹的运气，就在那一刻，不多不少，不紧不慢，你突然有所发现，打开了新世界的大门。这背后个人努力对最终结果起到了多大的作用，并不好说。「偶然」也是世界的一种真相和常态，很多人对此也有很大的误解。作为人类我们唯一能做的，只能是尽可能多的去了解一些不一样的东西，以求能更贴近真相一些。</p>
<p>2019 年，我希望我可以更纯粹、更极致、更理想主义，坚定自我，从心所欲，也用更开放的胸怀和包容的态度待人接物，年度书单还将一直继续下去。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>东北的冬</title>
    <url>/2019/02/05/winter-of-north-east/</url>
    <content><![CDATA[<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2019/02/05/5c5981f5ee873.jpg" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2019/02/05/5c598233d3831.jpg" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2019/02/05/5c59825ebeeef.jpg" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2019/02/05/5c5982bbbc951.jpg" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2019/02/05/5c5982e2aac4d.jpg" /></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-original="https://i.loli.net/2019/02/05/5c59830583ea1.jpg" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2019/02/05/5c59829a17feb.jpg" /></div><div class="group-picture-column"><img data-original="https://i.loli.net/2019/02/05/5c5983059de98.jpg" /></div></div></div>

<span id="more"></span>

<br />

<p>图片已经过裁剪与压缩。</p>
]]></content>
      <categories>
        <category>视觉动物</category>
      </categories>
      <tags>
        <tag>Sony DSC-RX100</tag>
        <tag>东北</tag>
        <tag>雪</tag>
        <tag>林海</tag>
      </tags>
  </entry>
  <entry>
    <title>心知天气数据 API 产品的高并发实践</title>
    <url>/2019/05/09/high-concurrent-validity-4-api-in-seniverse/</url>
    <content><![CDATA[<p><a href="https://www.seniverse.com/">心知天气</a>作为国内领先的商业气象服务提供商，天气数据 API 产品从公司创立以来就一直扮演着很重要的角色。2009 年 API 产品初次上线，历经十年，我们不断用心迭代，已经为数百家企业客户提供了超过 540 亿次稳定可靠的数据服务。在心知天气<a href="https://www.seniverse.com/">官网首页</a>一直跳动的调用量数字就实时展示了整个天气 API 产品的服务状态。目前，心知天气数据 API 的 QPS 在高峰时期已经达到数千的量级，如何承载这样海量的并发请求，使客户能稳定及时的获取到所需数据自然也是心知技术团队一路以来不断探索的主题。</p>
<img data-src="/uploads/seniverse-index.gif" class="" title="心知天气 API 服务实时访问量" alt="图片显示错误">

<span id="more"></span>

<h2 id="访问量特点"><a href="#访问量特点" class="headerlink" title="访问量特点"></a>访问量特点</h2><p>天气数据的基本属性和客户本身的业务需求决定了客户来如何调用我们的数据接口。对于部分使用我们数据进行数据展示的 2C 业务的客户而言，访问量潮汐跟人的行为规律有着明显的相关性，这大致表现为白天比晚上并发量更高；而对于部分使用天气数据做数据分析和研究或者其他需要批量请求天气数据的客户而言，他们大多会选择在整点时刻来批量请求不同的数据，所以整点时刻往往会有突发的高峰访问量。</p>
<p><img data-src="https://i.loli.net/2019/04/18/5cb885ced4a0b.png" alt="API 数据服务访问量特点"></p>
<p>在叠加了不同客户需求的总体 API 服务的访问量，可以看出以下几个特点：</p>
<ul>
<li>以「天」为单位周期性明显</li>
<li>每天零点时刻并发量会激增</li>
<li>整点和半点时刻存在高并发小周期</li>
</ul>
<p>只有了解了我们客户的需求特点，才能设计出更合适的技术架构来应对随之而来的挑战。</p>
<h2 id="石器时代"><a href="#石器时代" class="headerlink" title="石器时代"></a>石器时代</h2><p>在创业初期，「云计算」的理念开始兴起，创始团队在斟酌优劣之后，选择将整个系统构建于云服务提供商<a href="https://www.aliyun.com/">阿里云</a>之上，如此一来心知天气团队也不必自己再手工搭建和管理需要的硬件资源，这对于创业公司而言是一个不错的选择。和大多数早期创业公司一样，囿于资源和技术积累，最早我们也是将 API 服务实例直接部署在<a href="https://cn.aliyun.com/product/ecs">阿里云 ECS</a> 之上，对外通过<a href="https://www.aliyun.com/product/slb">负载均衡 SLB</a> 提供统一的 API 入口。</p>
<p>随着心知天气数据服务体验的不断完善，客户数量也不断增多，API 服务所需要承载的流量也持续上涨。由于我们已经构建了上述这样的基础架构体系，在并发量最高的时期，我们需要手工维护高达 40 台左右的 ECS。而每个 ECS 上有自己独立但不完全一致的运行环境，不管是应对访问量突变还是部署新的版本，都无法做到比较快速的响应和执行。</p>
<p>在这个阶段，我们产品的 API 数据和逻辑都还比较简单，所有关于用户信息处理、位置服务和数据处理的逻辑都揉杂在一个单体服务中，最终部署时也是一个一个独立的单体式架构通过 SLB 共同对外提供服务。</p>
<h2 id="青铜时代"><a href="#青铜时代" class="headerlink" title="青铜时代"></a>青铜时代</h2><p>随着心知天气数据种类的不断增多，数据处理和 API 服务的逻辑也变得各不相同，比如城市级数据和公里级网格数据就有着完全不一样的处理和取数逻辑。在这种情况下，基于程序的可维护性考虑，我们很快决定根据数据处理逻辑的不同将数据服务拆分为几个不同的微服务，各自对外提供不同的天气数据 API。而为了复用取数之前的权限校验、访问量和各种日志统计的逻辑，我们开始引入网关系统。</p>
<p>API 网关最重要的是性能和稳定性要足够好，所有的 API 请求都需要经过网关。在通过网关的校验之后，数据服务负责获取需要的天气数据，其结果再通过网关返回给外部用户。如此一来，不同的几个数据服务退化成无状态的纯数据服务，即每个数据服务节点不再考虑任何与用户相关的逻辑，只是简单的根据请求条件将所有处理好的数据从存储系统中取出后返回，网关作为唯一的请求入口来统一处理所有的权限校验和访问量、日志的各种统计。</p>
<p>基于<a href="https://konghq.com/">开源的网关系统 Kong</a>，我们使用 Lua 进行了大量的二次定制开发，从而形成了心知天气自己的一套网关体系。这套系统不仅满足网关基本的路由逻辑，还能更好的处理和我们自身业务深度耦合的用户权限校验、访问量统计以及以用户为核心的日志记录。Kong 天生也是支持集群的，所以在理论上我们可以无限横向扩展网关的处理能力。</p>
<p>在这样的架构之下，心知天气的 API 服务很好的遵循了<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99">「单一职责」的原则</a>，使得我们的代码维护和版本更新都能以更快速且代价更小的方式进行。但另一方面，我们还是需要手工维护大量的 ECS 集群，甚至由于天气数据服务的多样化，手工维护多个不同种类服务的集群将面对更繁重的挑战。不过，由于我们将服务进行了更好的拆分和分层，变成了一个个更小的微服务，使得我们能把它们进行更好的分布式部署，进而可以横向扩展来提高整个服务集群处理并发请求的能力。这一阶段既是我们成功向微服务架构的转变阶段，也可以看作是我们迈向更现代的后端架构的过渡阶段。</p>
<h2 id="黄金时代"><a href="#黄金时代" class="headerlink" title="黄金时代"></a>黄金时代</h2><p><a href="https://pivotal.io/cloud-native">Cloud-Native</a> 的概念是 2015 年被首次提出的，随后就获得了技术社区的大量关注。顺着之前架构演进的思路，我们很快开始用 Cloud-Native 的理念来武装整个后端系统架构。在去年，我们正式开始用 <a href="https://www.docker.com/">Docker</a> 和 <a href="https://kubernetes.io/">Kubernetes</a> 来改造和管理我们所有对外的线上服务，这些架构设计同时也与阿里云提供的云服务深度结合。</p>
<p>从网关到数据服务，目前我们都已经完成了容器化的改造，并且所有服务都使用 Kubernetes 来编排和管理，这意味着我们真正统一了各个服务的运行时环境，从而可以快速复制出新的服务节点。借助 Kubernetes，我们现在可以做到容器级别的自动伸缩，在并发量高的时候服务节点能够自动横向扩展以提高整个集群的并发处理能力，进而可以给用户提供更加优质稳定的天气数据 API 服务。</p>
<p>不仅如此，基于 Cloud-Native 的理念，我们还统一了各个服务的 <a href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88">CI（持续集成）</a> 流程，优化了 <a href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a> 的体验，做到所有服务的标准化和归一化 —— 从此以往，万物皆容器。这对于今后产品的持续高效迭代和改进，也是有重大意义的。</p>
<p><img data-src="https://i.loli.net/2019/05/09/5cd3d76bb42c6.png" alt="心知天气数据 API 产品的高可用之路"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>心知数据 API 产品历经十年，其后端架构也逐渐从传统的企业应用的开发模式转变为现代的 Cloud-Native 应用的开发模式，不仅极大的解放了团队的产品开发效率，而且能对外提供更加优质稳定的数据服务。心知天气从创立之初就带着鲜明的互联网风格，我们崇尚极客文化，技术团队也将继续带着勇于探索和敢于挑战的极客精神，用更好的技术与更优质的产品，为我们的客户提供更具价值的产品。</p>
<p><strong>【本文由多人协作完成，版权归<a href="https://www.seniverse.com/">心知天气</a>所有，转载需联系<a href="mailto:hi@seniverse.com?subject=文章转载授权申请">心知天气</a>获取授权】</strong></p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>系统架构</tag>
      </tags>
  </entry>
  <entry>
    <title>把 Airflow 搬进 Kubernetes</title>
    <url>/2019/12/03/develop-etl-via-airflow-on-k8s/</url>
    <content><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>稳定高效的进行数据处理几乎是如今每一家互联网公司都要面临的课题，尤其是对于<a href="https://www.seniverse.com/">专注于气象数据研究的我司</a>而言，做数据分析和 <a href="https://zh.wikipedia.org/wiki/ETL">ETL</a> 的工作是整个公司业务很重要的一部分。在脱离了原始的「刀耕火种」的时代之后，我们内部一直在使用 <a href="https://airflow.apache.org/">Airflow</a> 作为数据处理流程的框架来管理日常的数据流任务。其实我们也调研了很多其他的方案，最后还是选定了看起来相对比较可靠也比较符合我们业务需求的开源项目 Airflow 来做这个事情，虽然在使用的过程中确实也遇到了不少坑。当时这个项目还在 <a href="https://zh.wikipedia.org/wiki/Apache_Incubator">Apache Incubator</a>，目前已经顺利毕业了。</p>
<p>简单介绍一下 Airflow，一般由 WebServer（一套完整的 UI 界面用于随时查看任务的执行状态并可以手动执行一些操作）、Scheduler（用来做任务的调度和管理）、Worker（真正执行任务的部分，可能有很多个）组成。这是一个常见的分布式架构，你只需要把任务流的 <a href="https://airflow.apache.org/concepts.html#dags">DAG</a> 用 Python 代码写好，然后配置好触发条件就可以让它长期运行下去。在实际生产环境中，我们大量使用了 <a href="https://airflow.apache.org/howto/executor/use-celery.html">Celery Executor</a> 来把任务动态分布到多个 Worker 上执行。</p>
<span id="more"></span>

<p>如果数据处理任务长期不变，这样的系统已经可以满足我们的需求了。但实际上随着越来越多的数据任务被添加到整个系统，任务负载变得越来越重，很多时候固定数量的 Worker 已经不能及时的处理完被 scheduled 的任务，造成任务队列堆积，一段时间后如果一直不能改善负载情况甚至会拖垮整个系统。这种情况下，只能手动增加更多的 Worker 来分担任务处理工作。然后不同类型的数据处理越多，Worker 所需要安装的依赖也越多，每手工增加一个 Worker 的成本也越来越高。甚至对于气象数据的处理而言，有很多非常古老的数据处理工具（很多还是 Fortran 写的），经常出现依赖相互冲突的情况（版本冲突，编译通不过等等）。如何隔离各个任务之间的运行环境，以及如何根据负载需求动态的伸缩 Worker 的数量日益成为了这个系统的一个痛点。</p>
<p>动态伸缩，环境隔离，自然让人联想到 <a href="https://www.docker.com/">Docker</a> 和 <a href="https://kubernetes.io/zh/">Kubernetes</a> 这样的技术。好在 Airflow 1.10 版本引入了 <a href="https://airflow.apache.org/kubernetes.html">Kubernetes Executor 和 Kubernetes Operator</a> 允许为每一个任务创建新的 Pod 来处理，而执行完之后新创建的 Pod 会被清理掉，并且每一个任务都可以指定不同的 Docker image 来处理，这样看起来就可以完全解决我们前面的问题。</p>
<p>目前这部分功能似乎还很不稳定，官方文档和讨论都还不多，这篇博客也是为了记录下我们的踩坑过程。</p>
<h2 id="在-Kubernetes-上搭建-Airflow"><a href="#在-Kubernetes-上搭建-Airflow" class="headerlink" title="在 Kubernetes 上搭建 Airflow"></a>在 Kubernetes 上搭建 Airflow</h2><p>我们使用 <a href="https://helm.sh/">Helm</a> 来管理在 Kubernetes 上个各个应用以及它们的依赖，目前官方也已经给出了 <a href="https://github.com/helm/charts/tree/master/stable/airflow">stable&#x2F;airflow 的 Chart</a>，我们可以直接使用或部分参考。下面我们介绍一下从零开始的搭建过程。</p>
<ol>
<li><p>安装 Kubernetes</p>
<p>本地安装的可以选择 <a href="https://kubernetes.io/docs/tasks/tools/install-minikube/">Minikube</a>，主要它解决了跨平台的问题。我在 macOS 上使用的是 <a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac">Docker Desktop for Mac</a> 里<a href="https://www.docker.com/blog/docker-mac-kubernetes/">自带的 Kubernetes 集群</a>，如果你安装遇到了问题可以看看<a href="https://github.com/gotok8s/k8s-docker-desktop-for-mac">这里</a>是不是解决了你的问题，或者自行 Google 也可。</p>
</li>
<li><p>安装 Helm</p>
<p>Helm 3 已经是正式的稳定版本，可惜我们线上还在使用 Helm 2，而 Helm 2 的版本不兼容是没法使用的。为了跟线上保持一致，我本地也是安装的 Helm 2，所以后面都是以 Helm 2 的操作来执行的，第一次进行的朋友可以直接用 Helm 3。当然安装过程也<a href="https://github.com/helm/helm/issues/4730">很可能出现问题</a>，可以自行 Google 解决。</p>
</li>
<li><p>在 Kubernetes 上用 Helm 安装 Airflow Chart</p>
<p>直接根据<a href="https://github.com/helm/charts/tree/master/stable/airflow">官方的 Airflow Chart</a>步骤执行 <code>helm install --namespace &quot;airflow&quot; --name &quot;airflow&quot; stable/airflow</code> 即可在 Kubernetes 上安装一个标准的 Airflow 集群，之后可以查看各个 Pod 的状态是不是已经 ready（一切正常的情况下会在 <code>airflow</code> 的 Namespace 下安装 airflow-web、airflow-scheduler、airflow-postgresql、airflow-flower、airflow-redis）。还可以根据 NOTES 的提示在浏览器中查看 Airflow 的 UI 界面是不是也启动良好：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NOTES:</span><br><span class="line">Congratulations. You have just deployed Apache Airflow</span><br><span class="line">   export POD_NAME=$(kubectl get pods --namespace airflow -l &quot;component=web,app=airflow&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)</span><br><span class="line">   echo http://127.0.0.1:8080</span><br><span class="line">   kubectl port-forward --namespace airflow $POD_NAME 8080:8080</span><br><span class="line"></span><br><span class="line"> Open Airflow in your web browser</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据自身业务情况自定义一些配置</p>
<p>之后可以根据 Helm 的 官方 Airflow Chart 提供的配置方式进行一些自定义配置，比如把默认的 Airflow 镜像 <code>puckel/docker-airflow</code> 替换成自己根据自身业务需求构建的（比如已经安装了实现业务需求所有必要底层依赖的 Airflow 镜像，或者对于 Kubernetes Executor and operator 必需的 <code>apache-airflow[kubernetes]</code>，这样就不用每次部署更新都安装这些依赖了）、更改 <code>executor</code> 的类型（我们改为 <code>Kubernetes</code>）等等。官方的 Chart 目录下也提供了<a href="https://github.com/helm/charts/blob/master/stable/airflow/examples/minikube-values.yaml">一个例子</a>可供参考。</p>
<p>值得额外注意的是我们如何做数据的持久化。这既包括 DAGs、日志 logs，也包括 Airflow 的运行态数据 —— 存储在 Postgres 或 MySQL 中的数据 —— 如何持久化。官方的 README 对此<a href="https://github.com/helm/charts/tree/master/stable/airflow#dags-deployment">已经有介绍</a>，同样如果有额外的自定义配置直接写到我们自己的 <code>values</code> YAML 文件中即可。<a href="https://github.com/apache/airflow/blob/1.10.6/airflow/config_templates/default_airflow.cfg"><code>airflow.cfg</code></a> 中 <code>[kubernetes]</code> 对应的每一项配置也应该过一遍并做相应的修改，尤其是关于 <code>namespace</code> 和 <code>dags_in_image</code> 的部分。对我司而言，我们自己的 Kubernetes 集群运行在阿里云上，直接使用一个外挂的 NAS 作为 DAGs 和 logs 的共享存储即可（通过 <code>extraVolumeMounts</code> 和 <code>extraVolumes</code> 挂载和声明，也要注意跟 <code>dags.path</code> 路径保持一致），以后我们自己开发的 DAGs 可以直接通过 CI&#x2F;CD 更新到 NAS 上相应的目录。数据库采用一个已经存在的外部 Postgres。</p>
<p>假设我们将自定义的 <code>values</code> 配置写成 <code>minikube-values.yaml</code> 的本地 YAML 文件，就可以用 <code>helm install --namespace &quot;airflow&quot; --name &quot;airflow&quot; stable/airflow -f minikube-values.yaml</code> 启动一个经过自定义修改后的 Airflow 集群（可以先把之前启动的集群通过 <code>helm delete --purge &quot;airflow&quot;</code> 清除）。</p>
</li>
</ol>
<p>因为业务需求和基础设施现状的不同，中间可能有不同的架构选择，但总体上经过这几步之后，一个采用 <code>KubernetesExecutor</code> 并运行在 Kubernetes 上的 Airflow 集群就基本搭建好了。</p>
<h2 id="开发-DAGs"><a href="#开发-DAGs" class="headerlink" title="开发 DAGs"></a>开发 DAGs</h2><p>参考 Airflow 官方文档中 Kubernetes Operator 的例子可以开发适用于自身业务需求的 DAG。之后就可以访问 Airflow WebServer 来开启相应的 DAG 任务，并观察集群中 Task 的运行行为是否与预期的一致，并逐步迭代。</p>
<h2 id="悄悄告诉你，真相其实是这样……"><a href="#悄悄告诉你，真相其实是这样……" class="headerlink" title="悄悄告诉你，真相其实是这样……"></a>悄悄告诉你，真相其实是这样……</h2><p>实际上，在经过我的一番折腾之后，最终我们线上使用的版本并没有使用官方的 Helm Chart，而是完全基于我们自己 build 的 Airflow 镜像，从头搭建了我们自己的 Helm Release Chart，这样整个系统拥有最高的可定制度（有些问题不在代码层面定制根本没法绕过去，下文有详述），同时也剔除了很多 Helm 官方 Chart 里有但我们不需要的东西。跟官方的 Chart 相比，我们主要做了这些更改：</p>
<ul>
<li><p>没有使用 Airflow 官方的 Kubernetes Executor，而是自己继承 <code>LocalExecutor</code> 类定制我们自己的 <code>KubeExecutor</code>，实际做的事情也很简单，就是实际在执行任务的时候不直接像 <code>LocalExecutor</code> 那样在本地执行命令，而用 <code>kubectl</code> 把任务指定在某一个 Worker Pod 或使用了 <code>KubernetesPodOperator</code> 启动的临时 Pod 里运行。这样做主要考虑的是官方的 <code>KubernetesPodOperator</code> 为了一些通用性功能从而进行了较为复杂的流程设计，我们团队自身完全可以结合在阿里云里 Kubernetes 集群的具体特点改造 <code>LocalExecutor</code>，这样不仅在运行时可以节省更多的机器资源，而且对于我们最核心的需求 —— 稳定的生产数据 —— 来说是更有利的，毕竟在运行时动态操作 Kubernetes 集群资源的流程变得简单了很多。</p>
</li>
<li><p>阿里云还有一个很大的坑是在它上面构建的官方 Kubernetes 集群产品不提供阿里云的 CA 根证书校验，而 <a href="https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/#directly-accessing-the-rest-api-1">Kubernetes 官方明确指明了需要校验 CA bundle</a>，导致我们无法通过 API 与 Kubernetes Server 进行交互，进而在使用 <code>KubernetesPodOperator</code> 时会因为证书校验失败而无法创建 Pod。而 <code>KubernetesPodOperator</code> 也并没有提供参数让我们将 <code>verify_ssl</code> 设置为 False。所以最终我们也没有直接用官方的 <code>KubernetesPodOperator</code>，而是自己改了一个类似的把 <code>verify_ssl</code> 设置为 False 的 Operator 的版本来使用。同时这里也呼吁一下阿里云能按照技术社区标准来提供自己的技术服务与产品（我们提了工单 argue 这个事情，最终客服给我提供了根证书并叮嘱不要扩散，并不清楚阿里云不能对外公开根证书是基于什么样的考量；在其他项目中我们使用了客服提供的根证书来进行校验是没有问题的）。</p>
</li>
<li><p>去掉了不必要的通用型适配的各种选择，完全按自身需求合理定制。</p>
</li>
</ul>
<p>虽然我们做了定制，需要考虑的一些核心问题是没有变的，它们是：如何共享 DAG 的 Python 代码、如何做日志和数据库数据的持久化、是否使用 <a href="https://airflow.apache.org/docs/stable/concepts.html?highlight=xcom#xcoms">XComs</a> 来做 Task 之间的消息通信（同时在集群环境下如何实现这一点）、如何注入依赖（官方 Helm Chart 的 <code>requirements.txt</code> 方式）等等。由于这个尝试和定制的过程着实复杂和不那么让人愉快，甚至需要阅读一些 Airflow 的源码和各个云服务组件的接口参数设计，所以一篇博客无法一一详尽，我自己也不想写那些我们是如何绕过由于各方面的设计缺陷或开源产品不稳定导致的问题的技术细节，它们可能时刻会变，也没有技术深度，更多的是枯燥的云服务运维细节，所以不会在这里赘述太多而分散更大层面的宏观框架上的注意力。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在我们实际使用的过程中其实还遇到了很多 Airflow 的坑，作为一个 Apache 基金会的开源项目，它确实弥补了 ETL 场景下工具和框架的缺失，也提供了非常丰富的功能，不过尽管目前版本号已经到了 1.10.6，但还是有很多明显可感知的 BUG 存在，实际的使用感受是能用但总存在一些小问题，偶尔对任务的调度和管理还可能会失灵，不那么可靠，不算是一个高质量的开源项目，所以在使用时加上适当的重试机制是很有必要的。不过目前社区里在这部分并没有更好的替代品，Airflow 已经是我们考查过的最契合管理 ETL 流程的框架了。如果有新的开源项目能弥补这方面的空缺我们会很乐意去尝试，我们自己团队也在考虑是否在更长期的计划中开发一套自己的 ETL 流程框架。</p>
<p>几周不断折腾尝试的搭建、使用和实际开发的过程下来，其实涉及了很多开发<a href="https://pivotal.io/cloud-native">云原生服务</a>常用的 DevOps 工具和组件，比如 Helm、Kubernetes 和 Docker，能得心应手的使用这些工具需要一段时间的学习实践来积累知识和经验。要想在 Kubernetes 环境下玩转 Airflow，了解这些周边支撑的工具也是不可或缺极其重要的一部分。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Airflow</tag>
        <tag>Kubernetes</tag>
        <tag>Helm</tag>
        <tag>DevOps</tag>
        <tag>Cloud-Native</tag>
      </tags>
  </entry>
  <entry>
    <title>Elixir 代码性能优化指北</title>
    <url>/2019/12/05/elixir-code-performance-optimization/</url>
    <content><![CDATA[<p>Elixir 作为基于 Erlang&#x2F;OTP 的年轻语言，拥有良好的并发模型设计，在 Web 场景下对于实现能承载高并发的服务毫无问题。有好事者<a href="https://github.com/mroth/phoenix-showdown">对比过包括 Phoenix 在内不同的 Web Framework 的性能</a>，可见如果采用 Phoenix&#x2F;Plug 来实现 Web Server 在性能上不会有太大的问题（代码实现良好的情况下）。所以，本文不会讨论真正的工业生产环境下整个系统的性能状态，因为系统性能受到很多因素的影响，具体编程语言的运行时的执行效率往往不是真正的问题所在，与其考虑编程语言本身的运行时效率，不如探讨系统在具体架构和实现上如何能优化来承载更高的负载来得实际。在生产环境中，我们可以借助 <a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86">APM</a> 服务来监控系统状态和性能指标。</p>
<p>由于 Elixir 本身是基于 Erlang 的更高层次的抽象，所以直觉上我们会觉得 Elixir 在运行性能上应该比 Erlang 本身要差一些。实际情况是不是这样呢？Elixir 相比于 Erlang 而言，为我们提供了一些可以快速调用的高阶函数库，典型的有 <a href="https://hexdocs.pm/elixir/Enum.html"><code>Enum</code></a>、<a href="https://hexdocs.pm/elixir/Stream.html"><code>Stream</code></a>，提高了日常实现需求的开发效率，可以让代码实现得更清晰且更易维护。而更高的抽象又几乎必然意味着底层的实现逻辑需要更通用健壮，从而也会更复杂。更高的抽象程度似乎天然与更高的运行效率有着内在的矛盾。本文的焦点在 Elixir 代码的运行性能，即对于实现同样的功能，用哪样的 Elixir 实现方式会让代码在运行时跑得更快。</p>
<span id="more"></span>

<p>接下来会拿我在刚接触 Elixir 时实际开发过程中真实写出来的代码来举例如何进行优化，相信不少 Elixir 新手会跟当时的我一样或多或少犯类似的错误。源代码可以在这里找到：<a href="https://github.com/seniverse/ex_fieldmask">ex_fieldmask - GitHub</a>，通过项目的提交历史也可以看到我的修改过程，整个代码才一百多行，改动也都很简短，非常适合举例。这个库实现的需求是用简单的字符串解析的方式来实现类似 <a href="https://developers.google.com/youtube/v3/getting-started#partial">Google+&#x2F;YouTube API 中的 Partial Responses</a> 的语法和功能。我会以这个代码仓库中的例子来举例能明显改善 Elixir 运行性能的实现改进，其他不会明显改善性能但是也会让代码更优的改动也会稍微提一下。我们从提交历史中从前往后挑选一些值得一提的 commits 来一一解说。</p>
<ul>
<li><p>判断值时，用 <code>case</code> 替换 <code>cond</code>：<a href="https://github.com/seniverse/ex_fieldmask/commit/913be4225298d9ef90f34727108d737ea5d7701c">commit <code>913be42</code></a>。</p>
<p>改动前：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cond</span> <span class="keyword">do</span></span><br><span class="line">  keys === [] -&gt; data</span><br><span class="line">  keys === [<span class="string">&quot;*&quot;</span>] -&gt; ......</span><br><span class="line">  <span class="literal">true</span> -&gt; ......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>改动后：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> keys <span class="keyword">do</span></span><br><span class="line">  [] -&gt; data</span><br><span class="line">  [<span class="string">&quot;*&quot;</span>] -&gt; ......</span><br><span class="line">  _ -&gt; ......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：能用 <code>case</code>（或函数子句）的就不要用 <code>cond</code>。<code>cond</code> 适用于多个独立的表达式求值判断真假的情况，它需要从上至下对每个表达式求值直到遇到第一个值为「真」的分支。在这里，我们全部是关于 <code>keys</code> 的简单比较，显然用 <code>case</code> 直接模式匹配会是更优的实现。<code>cond</code> 里的 <code>true</code> 的 fallback 分支在 <code>case</code> 里可以用 <code>_left</code> 来对应变更用于匹配任意项。</p>
</li>
<li><p>函数用一个完整的 Pipeline 串联来提升可读性：<a href="https://github.com/seniverse/ex_fieldmask/commit/3e610d80b69be0015e376273806df9711427e701">commit <code>3e610d8</code></a>，其他类似的改动还有 <a href="https://github.com/seniverse/ex_fieldmask/commit/fa039386be8b953e8ec927408a880301fc5283cb">commit fa03938</a>。</p>
<p>改动前：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reveal</span></span>(tree, data) <span class="keyword">when</span> is_map(tree) <span class="keyword">do</span></span><br><span class="line">  keys = Map.keys(tree)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> keys <span class="keyword">do</span></span><br><span class="line">    [] -&gt; data</span><br><span class="line">    [<span class="string">&quot;*&quot;</span>] -&gt; ......</span><br><span class="line">    _ -&gt; ......</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>改动后：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reveal</span></span>(tree, data) <span class="keyword">when</span> is_map(tree) <span class="keyword">do</span></span><br><span class="line">  tree</span><br><span class="line">  |&gt; Map.keys()</span><br><span class="line">  |&gt;(<span class="keyword">fn</span></span><br><span class="line">    [] -&gt; data</span><br><span class="line">    [<span class="string">&quot;*&quot;</span>] -&gt; ......</span><br><span class="line">    _ -&gt; ......</span><br><span class="line">  <span class="keyword">end</span>).()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：最后的匿名函数中的参数匹配跟 <code>case</code> 一样也是模式匹配，同样优于 <code>cond</code>，原代码中把 <code>case</code> 改成匿名函数的形式是为了让整个 <code>reveal</code> 函数是一个完整的用 <code>|&gt;</code> 串联起来的 Pieline 而又不失简洁，但性能上并不会明显更优。这样的改动更多是把命令式的代码风格改成函数式的代码风格，Pipeline 的每个部分都是独立无状态的，可读性和可维护性都会有所提升。</p>
</li>
<li><p>List&#x2F;Tuple 直接用模式匹配取值：<a href="https://github.com/seniverse/ex_fieldmask/commit/801ff47c93f4b682bbd2f2997ee23ea7e98b6b6c">commit <code>801ff47</code></a>。</p>
<p>改动前：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">chars = elem(item, <span class="number">0</span>)</span><br><span class="line">delimiter = elem(item, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>改动后：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">&#123;chars, delimiter&#125; = item</span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：同样也是用模式匹配替代使用函数来取值，不仅让代码可以一行解决，而且还会提升性能。如果 List&#x2F;Tuple 很长，而我们只需要提取前面一部分的片段，则又可以使用 <code>_tail</code> 来匹配我们不关心的尾部区域。</p>
</li>
<li><p>匿名函数用 <code>&amp;</code> 改写：<a href="https://github.com/seniverse/ex_fieldmask/commit/c19d49fed10e026b0ccd3cd27a77af8e4b7fa87d">commit <code>c19d49f</code></a>。</p>
<p>改动前：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">Enum.filter(<span class="keyword">fn</span> str -&gt; str !== <span class="literal">nil</span> <span class="keyword">and</span> str !== <span class="string">&quot;&quot;</span> <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p>改动后：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">Enum.filter(&amp;(&amp;<span class="number">1</span> !== <span class="literal">nil</span> <span class="keyword">and</span> &amp;<span class="number">1</span> !== <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：无他，就是代码更简洁了，而且我们不再需要想如何给函数参数命名。<a href="https://martinfowler.com/bliki/TwoHardThings.html">众所周知，命名在编程里是一件很难的事情……</a>（当然，只有在这种函数很简单的情况下值得这样做）</p>
</li>
<li><p>在函数参数中直接匹配复杂数据结构内部的值：<a href="https://github.com/seniverse/ex_fieldmask/commit/9af5145731aacfeac0e6e3826ee4c854c8550d6a">commit <code>9af5145</code></a> 和 <a href="https://github.com/seniverse/ex_fieldmask/commit/456d3d4c4f26919055c18a7d2ff233437530f553">commit <code>456d3d4</code></a>，其他相同原因的改动还有 <a href="https://github.com/seniverse/ex_fieldmask/commit/21b1fee30f439628139f307157341812b52a237d">commit <code>21b1fee</code></a>。</p>
<p>改动前：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">Enum.reduce(&#123;%&#123;&#125;, [], [], <span class="literal">nil</span>&#125;, <span class="keyword">fn</span> token, acc -&gt;</span><br><span class="line">  &#123;tree, path, stack, last_token&#125; = acc</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> token <span class="keyword">do</span></span><br><span class="line">    <span class="string">&quot;,&quot;</span> -&gt;</span><br><span class="line">      <span class="keyword">if</span> List.first(stack) === <span class="string">&quot;/&quot;</span> <span class="keyword">do</span></span><br><span class="line">        &#123;tree, tl(path), tl(stack), token&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        acc</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;/&quot;</span> -&gt;</span><br><span class="line">      &#123;tree, [last_token | path], [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;(&quot;</span> -&gt;</span><br><span class="line">      &#123;tree, [last_token | path], [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;)&quot;</span> -&gt;</span><br><span class="line">      &#123;tree, tl(path), [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">    _ -&gt;</span><br><span class="line">      &#123;put_in(tree, Enum.reverse([token | path]), %&#123;&#125;), path, stack, token&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p>改动后：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">Enum.reduce(&#123;%&#123;&#125;, [], [], <span class="literal">nil</span>&#125;, <span class="keyword">fn</span></span><br><span class="line">  <span class="string">&quot;,&quot;</span> = token, &#123;tree, path, stack, last_token&#125; -&gt;</span><br><span class="line">    <span class="keyword">if</span> List.first(stack) === <span class="string">&quot;/&quot;</span> <span class="keyword">do</span></span><br><span class="line">      &#123;tree, tl(path), tl(stack), token&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;tree, path, stack, last_token&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;/&quot;</span> = token, &#123;tree, path, stack, last_token&#125; -&gt;</span><br><span class="line">    &#123;tree, [last_token | path], [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;(&quot;</span> = token, &#123;tree, path, stack, last_token&#125; -&gt;</span><br><span class="line">    &#123;tree, [last_token | path], [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;)&quot;</span> = token, &#123;tree, path, stack, _&#125; -&gt;</span><br><span class="line">    &#123;tree, tl(path), [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">  token, &#123;tree, path, stack, _&#125; -&gt;</span><br><span class="line">    &#123;put_in(tree, Enum.reverse([token | path]), %&#123;&#125;), path, stack, token&#125;</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：改动前的写法更多的还是在用其他无模式匹配特性的编程语言的思维在写代码，在 Elixir 里，我们可以直接在函数参数中使用模式匹配，不仅简化了步骤让代码变得更简洁，而且也简化了变量个数、少了命名需求。在分支的匹配过程中我们还可以给匹配到的字符串同样用模式匹配 <code>&quot;/&quot; = token</code> 的方式来命名。为什么已经确定的匹配还要用一个新的变量来匹配呢？原因是在分支内部需要多次重复引用 <code>&quot;/&quot;</code>，我们直接用 <code>token</code> 来统一引用即可，小小改动却充分体现了 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don’t repeat yourself</a> 的原则。</p>
</li>
<li><p>用 <a href="https://elixir-lang.org/getting-started/comprehensions.html">List Comprehensions</a> 替换高阶函数的使用：<a href="https://github.com/seniverse/ex_fieldmask/commit/8de1abf59a18829e8e19a33a625f58424e577e3b">commit <code>8de1abf</code></a>，其他类似的改动还有 <a href="https://github.com/seniverse/ex_fieldmask/commit/48afae9357515afbd2111bd412ac4d4cd09f2229">commit <code>48afae9</code></a>。</p>
<p>改动前：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span></span><br><span class="line">  [] -&gt;</span><br><span class="line">    data</span><br><span class="line"></span><br><span class="line">  [<span class="string">&quot;*&quot;</span>] -&gt;</span><br><span class="line">    data</span><br><span class="line">    |&gt; Map.keys()</span><br><span class="line">    |&gt; Enum.map(&amp;[&amp;<span class="number">1</span>, reveal(tree[<span class="string">&quot;*&quot;</span>], data[&amp;<span class="number">1</span>])])</span><br><span class="line">    |&gt; Map.new(<span class="keyword">fn</span> pair -&gt; List.to_tuple(pair) <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">  keys -&gt;</span><br><span class="line">    <span class="keyword">case</span> data <span class="keyword">do</span></span><br><span class="line">      data <span class="keyword">when</span> is_list(data) -&gt;</span><br><span class="line">        Enum.map(data, &amp;reveal(tree, &amp;<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">      data <span class="keyword">when</span> is_map(data) -&gt;</span><br><span class="line">        keys</span><br><span class="line">        |&gt; Enum.map(&amp;[&amp;<span class="number">1</span>, reveal(tree[&amp;<span class="number">1</span>], data[&amp;<span class="number">1</span>])])</span><br><span class="line">        |&gt; Map.new(<span class="keyword">fn</span> pair -&gt; List.to_tuple(pair) <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>改动后：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span></span><br><span class="line">  [] -&gt;</span><br><span class="line">    data</span><br><span class="line"></span><br><span class="line">  [<span class="string">&quot;*&quot;</span>] -&gt;</span><br><span class="line">    data</span><br><span class="line">    |&gt; Map.keys()</span><br><span class="line">    |&gt; (<span class="keyword">fn</span> keys -&gt;</span><br><span class="line">      <span class="keyword">for</span> key &lt;- keys, <span class="symbol">into:</span> %&#123;&#125; <span class="keyword">do</span></span><br><span class="line">        &#123;key, reveal(tree[<span class="string">&quot;*&quot;</span>], data[key])&#125;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>).()</span><br><span class="line"></span><br><span class="line">  keys -&gt;</span><br><span class="line">    <span class="keyword">case</span> data <span class="keyword">do</span></span><br><span class="line">      data <span class="keyword">when</span> is_list(data) -&gt;</span><br><span class="line">        <span class="keyword">for</span> item &lt;- data <span class="keyword">do</span></span><br><span class="line">          reveal(tree, item)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      data <span class="keyword">when</span> is_map(data) -&gt;</span><br><span class="line">        keys</span><br><span class="line">        |&gt; (<span class="keyword">fn</span> keys -&gt;</span><br><span class="line">          <span class="keyword">for</span> key &lt;- keys, <span class="symbol">into:</span> %&#123;&#125; <span class="keyword">do</span></span><br><span class="line">            &#123;key, reveal(tree[key], data[key])&#125;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>).()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：这里性能上是不是真的有优化可能不那么明显。在 Elixir 1.9.1 中我使用 <a href="https://github.com/bencheeorg/benchee">Benchee</a> 做 benchmark 发现 List Comprehensions 确实要比使用 Elixir 提供的高阶函数要快。没有看 Elixir 的具体的实现，但大致揣测 List Comprehensions 在底层是用简单的递归函数实现的，而高阶函数应该做了更多复杂的事情，从逻辑上可以想到的是 <code>Enum/Stream</code> 库需要先处理传入数据结构的 <code>Enumerable</code> 协议的相关要求再用不同数据类型对应的不同逻辑来处理，自然会复杂一些。</p>
</li>
</ul>
<p>总结上来，简单的明显可以改善代码性能的写法其实只有两类：尽可能用模式匹配、用 List Comprehensions 替换高阶函数，其他的只是从其他角度考虑的代码层面的优化。最终我们线上没有使用这个库，因为 <a href="https://github.com/seniverse/fieldmask_benchmark">benchmark</a> 发现直接定义 Partial Responses 的语法，然后用 Erlang 的 <a href="http://erlang.org/doc/man/leex.html"><code>leex</code></a> 做词法分析，再用 <a href="http://erlang.org/doc/man/leex.html"><code>yecc</code></a> 做语法分析生成 <a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">AST</a>，最后遍历 AST 就可以得到做了 mask 的结果，即我们要的 Partial Response。代码同样开源在 GitHub：<a href="https://github.com/seniverse/fieldmask">fieldmask - GitHub</a>，也是一个绝妙的学习 Erlang <code>leex</code> 和 <code>yecc</code> 的例子。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Erlang</tag>
        <tag>Elixir</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 年书单</title>
    <url>/2019/12/31/2019-booklist/</url>
    <content><![CDATA[<p>2019 年对很多人来说似乎是艰难的一年，在这个世界愈发趋于动荡和不信任的大背景下，越来越多的疑惑、迷茫和不确定性从上至下笼罩在每一个人可以感知到的日常生活中。或许只是一种周期，或许就是一种趋势，各种事物的分化与混乱变得越来越明显。如果从热力学第二定律的角度来看，维持事物不走向无序是需要额外付出很多努力的，那说明人类社会目前做的共同有效努力还不够；如果从唯物论的发展观来看，事物总是螺旋式向上发展的，周期中同时也蕴含着一些不可逆的改变。把 2019 年放在历史的长河中，我不知道它处在世界发展周期的哪个部分，但很可能不是在「好」（大部分人认为的世俗意义上的「好」）的那一半。这可能是前些年某些事件的发生导致了现在的局面，同时也可能是未来很长一段时间不同局面的开始。</p>
<p>我所感知到的 2019 年，不算好，但好过 2018 年，因为在 2019 年明显可以看到一些好的发展的希望。事情多不一定会让人感觉到累，但感受不到希望是一定会让人想要逃离的。不过，希望仅仅是一种未来往好的方向发展的可能，当变化越来越快的时候，希望也是越来越脆弱的，希望远不是必然。</p>
<span id="more"></span>

<p>忽视我以上开场想当然的臆测和主观感受，这依然是一篇书单。</p>
<ol>
<li><p><a href="https://book.douban.com/subject/27006467/">浮生六记</a>：★★★★</p>
<p>博客有一个分类是「浮生散记」，是出自沈复的《浮生六记》。</p>
<p>沈复一生困苦却用白描的方式把自己的故事一一记述下来，文采自然、平淡、真切，从中也可以看出他一介浪荡文人性格上的懦弱无能。</p>
<p>喜于与芸娘的几年四处游历、相濡以沫、互相扶持，悲在芸娘一生操劳、心思忧虑、英年早逝。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26997048/">撒哈拉故事</a>：★★★★</p>
<p>仅仅用一个略带嘲讽和贬义的「文青」来形容三毛或三毛的粉丝们是不公平的。三毛写的就是平凡的生活和真实的自我，在世界各地的每个人都有这样的生活，只是不是每个人都能够成为三毛，不是每个人都能写出这样的文字。热爱生活本身，已是足够。</p>
</li>
<li><p><a href="https://book.douban.com/subject/30455321/">流浪地球</a>：★★★</p>
<p>在看电影之前先看了原著，一个短篇基本把宇宙设定和故事框架搭建了出来，但这么点文字不足以支撑整个故事宏大的背景设定，所以人物、情节和要表达的背后的东西都很符号化。不过，也许正是短小且符号化的文学作品利于被 100 分钟左右的影视化表达所改编，如果是<a href="https://book.douban.com/subject/6518605/">《三体》</a>这样的长篇，要改编成一部（系列）成功的电影，难度会大上很多。</p>
</li>
<li><p><a href="https://book.douban.com/subject/6709783/">浪潮之巅</a>：★★★★☆</p>
<p>任何计算机和互联网从业者都应该读的一本书，前后几次再版的内容变化甚至都可以看出近几年行业的变迁与发展（之快）。</p>
<p>关于 Stanford 和硅谷之间的关系的章节尤其赞同，可以说国内所谓的高等教育还没找到门在哪里。</p>
<p>从整个行业历史长河的远景角度下来看，企业宿命论的观点是有道理的，创始人的特质基本上决定公司在世事变迁之中能走到多远。</p>
</li>
<li><p><a href="https://elixirschool.com/zh-hans/">Elixir School</a>：★★★☆</p>
<p>适合入门，但感觉比 Elixir 官网的 start guide 对知识的系统性和章节前后编排的组织合理性要差一些，优点是更偏项目实践，涵盖的面更广。</p>
<p>中文翻译有一些问题，给这个项目提了一些翻译方面的 PR。</p>
</li>
<li><p><a href="https://elixir-lang.org/getting-started/introduction.html">Elixir: Getting started guid + Mix and OTP guide + Meta-programming guide</a>：★★★★☆</p>
<p>官方文档绝对是入门 Elixir 的首选材料，内容编排和话题讲解都恰到好处又直击要害，完全值得多读几遍。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26910174/">上海堡垒</a>：★★★★</p>
<p>中学生科幻文学，前面多半部分是移动互联网时代之前的「高三」风格（比「中二」强一点），之后部分的行文流畅真切了许多，结尾还不错。在外星人入侵的弘大灾难背景下的朴素稚嫩而又执拗的少年情愫，科幻设定不硬，人物描绘质朴，倒是带来些许恍若隔世的违和感，跟江南在《此间的少年》中营造出的猎奇轻狂的趣味感一脉相承而又截然不同。</p>
<p>在同名电影上映之前先看一看原著，又是一部比《三体》更适合影视化表达的作品。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25816940/">富爸爸穷爸爸</a>：★★★★</p>
<p>认清资产和负债的确至关重要，这能让大多数普通人避开「中产阶级陷阱」。拿到当下现实而言，纯粹从财务的角度，那些签下 30 年贷款协议买房的人买下的绝不是资产而是负债。</p>
<p>每个人从大学毕业开始最原始的资产就是自己的工作能力和时间，上班本质上是出卖自己的时间和工作能力来获取货币资产。而财务自由的过程实际上是不断用新的资产形式来置换出卖劳动的过程，最终目标也就是即便不受雇工作也可以靠其他资产产生的收入来负担所有的支出，接下来就只需要不断的滚雪球就可以越来越富有。</p>
<p>一本经典的资产管理入门书，跟之前看过的<a href="https://book.douban.com/subject/26835090/">《软技能：代码之外的生存指南》</a>关于投资的内容遥相呼应、相得益彰。道理其实简单，但能做到的人永远寥寥。</p>
</li>
<li><p><a href="https://book.douban.com/subject/27204860/">指数基金投资指南</a>：★★★★</p>
<p>简直是手把手带领小白入门指数基金定投，有简单的理论也有实践操作，事无巨细，甚至包括了一些记账习惯、健康消费、投资心理等相关的内容，实用性强，内容也很诚恳，很适合零基础开始投资理财的读者。</p>
</li>
<li><p><a href="https://book.douban.com/subject/10471333/">叫魂</a>：★★★★</p>
<p>从小到大就不喜欢看历史书，觉得历史很枯燥，这大概是义务教育阶段历史教材上笼统的描述和专断的结论所熏陶出来的厌恶感。</p>
<p>但这本研究型作品却打破了历史的枯燥形象，看名字会以为内容是些鬼怪之谈，实际上这是一本非常严谨的学术著作。从乾隆年间的一场历史事件深度细腻的剖析了当时社会的状态和事件里各个社会群体及角色的举动和反应，最有意思的部分还是对舞台中央的君臣之间微妙关系的分析以及这背后所展现的官僚君主制的探讨。</p>
<p>作者作为外国学者，更是提供了一些在国内不常见的看待这段历史的视角，以及跟当时西方体制的一些对比分析，写得颇为生动精巧。一本上世纪写就的学术著作，如今看却也一点也不觉得过时。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25897187/">Elixir in Action</a>：★★★★☆</p>
<p>相信绝大部分人的第一门编程语言都不是 Elixir，那这本书就非常适合作为 Elixir 入门的读物。它没有陷于形式和细节，而是非常清晰的把 Elixir 核心和关键的部分由浅入深地勾勒了出来。行文逻辑和章节编排也非常合理，读起来流畅自然，体验非常舒适。简直是 Elixir 必知必会十三章。</p>
</li>
</ol>
<p>今年看的书并不多，但有两个我觉得比较有意思、有意义且也许会对我自己影响深远的事情值得写在这里。</p>
<p>其中一件是我终于汇总和总结了学习 Computer Science 的资源和路径，可以<a href="https://github.com/Maples7/cs-roadmap">在我的 GitHub 上找到这个仓库</a>。学习本身是一件非常私人且定制化程度很高的事情，就像<a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">软件工程里没有「银弹」</a>一样，我从不觉得有适合每个人的最好的学习路径，但我把我觉得最好最合适的一些课程和书籍等资源列了出来。系统的总结出来这件事情本身在大学期间我就应该做了，这些年虽然没有在纸面上写下来，但也一直尽可能遵循这样的路径来系统的学习计算机科学的课程。不过没有纲领就容易丧失节奏，现在做这件事算是补交一下四五年前的作业，同时我自己今后也会更明确的按照这个列表来一步一个脚印的深入学习下去。这可是一个以「年」为单位来审计的大工程，我自己觉得很有意义。</p>
<p>另外一件其实我在<a href="http://maples7.com/2018/12/31/2018-booklist/">去年的书单总结中</a>提到了，但并没有明确说是什么事情。可今年的书单已经暴露了它是什么，那就是开始比较系统性地学习和实践个人理财和投资。大概是不到两年前的一个非常偶然的机会我开始接触并尝试投资这个事情，我才发现其实很多人（包括以前的我自己）都对个人理财和投资存在着大量的误解，这绝对是值得每一个年轻人深入研究的一个领域，而且越早越好，因为它几乎跟编程一样会以非常潜移默化的方式从根源上影响你今后的思维方式。我当然不会在这篇博客来详细说明这是为什么（或许以后会写一写），但我会在这篇年终书单来提四个现在的我认为的最重要的投资思维。投资思维并不仅仅只能用于投资，在很大程度上，它们可以用于个人参与社会生活的方方面面。在可以预见的今后一段时间内，这四个词都会成为我微信个性签名的一部分，以此来时刻提醒自己：</p>
<ul>
<li><p>价值：价值思维强调你需要深入事情的本质，这是最基础且根本的。研究一只股票，首先要看的就是它背后的企业在目前的基础上未来能产生的盈利价值。泛化来说，我们应该永远都回归事物的本源，用最根本最核心的内在逻辑来看待、思考和决策一切和我们相关的事情。能看到核心价值并不是一件简单的事情，但这必须是我们一直追求和崇尚的。放到一家公司来说，追求核心价值要求他们能持续将资源投入到能真正解决社会问题的事情上去，回归商业的本质，而尽可能不被一时的创业潮流和资本热度所左右。这个最根本的事情大多是公司为什么而创业的原因，也是一家公司存在的根本价值。在越是困难的时期，回归到真正的价值追求会显得愈发重要，因为在退潮时你才更容易看清之前水面下的到底都是些什么东西。</p>
</li>
<li><p>概率：概率思维是很多人严重缺失但又非常重要的一种思维方式，它能够告诉你没有什么事情是必然的，也没有什么事情是一定不会发生的。所有未来的事情在还没有发生的时候都是概率的，这些事情一起构建成为了「薛定谔的未来」。用这个思维来投资，它能帮助你在任何时刻准确的控制你的仓位情况，包括哪些投资标的和怎样的分配比例，同时也让你对任何未来可能的情况有所心理上的预计并做出计划和准备，在任何事情发生后都不会因为一时脑热、害怕或恐惧而做出错误的决策。错误的代价往往被低估，在投资的世界里尤其明显，不出错基本就已经可以在可量化的游戏里打败大多数人了，如何保证自己不出错是需要每个人思考的基本的问题。世界永远是概率的，这是目前唯一可以确定的事情。</p>
</li>
<li><p>长期：长期思维可以让投资者避免因短视而带来错误。人类往往容易放大眼前发生的事情带来的影响，而低估长期趋势在未来产生的作用。把孤立的事情放到一个长期变化的过程中去看，也更容易看到事情的本质。这也会成为你做出正确投资决策的基础：浮亏时，你能知道什么时候需要继续坚持，而什么时候要懂得及时止损；浮盈时，你能尽可能最大化自己的最终收益。人的一生对每个人而言也是一个长期的过程，不必因为一时的得失而或喜或悲，保持平常心对个人保持一个良好的日常状态非常关键，这也是我之前一直揣摩且追求的「个人 2016 年状态」。</p>
</li>
<li><p>非线性：非线性思维能让你避免用简单机械的方式来思考。不要觉得事情都是在简单线性发展的，不要认为努力就一定要成功且会成功，不要用静态陈旧的观念来看待和衡量周围的事物。这跟我在去年的书单总结中说到的「顿悟」的习得方式有共通之处。不要因为事情的突然失败、成功或发生而感到惊讶，有太多个人无法决定的偶然因素在相互交织产生影响，现实生活中真正复杂的系统一定是非线性的，这几乎同时暗示了物理世界「永远不存在绝对完美的事物」的残酷真相。</p>
</li>
</ul>
<p>理论终归只是理论，实践中很难做到完美，但完美依然值得追求。或许未来我的博客也会增加一个「滚雪球」的分类来记录一些我个人的投资感悟。</p>
<p>最后，站在这个看似艰难的 2019 年的尾巴上：愿世界依旧值得被好奇，愿自己依然能常怀热爱。我们一起来迎接人类下一个云谲波诡而又风景迤逦的十年的开始。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 年书单</title>
    <url>/2020/12/31/2020-booklist/</url>
    <content><![CDATA[<p>2020 年，是一个太魔幻的一年（什么？你不知道为什么会这么说？好吧，如果你来自未来，本文末尾有一期推荐的播客可以听一下），甚至很有可能还是「魔幻元年」。那句话怎么说的来着：今年是过去十年最差的一年，却可能是未来十年最好的一年。当然，认真地讲，我并不完全赞同。不过要是说世界的节奏和变化速度越来越快，我是要默然颔首的。</p>
<p>其实这一篇本质上有标题党的嫌疑，因为今年看的书实在太少太少，当然后面我也会解释今年看书少的<del>借口</del>原因。不过，看过<a href="http://maples7.com/tags/%E4%B9%A6%E5%8D%95/">我前几年「书单」</a>的你肯定也知道了，我的书单系列只是用「书单」作为切入口，以此为契机来定期来聊聊我对这个世界的看法而已。虽然我也有要时常更新我的博客的想法，但事实就是总有一些手头上新奇的、或者我认为更重要的事情占据着我的时间，以致于目前这里几乎成了一个年更博客，这确实很不应该。但好在我依然还有年更「书单」这个保留节目。</p>
<p>Anyway，这依然首先还是一个「书单」，所以我们还是会从正题开始。</p>
<span id="more"></span>

<ol>
<li><p><a href="https://book.douban.com/subject/34838232/">新婚之夜</a>：★★★★☆</p>
<p> 不得不说，我很喜欢这几个中短篇故事，我觉得这才是真正给现代人看的文学作品。作者把细腻的情绪和世界的真实都潜藏在故事情节里，「给残酷的内核外面涂一层奶油」，以至于我会觉得在北京这样的城市路上遇到的每一个人背后都可能有一段类似书里描绘的故事。推理和悬疑的要素也大大增强了故事的可读性。</p>
<p> 第二篇《模特》也看过 2019 年扩展的中篇电子版，故事叙述方式和人物刻画都比出版的这一版明显更好。</p>
<p> 很喜欢作者讲故事的风格，如果长期坚持写作，应该很有潜力能写出更优秀的作品。</p>
</li>
<li><p><a href="https://book.douban.com/subject/5354957/">扶桑</a>：★★★★</p>
<p> 整个故事的结构和完整性都还不错，也比较有新意。从叙事人的视角来讲这个故事我觉得是个加分项，给了这个故事更多的现实寓意和文化内涵。整个读下来，前面部分会感觉略微零碎而不够畅快，但后面慢慢把拼图拼起来之后会觉得这确实还是一个好故事。</p>
</li>
<li><p><a href="https://docs.python.org/3/tutorial/index.html">The Python Tutorial</a>：★★★★☆</p>
<p> 自从大学期间看完《Dive into Django》和《Learn Python the Hard Way》之后，中间间隔了很长一段时间没有再使用 Python，几乎已经忘得差不多了。尽管在近两三年的工作中又有几个 Python 数据处理相关的项目，但总感觉自己在 Python 方面的理解还不够系统，所以打算再系统的学习学习，同时也看看一些新特性。任何编程语言的官方文档总不会太差，如此大众的 Python 自然也不让人失望，任何想入门的人都可以且应当从这篇文档开始作为学习的内容之一。</p>
<p> BTW，大体上我不赞同 learn something the hard way 的学习方式。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26752026/">聪明的投资者</a>：★★★★</p>
<p> 堪称价投宝典，虽然很多具体的事例都已经过时，但投资的大道却永远不过时（主要是第 1、8、20 章），同时这个版本的点评章节也很好的弥补了这方面的不足。投资的确是个体认知能力和认知水平的直接变现行为。</p>
</li>
<li><p><a href="https://book.douban.com/subject/27614523/">刷新：重新发现商业与未来</a>：★★★☆</p>
<p> 入职微软之前看完了这本书，写得很朴实。从个人经历来说，并没有过分强调自己的努力和付出，也准确表达了顺应趋势在对的时间出现对的地方的重要，同时家庭经历的曲折带给了他更多对于同理心的思考；从公司的层面来说，坦诚微软在当时需要一次文化变革，重新刷新自己，目前看来确实正在扭转颓势；最后谈了谈对未来技术的认识，跨国企业应当是有全球视野和使命感的。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25910559/">剑指Offer：名企面试官精讲典型编程题</a>：★★★★</p>
<p> 根据我面试别人和被面试的经验来看，这本书包含了一个合格程序员应该掌握的容易被总结和教材化的基础知识和技巧，针对很多公司已经套路化的面试流程而言的确是有效的。但它依然只是《骗分导论》一般试图突击走捷径的存在，不能作为修炼编程内功和计算机科学素养的考纲。仅对于找工作来说，是必要不充分条件。</p>
</li>
<li><p><a href="https://msl.overdrivechina.cn/media/5690793">Learn .Net Core: .NET Core Tutorial</a>：★★★</p>
<p> 一本非常短小的小册子，适合有其他语言编程经验的人熟悉 .NET 世界的 basics and fundamentals，以图一两天快速建立一个整全观。基本没有什么更深入的细节。</p>
</li>
</ol>
<p>没了。</p>
<p>如前面提到的，今年看书时间不多的<del>借口</del>原因大概来自于这样几个方面：</p>
<ol>
<li><p>换工作和城市，入职微软中国（苏州）。</p>
<p>从更新简历开始，到投递面试、确认 Offer、从北京离职，最后跨城市搬家、入职、新员工培训、自学一些相关的技术等等，这其中每一个步骤都需要耗费大量的时间和精力。而且微软是我目前为止遇到的入职流程最漫长的公司，毕竟其中的背景调查就耗费了三周到一个月的时间，处处显示着跨国大公司的规范与严谨。如果以后有机会，我也可以在博客或其他社交平台上分享更多在微软的经历。</p>
<p>舍弃旧的环境和已经熟知的工作流程、技术规格和项目，从零开始投入到一个全新的体系里，有太多的新东西需要学习，这不仅仅包括作为开发者所必须掌握的技术相关的知识（在微软 C# &#x2F; .NET 对于大多数开发者都是必须的，而在此之前我接触得并不多），还有一些事关企业文化、规范、工作流程和团队协作上的软技能的准备。而在像微软这样一个历史悠久的跨国企业里，项目和用户规模都十分庞大（意味着对项目稳定性要求格外高而无法快速变化），项目历史也十分悠久（十几二十年的代码，legacy code 不少），对于这些已经世界级的产品，想要短时间内掌握清楚基本不现实。我的 manager 就曾告诉我，新入职员工基本都需要经过一年到一年半的时间才能对项目上手，这本身就是一个不小的挑战。</p>
<p>所以更多的时间还是放在了跟工作内容相关的知识的学习上，这不是几本书就可以简单概括的。</p>
</li>
<li><p>东航「周末随心飞」。</p>
<p>一场突如其来的传染性肺炎疫情让所有人都猝不及防，航空公司们为了自救而推出了「随心飞」这样的产品，首先从东航的「周末随心飞」开始。在今年这样的情形下，对于航空公司来说这确实是一招不错的棋，而对于大部分产品购买者来说其实也并不亏。所以借着这样的契机，同时得益于微软讲究 work-life balance 的工作节奏和假期福利，今年我也着实好好<del>在国内到处蹦跶了一下</del>领略了一把祖国的大好河山。最值得一提的当属十一假期前后去了西北一线，包括银川、兰州、青海大环线的南半边、可可西里，确实看到了极其壮阔瑰丽的大漠景观。除此之外，还去了潮汕、长沙（两次）、西安、三亚、济南，也是一年难得的经历。</p>
<p>为了不辜负路上的美景，今年还购入了无人机和微单来作为拍摄器材，<a href="https://maples7.tuchong.com/">拍了不少照片</a>。我想，要彻底消化完我这个重燃的新兴趣点也是需要不少时间的投入的。</p>
<p>所谓「要么读书，要么旅行，身体和灵魂必须有一个在路上」，至少今年身体还在路上。曾经为了让自己能多出门走动、不要太宅，也制定过「希望自己周末一半的时间能出门」这样的年度计划，至少今年应该是实现了这个前几年的想法。</p>
</li>
<li><p>上完了<a href="https://cs50.harvard.edu/">著名的 MOOC Harvard CS50x</a>。</p>
<p> 这门课其实我在大学时期就上过一部分。虽然只是哈佛的一个计算机相关的通识基础课，但由于制作的实在太好，内容又相当丰富，我不忍心这么好的课程自己没有全部看完，于是在今年又从头到尾全部过了一遍。尽管对于我这个从业者来说没有什么新鲜的「干货」，但它却是我上过的体验最好的 MOOC。除了哈佛的明星教授 David Malan 精彩的授课讲解，也有制作得非常有层次的课后作业，最后的大作业甚至是独立开发一个完整的应用，这是少有的让我觉得参与起来非常有意思的一门课。实际上，这门课已经成为了一个独立的品牌，有一系列相关的网站、后续课程和工具集供你在 CS50 的海洋里遨游。所以也建议开发者或者对计算机知识感兴趣的人去听听这门课。</p>
<p> <a href="http://maples7.com/2019/12/31/2019-booklist/">去年的「书单」</a>我就提到了<a href="https://github.com/Maples7/cs-roadmap">我整理的学习 Computer Science 的资源和路径列表</a>，这门课目前就是我列在 Fundamentals 类目下第一位的课程。所以上完这门课也是我遵循去年立下的深入系统有节奏的学习世界顶尖的计算机相关课程的计划之一。这其实也比简单看完几本书需要花费更多的时间和精力。</p>
</li>
<li><p>外部环境、事件的影响，包括新冠疫情。</p>
<p> 说 2020 年是不可能脱离新冠疫情这个大的背景调查来谈的，它已经成为了 2020 年的标签和底色。疫情在今年或多或少的影响了地球上的每一个人，外部环境的剧变需要每一个个体有更加坚定的自我才能在自己的道路上继续走下去。我以前就写过，环境对人的影响往往被低估，相信今年的情况提升了很多人对于环境影响的认知。它或许不能完全左右你的方向，但绝对可以让你的每个动作都充分扭曲变形。这历历在目的一年，相信身处其中的每个人都深有体会，无须多言。</p>
</li>
</ol>
<p>其实从个人角度来说，今年对于我自己算是不错的一年，因为它足够丰富，这主要来源于在微软工作我会有更多时间投入到各种各样不同的我想要投入的事情上去，比如写一些自己想写的代码，比如对新技术的学习、投资领域的深入、其他兴趣爱好的培养等等。往年的「书单」或多或少我都会夹杂着一些「湿货」，以阐述我的世界观的某个部分，但今年这篇我想就保留这样简单平实的记述风格。已经是太不容易的一年了，就给我自己和看到这篇的你留个气口吧。</p>
<p>另外感谢 12 月有 31 号，让我还有充分的时间来完成这篇「书单」。最后，强烈推荐看到这里的你静下来听一听声动活泼旗下的这期播客：<a href="https://mp.weixin.qq.com/s/IBp5eQ8kggFyi6Egq4VnIQ">《请收下这枚记录2020的声音时光胶囊》</a>。</p>
<p>「历史就算会反复，但一定会向前走的」，2020 年是需要很多感性力量的一年，现在我们又来到了一个新的时间节点，故事还将继续，只愿世界和平。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>「必然」有多必然？</title>
    <url>/2020/05/19/how-certain-is-certain/</url>
    <content><![CDATA[<p>最近在看美剧《高堡奇人》（<em>The Man in the High Castle</em>）第四季，也是最终季。整个剧是基于 Philip K. Dick 的同名长篇小说改编的，也是这部作品创造了一种「架空历史」的新的科幻作品类型，剧情大致是基于纳粹德国和日本天皇打赢了二战，共同统治了世界之后的人类历史发展。值得一说的是，这部小说是 1962 年写的。作为 2020 的人类，我们早已习惯了第二次世界大战同盟国胜利之后的历史，但这部小说带给了我们这样一种思考，这种已经发生的历史是一种冥冥之中的「必然」吗？</p>
<p>当然，历史是经不起假设的，这个宇宙到底存不存在平行时空人类目前也不甚清楚。在这里，我并不是想讨论历史，也不是想讨论科幻，而是想讨论某个事件发生的必然性到底有多「必然」的问题。并不像大多数人以为的那样，人类的潜意识其实非常习惯于从某个结果来抽象总结出事情发生的原因，习惯于找出其中存在的一系列因果关系的逻辑链条而忽视次要因素，从而把事情化繁为简存储在自己的经验模型库之中。人性使然，已经获得成功的人也会不自觉的从自身的成功中总结经验并加以传授，告诉人们你们这样做也可以像我一样成功，这不禁也让人怀疑，成功学有必然性吗？</p>
<span id="more"></span>

<p>最近我还从<a href="https://zh.wikipedia.org/wiki/%E6%A2%81%E6%96%87%E9%81%93">梁文道</a>的播客<a href="https://shop.vistopia.com.cn/detail?id=4z4Ew">《八分》</a>的<a href="https://shop.vistopia.com.cn/article?article_id=vG_Cc">第 203 期节目</a>中听到这样一个故事（道长的这期节目本来是在探讨人性中善良的部分的问题），长篇小说<a href="https://zh.wikipedia.org/wiki/%E8%9D%87%E7%8E%8B">《蝇王》</a>讲了一群小孩被困荒岛在没有成人引导的情况下如何建立起一个脆弱的、充斥着野蛮与暴力的文明体系的故事，基本是社会达尔文主义的荒岛实验版本，充分揭露了人性中的恶。小说是虚构的，然而<a href="https://zh.wikipedia.org/wiki/%E7%91%AA%E6%A0%BC%E9%BA%97%E7%89%B9%C2%B7%E7%B1%B3%E5%BE%B7">人类学家 Margaret Mead</a>在《Humankind: A Hopeful History》中却写了一个真实的有类似情境却完全不同结局的故事：六个偶然迷失在无人岛上的小孩通过合作、民主、和平的方式生存下来活了十五个月的故事。Margaret Mead 企图用这个真实的故事说明人类本性中除了有自私的天性以外同时也有一种互助友爱的天性。但以此就可以推翻虚构的小说《蝇王》所描写的那个故事的可能性吗？人类是一种相当复杂的动物，我们既能看到《蝇王》小说中的恶，也可能看到如童话般的善，真实的人类社群更是一个庞大的复杂系统。</p>
<p>所以已经发生的「必然」到底多必然？</p>
<p>有无数的历史教材告诉我们历史中某些重大事件的发生是某种趋势的必然结果，彷佛世界的发展有一张无形的手在推动着前进，我们也无数次听到「即便现在某个人&#x2F;某件事不出现&#x2F;发生，这样的历史时刻&#x2F;趋势&#x2F;潮流之下也会诞生另一个某某人&#x2F;发生同样的某某事」这样类似的说法，彷佛条件到了该来的一定会来。人类自古以来就希望拥有预测未来的能力，玩狼人杀拿到预言家的身份都会精神几分，从进化心理学的角度，这本质上源于人类对不确定性的恐惧。每个人都希望生活在稳定安全的环境之中，如果能有效预测未来，则可以为即将发生的事情做好万全的准备从而获得对自己有利的条件。</p>
<p>不言自明，预测肯定是基于当下的现实来产生的，是基于此时此刻这一秒的全部已经发生的现实，来预测未来某个时刻将要发生的现实。首先，没有人可以同时了解到此时此刻的全部现实，即便我们假设现在可以采集到所有的现实数据，那接下来发生的事情就可以预测了吗？仔细思考，你会发现这里存在一个悖论，即未来被预测这件事情会不会影响对未来的预测。按理说，预测未来这件事同样也是当下的现实，应该也会对未来事件的发生产生影响。所以准确预测未来还可行吗？不得而知，我无法给出任何可信的答案或思考。回到现实，既然准确的未来还无法预测，那预测出事件的大致走向&#x2F;趋势&#x2F;潮流是不是可行呢？</p>
<p>各个行业中都有一些传奇励志的成功故事，互联网创投圈中更是如此，都说互联网是个年轻人的行业，有众多年轻的互联网新贵因为把握住了行业发展的潮流和趋势年纪轻轻就已经实现了很多人追求的所谓财务自由。那么，他们真的是因为提前看到了趋势和机会才成功的吗？当然，不排除真的有人有意识且主动地看到了趋势和机会，但肯定也有不少人主要是凭借运气做成了某件事情（在其他条件相同的情况下，这包括主观能动性的程度）。更进一步的问题是，能看到趋势和机会是因为什么？这其中又有多少偶然和运气呢？</p>
<p>当然，同样地，我们也不能陷入到一种虚无主义和怀疑论的情绪当中去。人类世界是一个混沌的复杂系统，事情之间环环交织，它们一起构成了一个已经发生的当下的「偶然」，一部分相互交织的「偶然」子集又相互作用和相互影响，为下一个「偶然」的发生提供作用和条件，而我们的主观能动性，同样也是其中的一部分「偶然」，同样对事件的发生产生影响。由于股票市场是不可预测的（这基本也反映了现实世界的不可预测性），很多价值投资者都崇尚用「概率」和「非线性」的思维方式来思考问题，从而通过更合理地布置仓位和设计操作策略来实现最终的盈利。我们在实际生活在也可以学习这种思维模型来应对不可预知的未来世界，首先要充分认识到世界的不可预测性并基于真实世界没有简单的因果关系的前提，不要用简单机械线性的思维和视角来分析问题，这样可以减少一些偶然被你感知到的噪音对你的影响，从而总是能依据自己的理性判断对不同概率下的可能的未来做出符合可能性的准备，进而做出一个当下最优的决策。</p>
<p>2020 年是一个太不平凡的一年，突如其来席卷全球的新冠疫情、本身已经变得脆弱的世界政治经济局势等等，人类似乎又站在了一个暴风雨的前夜，你能预测世界接下来的走势吗？</p>
<p>我想我是得看一些关于复杂系统理论的书了。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>必然</tag>
        <tag>哲学</tag>
        <tag>复杂系统</tag>
      </tags>
  </entry>
  <entry>
    <title>在望京，没有方向</title>
    <url>/2021/12/08/no-direction-in-wangjing/</url>
    <content><![CDATA[<p>北京的初雪天很冷，却总能给人一种充满希望的感觉。雪一下，北京成了北平，茫茫的白色也成了一系列盛大节日的暗示。会来事儿的商家会早早在店面上添上一抹红，本来素朴的街道氛围一下就上来了。不管你白天因为工作上的什么事情而烦恼，在天刚黑的下班路上，都是一段最佳的放空自己的时间。宽阔的街道上一如继往的车水马龙，迎面的车道闪过一道道晃眼的白光，正向车道的红尾灯连成一片红色光带。是很堵，但人们都失去了一些平凡日子里的暴躁。当然，这很可能是前面路口交警的功劳。</p>
<p>北京远不是一座浪漫的城市，现实的引力会牢牢的吸住每一个人，不让大家离地面太远。不仅不浪漫，甚至还很土气（「土」并不天然意味着「不能高档」和「不能高级」），然而这种「不浪漫」也正是这座城市吸引人的特点之一。生活会奖励真实，这里的每一个人都受其馈赠。望京当然也逃不过这引力。</p>
<span id="more"></span>

<p>没有二环内胡同大院的庄严古朴，没有三里屯的时尚摩登，也没有中关村的高知气息，望京在这样的北京城的东北角里，显得很普通。硬要说有什么不同，那大抵就是望京的路了。不同于北京大多数地方笔直朝向的道路，望京的路成了这些「笔直」的弯曲黏合部。沿着望京的路慢慢走，不知不觉你就偏离了原本的方向。这当然算不上什么望京「有名」的特色，但你也难忽略这件事的存在。</p>
<p>普通的望京却没有普通的人，这样说其实不对，每一个在北京浮沉的人都是不普通的，跟望京没啥关系，望京依然还是那样普通。在路上的每一个人，都有可能有一段引人入胜的故事。这是一个爱听故事的人的天堂，要是你还有酒，那或许可以换到很多色彩斑斓的故事，或者不需要酒，那你得成为一个健谈的的士司机。但是，在某种程度上，这里的每个人又都是普通的。无论你曾经经历过什么，在这样一座偌大的城市里，你都能找到跟你有类似经历的人，没有人是完全独一无二的。</p>
<p>望京可以算是目前北京城人口密集区的最外围的一个据点了，再往外走，选一个秋高气爽的日子，你就可以在北京郊区的农家小院里度过一个惬意的周末。当然，前提是你没有在望京迷失出城的方向。</p>
<p>在望京，不仅没有方向，也没有音乐。当然，开出城区之后是有音乐的，但一回来望京就没有了。你可以在这里听到各种各样的旋律，但这里没有音乐。没有音乐人就很难拥有灵魂。</p>
<p>也许望京有一种神秘的神奇磁场，每一个进入这片场区的人都在不知不觉中丧失了对自我、对生活的敏锐感知力。每个来这里的人都带着天然的对生活的期待，目标明确，反而慢慢地在一天又一天的循规蹈矩中迷失。中关村或许承载着人们更强烈得多的期待，但那里的人们在一天天的忙碌背后也会关注生活，或许是周围的校园气息对这种蓬勃的欲望起到了中和的作用，反而让其不仅有朝气活力的气质又能有随时静下心来的感知。</p>
<p>望京大抵是少了点什么东西。</p>
<p>在望京，务必带好你的罗盘再出发。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>创业</tag>
        <tag>北京</tag>
        <tag>望京</tag>
      </tags>
  </entry>
  <entry>
    <title>创业的准则</title>
    <url>/2021/11/19/principles-4-startups/</url>
    <content><![CDATA[<p>对于普通的立志于在互联网行业有所作为的大学毕业生而言，选择去大公司还是去创业公司工作一直是一个没有标准答案的问题，不同的人适合不同的道路。而另一个更艰难的道路就是自主创业。我毕业这几年，正好集齐了在创业公司、国内中型民营公司和跨国大公司的工作经验。总的来说，在创业公司的工作是其中目前为止最长也非常可圈可点的难忘经历。这篇文章根据我在创业公司的经验和自己平时对于市场的思考总结而成，是我认为创业应当遵循的创业的准则，不一定正确也不是一个系统完整的阐述，个人观点，仅供参考。</p>
<span id="more"></span>

<ol>
<li><p>找最优秀的人一起工作。</p>
<p> 这里的「优秀」不一定得是具体业务上已经最厉害的人，但一定是有潜力成为最厉害的人的人。优秀的人能给公司带来的长期价值是难以用一朝一夕来衡量的。除了完全能胜任本职工作的基本能力以外，优秀的人不仅能对整个团队的建设产生积极的影响，更重要的是，他们往往能跳出传统的思维和各种条条框框的限制来看待具体的问题，提出创造性的解决方案，给整个团队创作难以估量的价值，而这些价值很可能成为决定创业公司走向和存亡的关键核心优势。</p>
<p> 当然，有潜力的人是需要时间和空间来培养的，而创业公司相比于中大型公司往往更容易营造这样肥沃的土壤。优秀的人能持续学习，跟随公司一起成长，互相成就，达成共赢。创业公司在人才方面存在越多这样的良性循环，就越能走得更长远。</p>
</li>
<li><p>宁可不做，做就要用对的方法做对的事情，不要用错误的方法做事。</p>
<p> 明星技术创业公司 TiDB 的 CTO 黄东旭有一个观点我很赞同：Make it right before making it fast。朝着正确的方向做事永远是所有具体决策的大前提。创业公司本身所拥有资源是很有限的，只能用有限的资源发挥更大的效能才能跑赢更大型的公司。这一点其实对创业公司的领导者提出了很高的要求，这要求他们能够有足够的预见性和前瞻性，能够充分吸收外部市场上各种各样的信息做出正确的决策。</p>
<p> 有的人可能会认为「快」比「正确」更重要，我并不这样认为，或者说，这中间需要一个平衡和取舍。有一种常见的说法是创业公司能够快速试错从而能比大公司更灵活的「转身」。这一点在已经做出错误决策的情况下是正确的，所以正确表述应该是「创业公司能够比大公司更快速的扭转错误的方向」。可是我们为什么不追求从一开始就尽量不做出错误的决策呢？用俗话说就是，不要用战术上的勤奋掩盖战略上的懒惰。创业公司领导者需要花更多的时间思考公司的战略和方向而不是整天呆在公司扣一些细枝末节（当然，并不是细枝末节不重要，而是战略方向要更重要得多）。一定要记住一个大前提，创业公司所拥有的资源是非常有限的，所以试错的机会成本其实比大公司要高得多。大公司完全可以拆出数十倍于创业公司的资源来试错不同的决策方向和选择，而创业公司失败一次就足以让团队元气大伤。优秀的团队成员可能可以给公司的效率带来很大的提升，但错误的决策方向落地执行下去不仅是对客观资源的一种浪费，也是对人才的一种伤害。</p>
<p> 所以「正确」比「快」更重要，宁可不做，做就要做对的事情，并且用对的方法来做这件事。</p>
</li>
<li><p>在没有划时代的技术优势时，产品的成功是所有细小正确决定优势的累积。</p>
<p> <a href="https://www.thoughtworks.com/radar">Thoughtworks 有一个广为流传的技术雷达的观点</a>，但真正能划时代的技术其实是极其稀少的，而每一个关键技术的突破，都可以带来一波技术红利的浪潮，持续数年。现如今，上一波移动互联网的浪潮早已远去，下一个能来带技术爆炸的计算平台到底是啥还未可知，可能是实现完全无人驾驶技术的新能源汽车，也可能是 Facebook 刚提出的所谓「元宇宙」虚拟网络空间，总之还没有确定性的答案，而过早涉足这些技术的创业公司大概率也会成为时代的炮灰。然而在已经成熟的技术领域里挣扎似乎又早已没有可以创新的空间。</p>
<p> 我上一段在创业公司的工作经历所做的产品就是在很传统的领域，很难打破传统行业的桎梏做出颠覆式的创新。所以产品想要在公开市场上取得成功几乎只能取决于所有细小正确决定优势的累积。就好比你在 2021 年的今天做一个手机 App，你已经很难找到无人想到的新的创意来填补市场上的空白，存量竞争的时代只能靠产品上累积的细节和局部的优势来来取得竞争优势。这些优势可能是更少的 bug、更好看好用的 UI&#x2F;UX、更人性化的布局和设计、抑或是能支撑产品决策的更成熟深刻的理论基础。关注细节、关注每一个微小的决定，在这种技术周期的浪潮下是重要的。</p>
</li>
<li><p>用产品和技术而不是营销手段说服用户。</p>
<p> 在产品没有打磨好之前，不要使用任何刻意的营销手段。这样做只会提前消耗掉未来可能成为优质长期用户的市场耐心。真正的好产品，靠自然流量和口碑传播也终能被市场认可，但在市场快速变化的今天，在产品打磨好之后，使用营销手段可以加速从 1 到 N 的过程，快速占领市场份额，建立自己在这方面的护城河。</p>
</li>
<li><p>建立制度，然后让更多的人自己做决定。</p>
<p> 有团队的地方就需要有制度，制度是团队文化的具体化，文化通常可能带有创始人强烈的个人色彩。但不管怎样，因为人的差异性，制度是需要的，而在制度建立之后，具体的与每个团队成员相关的决定让成员们自己做选择（尤其是小团队的时候，吸纳优秀的人进团队，再充分信任每一个团队成员）。只有这样，才能真正在团队范围内做到文化与行为的一致性。比如，现在很多互联网公司都会实行弹性工作制，如果这真的是创始人所认同的工作制，那么我们可以建立弹性工作的制度，同时要求每天基础的工作时长，那么具体每天的工作时间段则交给团队成员自由选择；如果创始人并不真的认同这样的制度，即便口头上声明你们是弹性工作制，长期下来的言行不统一也会让团队成员逐渐丧失对这个团队的信任，相互之间变得不再坦诚；而如果创始人认为就应该是白天固定时间段的工作制更符合团队工作效率的要求，那么制度就是固定工作时间制，而不要声明的与实际的有出入。修补制度上的漏洞，直到让大多数人尤其是创始人达到一个舒服的状态，而把具体事项的决定权交给充分被信任的每个人。</p>
<p> 本质上，这其实是约束与放任的平衡哲学，建立制度就是建立约束，而让每个人做与自己相关的决定就是给予成员选择的自由。这样充分打磨下来的团队才能稳定持续走得长久。</p>
<p> 文化上尽量开放包容，奖惩的原则要事先声明并遵照执行，合作靠透明的制度而不是依赖于默契（短暂的依赖于具体个体之间的默契不是可以长远依靠的事情）。</p>
</li>
<li><p>不放过任何一个细小的直觉上能感知到的问题。</p>
<p> 在一片迷雾中行走，很多时候都是依靠直觉的。而创始人往往拥有对团队、对产品方向最敏锐的直觉。当有某方面敏锐的感知时，不要犹豫，不要怀疑，立马去验证自己的直觉。这种直觉的感知往往是有所苗头的，而越早行动越能避免更多更大的问题的产生。</p>
</li>
<li><p>流程优化永远比赶进度更重要。</p>
<p> 对流程上的优化<strong>永远</strong>（记住是「永远」）比赶进度更重要。只要发现了流程上影响效率的地方，立马启动优化。对于 to B 类型的项目，存在这样一种情况，客户要求的时间很紧，项目进度很赶，而流程上也有很多亟待优化的地方，那么就引入更多的人力资源来优化流程上需要改进的地方，不管是从外部招更多的人还是从内部调其他的人来处理。效率是创业团队的生命线，失去了效率也就基本失去与大公司竞争的很大一方面的优势，所以永远要优化流程，当一个低效的流程反复被执行，浪费的不仅是这个流程上所有人的时间，更是对这个流程线上人的主观能动性的脱敏式折磨（这类似于中大型企业虽然有很多常年低效的流程制度，但因为早已形成惯性无人进行优化，员工们也逐渐就不再觉得那是可以被改变或优化的地方，慢慢的越来越多的人开始人浮于事，用打工人的心态各扫门前雪，这往往就是中大型企业开始体制僵化走向衰败的开始）。</p>
</li>
</ol>
<p>差不多暂时能想到的点就这些，如果以后有新的想法可以总结成文也会写一些新的东西。创业是一个十分艰难的过程，三年在创业公司的经历见证了一个小团队的起起伏伏，对于方向和未来的迷茫，感受到真实世界里创业的艰辛和残酷。不禁让人想起十年前左右「大众创新」所引发的在校大学生的创业热潮，大部分都是极其幼稚的（当然不可否认当时成功的创业项目也很多，那个时代有那个时代的红利）。当面对真实的现金流压力的时候，你的所有产品决策和公司走向还能不忘初心吗？无论成败与否，所有的创业者都会需要想明白这个现实的问题，并找到自己的答案。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>产品</tag>
        <tag>创业</tag>
      </tags>
  </entry>
  <entry>
    <title>完全理解回调函数</title>
    <url>/2017/10/17/understand-callback/</url>
    <content><![CDATA[<p>什么是回调函数？</p>
<p>在任何一个函数是「一等公民」的编程语言里，这都不会成为一个问题。简单说，回调函数就是传递给其他代码的函数实体或引用，但其内涵远没有这么简单。</p>
<p>回调函数本质上提供了一种与常规的上层调用下层代码相反的模式，使得底层代码也有机会反调高层的代码，这大大提升了代码的能力，也同时给工程化项目带来了新的问题和挑战。</p>
<p>回调函数也是事件驱动式编程的基础，使得程序不必像传统的流程驱动式编程那样亦步亦趋的向下进行，而是可以被动性的由外来事件来触发进行，这几乎是所有图形化编程最基础和标准的实现方式。</p>
<span id="more"></span>

<p>一个典型的回调函数的例子就是在各个语言中都很常见的排序接口（比如 C++ STL 中 sort 函数），它们几乎都允许用户自己提供一个定制化的「比较函数」，这个比较函数就是典型的回调函数，它将会在排序接口的内部被执行。正是由于这样的回调函数的存在，使得排序接口不再仅仅局限于自然排序，大大提高了代码和接口的重用性。</p>
<p>回调函数分为两种，一种是同步回调函数，另一种是异步回调函数。上述排序接口的回调函数就是同步回调函数，而在 Node.js 中常见的回调函数是异步回调函数。同步回调和异步回调都可以使得调用者（caller）不再简单依赖于被调用者（callee），使得二者在代码空间分布上解耦，而异步回调函数更是在运行时从时间上将二者解耦。</p>
<p>回调函数背后其实隐藏着「控制反转（IoC，Inversion of Control ）」的编程哲学，或者说回调函数是实现 IoC 的最常见的手段。IoC 的核心思想是 “Don’t call me, I’ll call you”，也被叫作「好莱坞原则」，据说是好莱坞经纪人的口头禅。控制反转其实也很常见，一般的库（library）中有回调函数的地方就有控制反转，这种控制反转可能还是局部的，而 Web 开发中几乎肯定会用的框架（framework）则是把控制反转作用到了全局，它使得基于上的更高层开发者不用像命题作文一样从零开始创作，而是把它变成了一道填空题，你只需要在约定好的地方按照具体的业务需求填入相应的内容即可，整个程序的运转流程被牢牢地把控在框架手中。</p>
<p>这样的框架重用度非常高，经过不断地迭代，越通用的东西会越来越沉淀到底层，服务于更广泛的上层代码，而多亏了回调函数的存在，使得上层开发者也能将自己独特的业务需求植入其中。</p>
<p>从事件驱动式编程的角度来说，回调函数也是实现 OCP（Open Close Principle，开闭原则）的手段之一。「开闭」指的是「对扩展开放，对修改封闭」，它要求代码在尽量少修改的情况下还有足够好的扩展性。举例来说，如果需要实现一个通用的消息消费者，如何做到在添加新的消息类型时却不必修改主函数呢？答案可以是让每种消息类型传递自己特有的回调函数，消费者的主体不变，在合适的地方调用随同消息一起传递过来的回调函数即可。</p>
<p>回调函数也不是全然没有问题。</p>
<p>Node.js 天然的异步特性设计使得大多数接口都是异步的，自然也充满了各种各样的异步回调函数。在 Node.js 里，回调函数最大的问题不仅仅是代码书写上产生了 callback hell，更本质的问题是回调函数的调用得不到有效的控制。因为外部异步接口不都像框架一样是基本可信任的，所以你并不能保证别人会如何对待你传入的回调函数。有趣的是，异步流程控制协议 Promise 再一次利用控制反转解决了回调函数调用的「信任」问题。Promise 把本来由异步接口控制的回调函数调用权收归自己所有，所有的异步调用都是通过 Promise 这个「中介」来完成，而回调函数的管理和调用也由 Promise 来一手掌握。</p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul>
<li><a href="https://book.douban.com/subject/4031906/">《冒号课堂》</a></li>
</ul>
<h4 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h4><ul>
<li><a href="http://maples7.com/2016/08/24/understand-sync-async-and-blocking-non-blocking/">完全理解同步&#x2F;异步与阻塞&#x2F;非阻塞</a></li>
</ul>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>「完全理解」系列</tag>
        <tag>回调函数</tag>
        <tag>控制反转</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 年书单</title>
    <url>/2021/12/31/2021-booklist/</url>
    <content><![CDATA[<h3 id="关于书单"><a href="#关于书单" class="headerlink" title="关于书单"></a>关于书单</h3><p>直奔主题：</p>
<ol>
<li><p><a href="https://book.douban.com/subject/35275524/">晚婚</a>：★★★★</p>
<p> 人物描写十分细节，情绪表达非常细腻，如果没有一定的人生阅历和生活体悟，很难相信作者能把书中的某些人情世故和人物动机描写得如此让人感同身受，这是某种源于生活的真切（而且很现代），但故事的戏剧性又提醒着读者小说创作高于生活的存在。</p>
<p> 相比于《新婚之夜》少了很多推理和悬疑的要素，但依然还是有很多伏笔在前后呼应。整个故事的基调是压抑的，给人无力感，的确是一部「漠然记」。还是很喜欢辽京的写故事风格。</p>
</li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p><a href="https://book.douban.com/subject/35250412/">候场</a>：★★★★</p>
<p> 第一次看李诞的书，我也是边喝着凉凉的啤酒边看着新一季的《吐槽大会》边看完这本书的，文字跟他说的话一样个人风格非常强烈。</p>
<p> 李诞整本所谓的「小说」都在写一个叫李诞的人的愁苦和自我厌恶，如果他是真的「诚实」的话。任何能称之为作品的东西，比如电影或小说，都不是绝对的真实，因为生活本身其实是麻木混乱无趣、极少有戏剧点、不值得被看的。这还是我看大鹏的《吉祥如意》的一点想法。</p>
<p> 会自我怀疑的人，一是自恋矫情，二是值得做朋友。这个世界已经有太多的成年人被规训得有着过于明确清晰的自我意志，每一个动作的目的性都如此强烈，以致于世界才会像现在这样无趣。不过我不是在说那种冠冕堂皇自欺欺人的假的「自我怀疑」。这本书讲的我前面所指的真的「自我怀疑」。</p>
</li>
<li><p><a href="https://arxiv.org/ftp/arxiv/papers/1702/1702.01715.pdf">Software Engineering at Google</a>：★★★★★</p>
<p> Google 在 Web 领域深耕多年，对于做 Web 产品的软件工程经验积累颇深。随着战略转变和软件系统的逐渐庞大，微软也在多年前就意识到了内部工程化的重要性。虽然这是一篇写 Google 的文章，却可以从中看到很多微软内部在践行的实践，说明微软也在快速补齐 Web 软件工程化方面的短板，1ES 策略在内部践行多年，很多开发上的体验都大有改善，这对提高开发者开发效率、产品质量和稳定性都是极为重要的一部分，尤其是对这种动辄已经迭代了一二十年的产品的庞大代码库以及如今的全球用户基数而言。</p>
<p> 比较而言，微软在工程化上还是有两点跟 Google 有比较大的不同：<br>1. Google 几乎所有的代码在一个大的 repo 里，不是 git 管理的；<br>2. 他们经常重写代码。</p>
</li>
<li><p><a href="https://book.douban.com/subject/35339729/">微信背后的产品观</a>：★★★★☆</p>
<p> 「需求只来自你对用户的了解，这里非常想强调几点：第一，需求不来自调研；第二，需求不来自分析；第三，需求不来自讨论；第四，需求不来自竞争对手。」</p>
<p> 太赞了！张小龙是典型的原教旨主义产品经理，这一领域的另一个知名代表是乔布斯。而与这一派相对的国内的字节系大概可以代表。我是从来都不相信用数据来决定一个产品的方向的，这种做法本质上是在跟人类历史好不容易构建的人文主义作斗争，是在剥夺人之所以为人的本质，甚至可能在将来导致人类的灭亡。</p>
<p> 产品经理永远要保持对自己主导的产品的人文温度，这样世界才能越来越好。</p>
</li>
<li><p><a href="https://read.douban.com/column/59545797/">我们消失的那一年</a>：★★★☆</p>
<p> 「像是终于找到了线头，慢慢地提起来，一些原本散落在记忆深处的珠子都串到一起了」。多线多时空叙事慢慢串起来好评，悬疑感十足，让人很想继续读下去。部分地方文笔和遣词造句还可以再斟酌斟酌。</p>
</li>
<li><p><a href="https://book.douban.com/subject/35552655/">李诞脱口秀工作手册</a>：★★★☆</p>
<p> 这本书（工作手册）首先是写给内容创作者的现实的工作经验和方法，不是什么复杂的理论，全是从个人感受和实际出发，追求一种长期持续的专业内容生产；其次有些命题也是很终极的，是可以面向普罗大众的，当然同样也是很实用主义倾向的，所以非从业者也可以看看，或许能从窥探脱口秀行业的工作方式中获得一些启发（比如第二节工作和生活是否应该分开的问题、第十七节如何给别人 pitch 你的想法）；另外，了解他们在这个新兴行业摸索同时尝试总结出一些规律的思考过程是有趣的。</p>
<p> 问题就是太短，不够系统，很多地方也是点到即止，有的地方模棱两可不可言尽，还有些地方可能也不是完全没有异议的。不过作为一个指导作用的给从业者工作手册是不错的。</p>
</li>
<li><p><a href="https://book.douban.com/subject/35295592/">小狗钱钱</a>：★★★★★</p>
<p> 我每次看这种经典的投资入门类型的书都会觉得：Damn! 为什么我十岁的时候没有看过这书。哈哈哈有点夸张，合适的时候看到比更早的看到要有意义得多，尤其是在这几年的所有关于钱的实践之后，很多点已经是心领神会。几乎你人生中所有与钱相关的选择和决定都可以在这一类书中找到明确的答案。</p>
<p> 讲故事的方式提高了这本书所要说明的道理的可读性，后记部分提到的企业家精神与如今以培养社畜为目的的教育模式的冲突尤其令人深思。虽然很短但是绝对是今年看完的最值得的一本书。</p>
</li>
</ol>
<h3 id="关于摄影"><a href="#关于摄影" class="headerlink" title="关于摄影"></a>关于摄影</h3><p>还称不上摄影吧，顶多就是拍拍照片。</p>
<p>「读万卷书，行万里路」，「身体和灵魂总要有一个在路上」，不看书的时候出门拍拍照是一个很好的跟自己独处的方式。当你能够专注的沉浸在如何拍到一张好照片的状态中时，很容易进入那种「心流」状态。专注于写代码也能达到这种状态。本质上，这都是一种利用自己沉淀的技术、品味和灵感进行创作的行为。</p>
<p>摄影圈目前是有一些不好的风气和迷思的，我很庆幸我从一开始就树立比较正确的摄影价值观，就跟我接触其他我本不了解的领域（比如投资）一样，这样比较不容易被网络上各种各样的言论带偏。跑题的结论是，学习新东西最开始重要的不是快速掌握技术，而是树立正确的看待这个事情的观念。</p>
<p>转回来，很多真正能让自己满意的好照片可能都诞生于不经意的一瞬间，而这样的时刻往往你的手边并没有相机。对于初学者而言，有一个能让你愿意经常带出去拍照的相机比去学习什么艰涩难懂的摄影理论和培养艺术品味要重要得多。希望明年仍然有机会会拍到很多不期而遇的好照片。</p>
<h3 id="关于投资"><a href="#关于投资" class="headerlink" title="关于投资"></a>关于投资</h3><p><a href="https://maples7.com/2019/12/31/2019-booklist/">前年的「书单」</a>说过，我在几年前一个很偶然的机会开始接触投资。依然非常幸运的是，我从一开始就树立了比较正确的投资理念。这基本上是近几年我最大的收获之一，也很可能是我这一生很重要的收获之一。</p>
<p>投资其实是一个早就有前人公开最优解法的领域，但大多数人要么懒于学习、要么惧于尝试。它其实一点都不难，基本原理甚至相当简单。甚至于说，对于投资，大道至简才是最终的归途。当然，更多已经开始投资的人莽莽撞撞全凭一时的感觉来操作，运气好是可以短时间获得不错的收益，但很可能不是长久之计。这是一件非常考验人的耐心和毅力的一件事，但不同的人可能有不一样的适合自己的投资策略，一旦认定一种策略，剩下的就是绝不轻易放弃的不断「滚雪球」。</p>
<h3 id="关于疫情"><a href="#关于疫情" class="headerlink" title="关于疫情"></a>关于疫情</h3><p>这两三年的头条自然是新冠疫情，疫情对人的异化作用远比大多数人想象的要深刻，甚至你现在看到电影里人多的场景都可能潜意识里感到不适。这几天有不少专业人士预言疫情会在 2022 年结束，我远没有这么乐观。对于国内的普通人来说，疫情什么时候结束已经不是最重要的事，重要的是如何减少疫情对自身的人生规划产生的影响。世界已经安定这么多年，没理由一直这样期待下去。这个道理对于投资同样也很重要。</p>
<h3 id="关于预测"><a href="#关于预测" class="headerlink" title="关于预测"></a>关于预测</h3><p>我不敢说明年，我觉得三年内会有一场金融危机，或者是比金融危机更严重得多的危机。没什么 solid 的依据，就是一种直觉，当然，这不是这一天两天的直觉。当年，危机只是危机，即便它比任何一次危机还要严重，也不会是末日。危机过后，世界还会继续。当然，末日也总有一天会来，但应该不会这么早。</p>
<h3 id="关于人生"><a href="#关于人生" class="headerlink" title="关于人生"></a>关于人生</h3><p>我一直试图在人生的所有事情上成为一个纯粹的理想主义者，这当然不是一件简单的事情，但却值得为之付出所有的努力。但是，保持理想主义的同时，我开始意识到一些我值得改变的地方。</p>
<p>以前我对竞争是不屑的，我总是会抱着一些提升自己远比这一两次直接的竞争来得重要的心态，而从小父母的言传身教家庭教育也让我骨子里养成了谦让的习惯，如果有人明确的说喜欢什么东西，不管我是不是喜欢或者讨厌这个人，我大概率是会让给对方的。这当然不是一个坏的品质，但却值得重新审视。本质上，理想主义者愿意为这个世界变得更美好而付出自己的努力，但一味的谦让有时候让出去的却是未来对世界的掌控权和话语权，这并不是一个理想主义者愿意看到的，因为真正的理想主义者实在不多。所以以后希望自己能更敢于直接竞争，不要把这个世界拱手让给我们讨厌的那些人。</p>
<p>另外，希望自己能更有行动力，我今年无疑是想得比做得多很多，这其实很不好。虽然在很多事情上需要细火慢煨、想清楚了再行动，但有些不那么重要的事情上早行动会带来更多切实的好处，至少实践也会加深自己对事物本身的理解。运用 72 小时法则 —— 一件事情如果 72 小时内没有开始，那你很可能永远不会开始。我经常有一些不错的主意，但很多时候没有好好完成使得并没有充分利用好这样的灵感和机会，这是很可惜的。</p>
<p>最后，希望自己能更有专注力吧。看到一种说法是专注力是一种稀缺资源，用完了就没有了。我将信将疑。但我打心底里认为，用强迫自己的方式做自己本身不认同或不喜欢的事情是难以为继的，从这个角度来说，专注力的确是一种用完了就没有的稀缺资源。另一方面，能否专注其实反映的还是自己内心的安定程度，希望新的一年自己的心态能更安定，意志力能更强。</p>
<p>Hope for the best and prepare for the worst. Always!</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
        <tag>人生</tag>
        <tag>投资</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>如何开始稳健投资</title>
    <url>/2022/03/13/how-to-start-investing-soundly/</url>
    <content><![CDATA[<p>如何开始稳健投资？作为一个不单单以赚钱为目的十分业余投资者，想凭借自己四年左右的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E7%BA%A7%E5%B8%82%E5%9C%BA">二级市场</a>摸爬滚打的粗浅经验，用不断拆解标题的方式来浅显易懂的回答一下这个问题。</p>
<h2 id="「投资」"><a href="#「投资」" class="headerlink" title="「投资」"></a>「投资」</h2><h3 id="正确的金钱观"><a href="#正确的金钱观" class="headerlink" title="正确的金钱观"></a>正确的金钱观</h3><p>首先，我们的行为是「投资」，不管你的目的如何 —— 虽然我相信绝大部分人的首要目的就是实现财富增值，这很好，相当好 —— 但如果你天生或者后天养成了对金钱和财富的潜意识仇视或厌恶（这并不少见，古语有「贫贱不能移」，中华文化传统就有清贫审美观，普遍认为钱是俗物，商贾之人自古以来社会地位就不高），建议你尽早改变这个观念，先对金钱有一个正确的认识，再继续读下去。我不想在这篇博客里本末倒置做过多赘述，有这方面问题的朋友推荐看<a href="https://book.douban.com/subject/35295592/">《小狗钱钱》</a>和<a href="https://book.douban.com/subject/25816940/">《富爸爸·穷爸爸》</a>来解决这方面的认知问题。</p>
<p>另外，如果你想快速暴富，直接点「返回」或者关闭页面，谢谢。</p>
<span id="more"></span>

<h3 id="本金从哪里来"><a href="#本金从哪里来" class="headerlink" title="本金从哪里来"></a>本金从哪里来</h3><p>投资首先需要有本金。本金从哪里来？这个问题对于开启投资行为而言可太关键了，本金是一切活水的源头。</p>
<p>资本增值首先得有资本。我所知道的很多相对年轻或有名或无名的实现财务自由的人生故事里，他们大多早早通过创业、自媒体、家庭资助等方式获得了值得用来投资的第一桶金，再通过这样的本金在资本市场实现巨幅财富增值。不管是通过什么样的方式，如果你很幸运有比较快速的方式积累到你的第一桶金，那你已经超越了绝大多数投资者了，因为第一桶金往往是难度最大且最费时间精力的。这就像滚雪球，不同的人通过不同的方式获得的初始雪球的大小不一，雪球越大在固定时间内能沾起来的雪花越多，而且是呈指数级增长。</p>
<p>当然，对于我们大多数普通「打工人」而言，只有每个月或每年固定的薪水用来投资。我一直认为拿去投资的钱不能影响正常的生活，不能降低原有的生活品质，所以如果你的工资扣除你的开销已经所剩无几，那也先暂时不必考虑投资了，收藏本文，努力提高自己的基础固定收入，等每月结余足够可观之后再开始吧。这不仅仅是赚多赚少的问题，如果你的现金流不够充裕，你就会很容易在资本投资行为中作出不理智的决策，那时候股市不仅不是你用来实现财富增值的手段，反而会成为你好不容易积攒的本金的坟墓。当然，每个人的具体情况不同，开销的绝对量和占收入的比重（相对量）差别很大，很难给出定量的标准。</p>
<p>总结来说，拥有足够量的本金对于开始投资非常重要，不管你是有足够的存量资金，还是可预期的稳定持续的未来的现金流。如果达不到条件，不开始比开始更好。</p>
<h2 id="「稳健」"><a href="#「稳健」" class="headerlink" title="「稳健」"></a>「稳健」</h2><p>什么是稳健？其实我上面的段落已经稍微体现出了我对于稳健投资的基本准则，我觉得开始投资前首先要给自己定以下几个绝对不能打破的「红线」原则：</p>
<ol>
<li>「不会死」永远是最重要的、永远值得首先考虑。这不是指你生命的消逝（当然身体健康比投资要更重要、重要、重要得多！），而是说任何时候你都要保证你的本金在 99.9999% 的情况下不会变成 0。风险是客观存在的，但很多方式可以让你的本金不会浮亏到 0 甚至是负数（想想 2020 年的原油宝事件），这首先意味着你永远不要<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E9%87%91%E6%A7%93%E6%A1%BF">上杠杆</a>或者进行<a href="https://zh.wikipedia.org/wiki/%E6%9C%9F%E8%B4%A7">期货</a>投资（更不用说投资币圈、P2P、各种没有资质的伪装成投资的诈骗盘了）。</li>
<li>在不能完全依靠投资自给自足的阶段，投资不能影响自己的主业。也就是不能太占用自己的时间和精力。</li>
<li>投资不能降低自己的生活品质。</li>
<li>即便损失掉所有用于投资的本金也不会使自己的资产大幅缩水难以翻身。当然，不同的人在不同的人生阶段能承受的风险水平不同，相对而言，越年轻的时候可以适当承担更高一点的风险。比如刚毕业一两年的年轻人，本身拥有的资金量很有限，即便损失掉所有的存款也相对可控（因为处在工资能快速增长的阶段，两三年后可能工资就能翻倍，损失的绝对量相对小），所以即便把 70% - 80% 左右的存款用于投资都是可以考虑的。这实际上是个人资产配置的范畴，投资策略与资产配置策略息息相关。</li>
<li>投资的品种在 99.99% 的情况下不会跌到 0。</li>
<li>得用至少三到五年肯定用不到的闲钱用来长线投资。这是为了保证在整个投资阶段的任何时候不会因为市场以外的个人原因做出赎回（卖出）的操作。</li>
<li>投资行为要让自己感到舒服。如果做一件事不会让你感到舒服，你不可能长久的进行下去。如果在投资行为过程中的任何时刻让你觉得不舒服了（仓位低了或者高了、被深套了、存量资金不足了等等），都意味着你的策略或者心态出现了问题，都会导致你做出不理智的操作，这时候需要反思你的投资策略问题出在哪，并对它进行不断的改进（而不仅仅是针对少数几次操作的调整）。</li>
</ol>
<h2 id="「如何」"><a href="#「如何」" class="headerlink" title="「如何」"></a>「如何」</h2><p>这一部分将讨论在以上原则的指导下，<strong>以 A 股市场特点为基础</strong>，对于投资小白而言的更具体的<strong>长期</strong>投资策略。</p>
<p>首先，<strong>假设</strong>我们先选一个单一的品种进行投资，在第 1 条和第 5 条原则的指导下，个股对于小白而言基本就先不考虑了，因为任何一个个股都有可能跌没。那我们得从基金中选，基金分为<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%8A%A8%E5%9E%8B%E5%9F%BA%E9%87%91/9125882">主动基金</a>和<a href="https://baike.baidu.com/item/%E8%A2%AB%E5%8A%A8%E5%9E%8B%E5%9F%BA%E9%87%91/9125945">被动基金</a>，这其中的选择对于小白而言就各有优劣了，感兴趣的话可以自行去了解。如果你想有一个自己掌控度比较高的策略，那就应该会选择被动基金（指数基金）。指数又可以分为<a href="https://zhuanlan.zhihu.com/p/77980205">宽基指数和行业指数</a>，其中宽基指数基金相对风险更低。对于 A 股而言，以下我们以最典型的追踪<a href="https://zh.wikipedia.org/wiki/%E6%B2%AA%E6%B7%B1300">沪深 300</a> 指数的基金为例来讨论具体的策略。因为这个品种基本只要中国股市不关门，它都会一直存在并且不会死。</p>
<p>选定了投资品种，我们如何开始买入卖出呢？</p>
<p>首先，在开始真正操作之前，你得想好自己的具体策略，考虑到各种各样的可能情况下自己如何应对。这样做是因为市场作为一个复杂混沌系统在现有的技术条件下基本是不可预测的，我们的策略不应该建立在对市场走势预测的基础上，而应该建立在对各种可能情况到来的应对之上。而且「预测市场」是个伪命题，任何对市场本身的预测反过来都会影响未来市场的走势。</p>
<p>其次，基于第 3、4、6 条原则，尤其是第 6 条原则，<strong>充分考虑你的存量资金和未来稳定的现金流下</strong>（注意，稳定的现金流可能短时间看起来「稳定」，但人生无常，不代表这样的资金流不会消失，要充分给自己留足安全垫），一开始就<strong>明确想好</strong>你未来所有会投入市场的<strong>资金总量</strong>。比如你打算投入一百万，之后你甚至可以假想把你的整个资金分为一百份，每份资金一万。这样做是让你在未来进行买入、卖出的操作时对你的可投入资金和单次操作的资金量有一个非常直观和定量的衡量概念。</p>
<p>接下来，在你也许踌躇满志兴致勃勃的准备开始「入坑」的时候，我得泼一盆冷水。因为在大多数 A 股市场起起伏伏普普通通平平凡凡的日子，你都不需要做任何操作，这不仅是长期策略本身的要求，也符合第 2 条指导原则。耐心在资本市场永远是美德。那么什么时候值得操作呢？我不打算在这篇针对投资小白的策略讨论里做任何数学计算，或者引入各种<a href="https://zh.wikipedia.org/wiki/%E8%B5%84%E4%BA%A7%E4%BC%B0%E5%80%BC">资产估值</a>指标的概念。一个可能的非常简单的策略是，如果你发现 A 股因为疯狂连续大幅下跌上了微博热搜、各种微信群里出现各种关于「绿色」的投资段子、很多你的好友开始吐槽自己投资的股票基金的大幅回撤，你就可以考虑买入了。买多少呢？总的原则来说，跌得越重应该买的份数越多。A 股大盘大概跌到了什么位置其实关注股票的人都是可以大概感受到了，大底是不可预测的但是底部区域相对是可以觉察到的。大概给出一个量化的标准是，在 2018 年沪指（<a href="http://quote.eastmoney.com/zs000001.html">上证指数</a>）处于 2500 左右这样的位置的时候（我这里用沪指作为一个小白都更熟悉点位的指标来说明，实际上你更应该看你的投资标的的市场位置，在这个例子里是沪深 300 指数的市场位置），你基本已经可以投入 70% - 80% 的资金量了，也就是你的 100 份资金的 70 - 80 份资金。当然，这样回头看市场再给出操作标准是非常不负责任的，因为你不能期望未来的沪指大底也在 2500 点左右（市场不可预测）。但你永远可以看你的投资标的的历史走势，如果能结合你关注的各种财经博主、公众号对于现在市场的位置综合判断会更好。更具体一点，就当下的市场位置而言，沪指在 3300 点左右，上周 A 股因为连续大跌上了微博热搜，我会开始考虑进行买入，结合一些市场声音对 A 股位置的判断，A 股基本跌到了一个合适的黄金坑的入口位置，你基本可以把你的仓位控制在 50% 左右（即从零开始已买入 50 份资金，仅举例）。这样做是因为，如果 A 股继续下跌，甚至跌到四年前的 2500 点（这个点位我应该会控制仓位在 70% - 80%），你依然有充足的资金用来补仓抄底；如果 A 股从此止跌开始回升，我觉得 50% 的仓位也会让自己心里比较舒服不会让自己觉得仓位太低。记住，市场永远是经不起预测的，你只能应对。另一个侧面的标准是，你几乎不会让自己处于满仓（100% 仓位）的状态下，或者这样的时候会很短暂（个人而言，我不能允许满仓超过一个月）。在满仓的情况下如果市场还在不断下跌，你的心态会非常不稳定，违背了第 7 条原则，你会很容易产生<a href="https://baike.baidu.com/item/%E6%AD%A2%E6%8D%9F/1683">「割肉止损」</a>的想法。所以宁愿错过一些利润也不要让自己处于一种危险的境地，这也符合原则 1 的要求。当然，如果你真的因为节奏控制不利，早早投完了 100 份资金，那就坚定的控制自己不会有更多的投入，任凭市场风云变化，都坚定地等待市场雨过天晴的那一天。总结来说，对于买入操作，在大部分时候你不需要做任何操作，在真正值得买入的位点，慢慢按个位份数积累仓位，控制仓位比例与市场位置相关，不要让自己轻易满仓，如果不小心满仓了即便继续下跌也停止买入操作。</p>
<p>何时买入的问题基本解决之后，如何卖出呢？对于长期价值投资策略而言，卖出操作往往比买入操作的次数更少、也更难。股民中有一句俗话是「会卖的才是师父」，确实是这样的。针对当下的 A 股特点，这样的卖出策略你或许可以考虑：</p>
<ol>
<li>牛市不来永远不卖，如果牛市来了，当所有人都陷入疯狂的时候（你公司的扫地阿姨都开始谈论股票想要买入的时候），果断清仓；</li>
<li>与买入策略对应，根据当前的市场位置控制仓位对应比例的卖出，比如沪指在下跌过程中 3500 点的时候你的仓位在 30%（举例而已，实际上我觉得 3500 点也许不值得 30% 的仓位），那你可以在沪指经过一轮下跌再上涨到 3500 点的时候把你的仓位卖出到剩 30% - 40% 左右。不过，跟几乎永远不要满仓对应，你也应该留一部分仓位（比如 20% - 30%）作为压舱石，用 1 的策略来卖出，否则你永远赚不到股市疯狂上涨阶段的涨幅。</li>
</ol>
<p>如果你深入思考，你会发现 1 的策略更适合超长期的价值投资，真正意义上的赚取大盘长期上涨的利润，但却丢失了市场反复波动阶段的利润，也付出了时间成本；而 2 的策略则融入了波段的思想，更适合反复波动的市场阶段，但在市场的疯狂上涨阶段，你的仓位已经不是很多了。另外，有一个说法是 A 股已经再也不会有短期牛市疯狂的表现了，所以你应该根据不同时期的不同特点来改进你的策略。为了实现对市场各种不同阶段的利润的收割，一个好的投资<strong>体系</strong>应该是针对短期、中期和长期都<strong>分别</strong>有不同的资金比例和策略应对的，在这篇里不再详述了。当然，以上示例策略只是我写这篇博客时候的拍脑袋的想法，没有经过市场的检验，目的仅仅是为了体现我前面提到的投资原则，你更应该有自己的经过深思熟虑之后的投资策略。</p>
<p>另外，这个示例策略还只是讨论了对单一品种的投资，下一个值得进阶的点是，你应该考虑对<strong>相关性比较低</strong>的多个品种进行投资（包括<a href="https://book.douban.com/subject/26752026/">《聪明的投资者》</a>在内的很多投资大师的著作有类似的观点），并且分配不同的仓位比例，不要让单一品种的仓位占比过高（比如当你的可投品种多了之后，控制每个品种仓位不会超过 20%）。这样做的理由是，相关性低的不同品种可以在市场的各个不同阶段降低你的总仓位的波动和<a href="https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%92%A4%E7%8E%87/3645063">最大回撤率</a>。不要小看这个指标，当浮亏过大时，你的投资心态会受到极大的影响，从而违背了第 7 条原则。而且，这些品种各自会有不同的周期和阶段，你可以更灵活的将某个上涨的品种资金回收用于其他处于低估值阶段的品种（但要注意控制单一品种的仓位比例），或者回收到现金池进行更大范围的资产配置，甚至可以达到一种「东方不亮西方亮」的效果，这是很符合第 7 条原则的。</p>
<h2 id="「开始」"><a href="#「开始」" class="headerlink" title="「开始」"></a>「开始」</h2><p>我为什么在这时候想写这篇博客，很大程度上是因为这个时间点可能会是一个比较好的开始投资的时间点。不像很多投资大 V 所吹嘘的，我从来不认为无脑定投是一个好的投资策略，完全的定投很难在可以接受的时间跨度内实现满意的收益率，而时间成本其实对一个人短暂的一生而言远远比我们以为的要重要很多。所以投入的时机其实很重要，当下的股市状态也许是一个不错的开始的时机，处于下降趋势中但应该还没有完全见底，估值不算特别便宜但是某些品种到了一个可以开始买入的点位，这是开始实践一个完整的投资周期的比较好的时间点。对于小白第一个的投资周期，在你还没有投入很多资金到资本市场的时候，没有亏损很重要，不过，能够在不同的市场阶段充分感受那个当下自己在心态、策略上的优势和不足，体会资本市场和世界运行的特点，不断沉淀出自己的经验和体会，可能会更重要。</p>
<p>我自己是从 2018 年左右正式开始实践股票市场投资的，在一个非常偶然的机会了解到了 <a href="https://weibo.com/u/5687069307">ETF 拯救世界</a>的<a href="https://www.zhihu.com/question/65793376">「长赢指数投资计划」</a>和<a href="https://qieman.com/">且慢</a>，我自己的投资理念、策略方法、心得体会大部分都来自于此，我觉得这至少是一个非常值得参考的策略（利益声明：本人跟 E 大和且慢没有任何除开跟投外的私下利益关系）。巧合的是，2018 年 A 股在我开始投资不久就经历了阶段大底，现在回头看，我觉得我是碰巧在一个比较好的时间点开始了我的投资之旅，那个时间点我感觉跟现在的阶段很类似（很多投资大师之所以能长期实现稳定的收益率，一个可能的原因就是他们不会把幸运归因为是自己的实力，从而能避免因为单次的侥幸而不思改进，很多看似成功的投资个例，其实都仅仅只是幸运而已，运气因素在成功投资中的占比可能比我们认为的要高一些）。当然，即便是做简单跟投，我觉得任何参与资本市场投资的人都应该有自己的独立思考和认知，至少应该要认同你用真金白银做的投资操作和策略，做到知行合一，你才不会在股市的动荡旅程中被中途甩下车。<a href="https://sspai.com/post/62828">「投资是认知的变现」</a>，我是深以为然的。</p>
<p>此外，养成记账的习惯，时刻把握自己的资产配置状态，是开始投资的首要前提。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最后，如果你真的想开始投资或者已经在投资，我觉得任何时刻都需要怀有「敬畏市场」的心，这不是一个有简单线性因果关系或简单相关性的领域，不要试图以你自己道听途说的消息、简单线性的对复杂世界的肤浅理解来进行任何脱离策略和原则的想当然的操作，永远要有「价值、概率、长期和非线性」的投资思维（我在<a href="https://maples7.com/2019/12/31/2019-booklist/">《2019 年书单》</a>最后部分对这四个词有详细阐述），要有怀疑和独立思考的精神。</p>
<p>有时候我觉得投资过程跟探索人生很相似，充满了混沌、未知和不确定，又永远有不期而遇的惊喜，你再强大也只是市场的学徒、浩渺宇宙中的沧海一栗。</p>
]]></content>
      <categories>
        <category>滚雪球</category>
      </categories>
      <tags>
        <tag>投资</tag>
        <tag>理财</tag>
        <tag>基金</tag>
        <tag>ETF</tag>
      </tags>
  </entry>
</search>
