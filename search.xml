<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>没有微信的 24 小时里</title>
    <url>/2014/09/25/24h-without-wechat/</url>
    <content><![CDATA[<p>也是前不久在《简书周刊》上看到一篇文章，作者讲述自己在删除了所有手机上的社交 App 后的种种感受。或许我们都早已承认社交网络已经深刻的影响着我们的日常生活，但在看到那篇文章之前，我还真没有意识到离开以微信为首的社交 Apps 之后会是一番怎样真切的感受。</p>
<p>当时钟快要滑向凌晨的时候，脑袋一热，于朋友圈(juàn)留下一条「绝笔状态」，便删除了手机和 iPad 上的冠以「社交」两字的文件夹。自我感觉良好。对于我这样的重度社交 App 依赖患者，这也是一件颇值得考究的行为。大概这就是极端下的自我厌恶吧。</p>
<span id="more"></span>

<p>在多看怒刷完两百页电子书，很理智的抑制住自己想要分享到朋友圈(juàn)的习惯性冲动，美美地进入了梦乡。</p>
<p>生活是平凡的，也是不凡的。我们以天、以周、以月、以年为周期重复着我们的生活，却总可以在这样的重复中感知点点滴滴的变化，并始终保持着对未知的下一秒的期待。或许你早已经熟悉，讲台上老师混杂着方言与普通话的语调，却总可以在桌洞里冒出来的小纸条上发现惊喜。这些惊喜都促使你产生了对朋友圈(juàn)的冲动。朋友圈(juàn)成了我们每天精彩生活的缩影。一条段子，一张自拍，一个玩笑，甚至是一句抱怨，寄托着我们的情感，都流淌到了朋友圈(juàn)里。更让人着迷的是，那些远在天边的、近在你旁边的、几乎不联系的、天天联系的、熟悉的陌生的、认识的不认识的，都可以在你的状态下轻轻地点上一个赞，或者感触相似者还会稍加评论一番，似乎是对自己发布的这条状态的奖励。久而久之，潜意识开始依赖这种奖励式的互动方式。</p>
<p>朋友圈(juàn)，圈养着我们的朋友们。</p>
<p>于是，上课、开会无聊时，会刷一刷朋友圈(juàn)；食堂排队等饭时，会刷一刷朋友圈(juàn)；自习看不下书时，会刷一刷朋友圈(juàn)。甚至，重度患者如我，解锁开屏幕的同时，手指也就不自觉的落在了「社交」为名的文件夹上，忘了最初为什么要拿出手机了。</p>
<p>所以，没有微信的这 24 小时里，我的感受是复杂的。</p>
<p>这是一个从平静变得焦虑的过程。刚开始，会有那么一丝丝的成就感：看，没有刷微信我多看了多少页书，多做了多少道题，多背了几个单词。内心是多么的安宁和满足。再然后，开始抱怨和不满。之前任何刷微信、刷人人、刷微博、刷知乎的个人「基本需求」都可以简单快捷的通过 Apps 得以满足，现在，这长期培养出来的个人需求被硬生生地截断了。我开始更多的依赖浏览器，用浏览器刷知乎，刷微博，然后对网页版渣成翔的用户体验充满怨念。紧接着，我开始有些许期待朋友圈(juàn)的朋友们又给我评论些什么，又产生了哪些新鲜事，我又错过了哪些让我开怀大笑的段子。我也才意识到，社交网络，尤其是微博和各种微信公共账号，已经成了我每天浏览新闻、了解这个世界的主要途径。</p>
<p>又一次快要凌晨的时候，我已经难以说服自己承受这种刻意压制自己需求带来的些许焦虑感。但是，我昨天才在朋友圈(juàn)发的「告别状态」啊……在反复纠结当中，我最终还是选择了顺遂自己的心意。我还真怕这激烈的克制对心理造成不良的影响。看着朋友圈(juàn)上的红色标记，在点开的一瞬间，我似乎感到了一种解脱和释然。</p>
<p>毫无疑问，互联网让我们的生活质量有了质的飞跃。同时我们也越来越依赖于互联网带给我们的更开放、联系更紧密的社交生活。但是，这种看似频繁的社交联系真的带来了真实感情上的亲近吗？</p>
<p>可笑的是，就在我正在码字之时，我也边回复着微信、QQ 好友发来的各种消息，并且我还很可能会把这些文字分享到我将持续刷下去的朋友圈(juàn)里。</p>
<p>不过，值得一提的是，经过这 24 小时的实验，我想我会更加注意适度的去控制打开这些社交 Apps 的频率，我将更能深刻体会社交网络给自己的日常生活带来的真切的影响，我将开始有意重新培养自己长篇阅读以及长时间专注的能力。更依赖社交网络的同时，也会更加珍惜和谨慎的去把握好那个「度」了。</p>
<p>下次再刷屏的时候，不妨想想，是你在刷屏，还是屏在刷你？</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>社交网络</tag>
      </tags>
  </entry>
  <entry>
    <title>大理：一场风花雪月的事</title>
    <url>/2014/09/21/dali-things-about-wind-flowers-snow-and-moon/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=29777634&auto=0&height=66"></iframe>
很多人知道大理这个地方，大概都与金庸的小说《天龙八部》有关。未到大理，这座想象中的古城或多或少会让人有关于生死大义、爱恨情仇的武侠幻想。这种感觉仿佛像是将要误入边陲一隅的桃花源，少了现代生活的喧嚣与紧张，剩下的只有这座与世隔绝的古城的林林总总。

<p>从丽江到大理，已是凌晨，火车站都显得有些僻静。偶有一两个旅店拉客的老板。经历过丽江和香格里拉不大愉快的消费经历，必定是对这些「上门推销」的人存在戒心的。但最后还是无奈于「夜已深、天微凉」，也就上了辆「贼车」了。</p>
<span id="more"></span>

<p>从大理火车站到大理古城，车程也要几十分钟。夜色中的大理，只有「静」可以来形容，这种静，简直是静到人的灵魂深处。没有流光溢彩的街灯，没有灯火通明的夜市，有的，只有那一轮朦胧的月。再放眼远处，只有连绵不绝的高山，在月色下影影绰绰地把整个大理城围着。而山脚下不大的大理古城，夜色里只剩一抹温柔。</p>
<p>如果你想让自己的大理之行与众不同，深夜的大理古城是一定要逛的。我们住的客栈在古城西边。从西城门对面的小巷一路向城走，那种感觉，简直是回到了只存在于记忆中的童年。月色皎洁，映照着石板路，没有路灯。幽深的古巷里除了你一个人也没有，偶有狗吠，却也慢悠悠融合在这夜色里。有个有意思的说法是，大理的狗是不咬人的，也不知是真是假。进入古城，想找个夜宵摊竟也是一件颇为难的事情。这里完全没有我们所想象的热门旅游景点的样子，有的完完全全就是小镇的生活气息，日出而作，日落而息。深入古城很远，也不见一家亮着灯的夜宵摊。偶有开着小门的小店铺，昏黄的光从屋内流泻出来洒在石板路上，彷佛你自己又置身于记忆深处的童年。久不遇夜宵摊，只得在小店铺买了点零食，遂折返。</p>
<p>沈从文曾写过一篇名为《云南看云》的散文，看云来云南，是的确不假的。大理的云尤其有其独特之处。早晨，透过客栈的落地窗，一睁眼，映入眼帘的便是天空大片大片的云。单说云，其实还不够准确，应该是在湛蓝湛蓝的天空背景下的云。因为即便是这样的云，放到北京，我相信也是「无福消受」的了。</p>
<p>来大理这种地方，如果你不想毁了自己这趟旅行，是万万报不得团的。无论何种形式的团，最好都避而远之。自己去当地的青年旅馆租一辆自行车，便可以开始自己一天的旅行了。</p>
<p>白天的大理古城终于有了一个旅游景点该有的景象，但即便是游客如云的地方，也绝对少不了当地人的身影。他们似乎早已对这些外来人习以为常，只是经历着自己的生活，经营着自己的日常，浓郁的生活气息让人感到分外温暖。在古城吃过当地的特色早餐，便开始逛古城了。古城城墙很厚，城墙上竟可以看到民宅，可谓奇特。古城的街道与丽江古城让人找不到北的弯弯曲曲的小巷不同，都是笔直的，从北门直通南门，从东门直通西门。方方正正，直来直往，似乎也是这里的特色。站在高高的城门上，或俯瞰古城，或眺望远处的苍山洱海，都是甚为壮观的。这不禁让人想象历史当中的大理古城，是多么气派和繁华。同样，与丽江古城已经被外来人的商业化腐蚀得不成样子不同，大理古城还保留着自己的本色。最让我感到印象深刻的，还是古城当中的老电影博物馆。进入博物馆，彷佛就进入了一段历史。那古朴的氛围和细腻的情愫，从古老的只能在电影中看到的放映机、胶卷中缓缓散发出来，述说着这座城市昨日的故事。</p>
<p>每个旅游城市都会有一些不能不去的景点。来大理，苍山洱海是一定要去看的。说是去看，其实在大理古城城墙一角，便早已看到了。那远处山峰插入云端的群山，便是苍山；与苍山相对的湖泊，便是洱海。其实吧，在大理骑自行车赏景，倒不如步行来得痛快。因为实际情况基本上是，每骑了二十米左右，便忍不住要停下来，然后拿出相机，开始拍照。不知是不是有季节和天气的原因，我们见到的苍山，美得简直让人醉了。而这美，还是因为云。这云与普通的天空飘的大坨大坨的云还不同，她彷佛是盖在苍山上的一床棉被，或者说更像是山那边有海水漫过来激起的白色的浪花，整个把山的上部完完全全的盖住了。而且过一段时间你再去看，云确实还慢慢地在往山脚下移动。到傍晚时分，简直已经盖住苍山的一半多了。苍山脚下，还有一个十分著名的景点——大理三塔。在《天龙八部》的经典电视剧版本中，就有这三塔的场景。</p>
<p>大理地处西南边陲，自古以来就有「妙香佛国」之称，这点从三塔建筑以及三塔到沧海的这条路的布局和建设就可以看出，此中玄妙，定是不少。从苍山到洱海，就体现了租来的自行车的价值了。我们特意选取了一条田野间的小路，找准洱海的方向，便出发了。路途依然是停的时候居多。从各种不同的角度回头看苍山，看大理古城，都有一番不同的感觉。</p>
<p>由于走了一条乡间石子小路，不久我们就迷失在小路尽头的建筑群中。大理当地主要的少数民族是白族，建筑也具有白族独特的风格。在询问过一个白族小孩儿过后，我们终于走出了建筑群，来到了公路上。这时候已经是下午三四点钟了，来到公路上我们才发现，像我们这样骑车来个环洱海游的还有不少。再骑了一会儿，终于来到了洱海边的环湖公路。夏季的洱海，是平静的。湖中央游荡着一两条小船，船夫撑着杆子戴着斗笠。湖边在风景好的地方，建有花园式的茶吧和旅馆，有秋千，有落地窗，甚至还有供游客租用的房车。但其实这样的商业设施还并不多，整体上还是一副田园自然做派。这时，看看洱海，再回过头看看被「云被」盖着的苍山，你会产生一种一辈子就留在这里的想法。</p>
<p>从洱海回到客栈，天已经黑了。虽然十分不舍，但计划好的晚上的火车就要离开这座古城了。收拾好了行李之后我便去了白天租自行车的青年旅馆还车。当时他们还在旅馆的庭院里摆着桌子吃饭，院子里停着各式各样的自行车和一辆卡丁车，显示出了这里年轻活泼的气息。待我从里屋里办完手续出来，一回头，我再一次被惊艳到。由于青旅对面就是民居的侧墙（白族建筑的墙面都是白色粉刷的，只在墙面边缘做少量装饰纹），青旅的年轻老板便将电视信号投影到了整面墙上，大家一起坐在庭院，磕着瓜子看着电视，似乎这已经是生活再平常不过的事情了。看着这一幕，我硬生生地站定愣住了。感慨着这天然幕布真好的同时，两行热泪差点没掉出来。这样很多人围在庭院里乘着凉休息聊天的场景，大概也只存在记忆深处中的童年了吧。</p>
<p>大理是适合情侣一起去的地方。你可曾想象和自己喜欢的人躺在城墙上，只是看着天上的蓝天白云；骑着双人自行车来洱海边看日落；登上苍山一起抚摸那一床「云被」；凌晨时分逛着古城一起找寻那昏黄的街灯……</p>
<p>如此种种，便已是人生难得的幸福。</p>
<p>在大理，观苍山，品洱海，我又开始期待着，那一场风花雪月的事儿。</p>
]]></content>
      <categories>
        <category>在路上</category>
      </categories>
      <tags>
        <tag>大理</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>人类，请收起你们虚妄的自尊心</title>
    <url>/2016/03/18/humans-please-hold-your-humanity-back/</url>
    <content><![CDATA[<p>人类纪元，公元 2016 年 3 月中旬，一件令全世界瞩目的事件即将发生，世界围棋冠军李世乭九段与 Google DeepMind 团队研发的围棋人工智能程序 AlphaGo 之间的围棋五番棋大战即将展开，一时间「人机大战」、「人GO大战」等词充斥于各大社交网站和媒体。几天过后，最终以人机 1:4，AlphaGo 轻松打败李世乭九段而取胜。</p>
<p>有意思的是，赛前，新浪体育和新浪科技都对网友做过调查，在新浪体育的调查结果显示，认为李世乭将战胜 AlphaGo 的网友占 72.7%，而在新浪科技的调查结果中显示，认为李世乭将获胜的网友占 47.8%。</p>
<span id="more"></span>

<p>我无意于对比和分析同属于新浪两个频道的调查结果产生差异的原因，毕竟实际的目标用户就不同。不过这个数据从一个侧面说明，赛前普通大众中的更多人还是觉得机器在围棋上还是无法战胜人类的。这一点，从微信朋友圈赛前赛后所有有关这场比赛的文章标题，就可以明显看出语气上的落差。</p>
<blockquote>
<p>19年前，深蓝战胜卡斯帕罗夫的时候，中国人一片那种「计算机虽然已经很厉害了，但是那是因为西洋象棋本身不够高深，咱们中国发明的围棋博大精深、玄妙无比」之类的论调。当年我才 17 岁，也陶醉在中国文化博大精深这种民族自豪感的情绪里。今天我终于知道，这世界，终究是要向前走的。</p>
</blockquote>
<blockquote>
<p>—— 来自社交网络，出处未知</p>
</blockquote>
<p>诚然，强人工智能的时代可能还很遥远，但它总有一天将要到来。或许目前依然有不少人怀疑人类是否能突破强人工智能的技术难点。你我（可能）都不是研究人工智能的专家，无法从科学上给出一个或肯定或否定的回答。即便是专家，或许自己也难以给出一个肯定的答复。但从哲学的角度上说，人工智能对于人脑智能的模拟总有一天是可以无限趋近的。如果你承认人脑——作为自然界存在的事物之一——不可被研究，那就已经在无意中陷入不可知论的框架中去了。</p>
<p>从赛前的大众舆论可以看出，人类对于自己在这世界上独一无二的智能能力还是感觉十分良好的。而在第一局李世乭败给了 AlphaGo 之后，从第一时间少部分人在社交网络的言论可以看出，有些人似乎隐隐有一种被机器「羞辱」了的情绪在。知乎上开始出现这样的问题：「如何杀死一个人工智能？」。潜意识中，这些人已经把人类和人工智能对立了起来。</p>
<p>其实如果真要认真地试着来回答知乎上的这个问题，不先完整地定义人工智能这个问题根本无从开始。其中我看到最多的答案大概是「拔掉电源」，还获得了不少赞。试想如果真的是一个无论从外形还是综合能力都已经跟人类相似甚至超过了人类的强人工智能，欸，下半句都不必说了，你还记得<a href="https://movie.douban.com/subject/4160540/">《机械姬》（Ex Machina）</a>的结局吗？另外，谁又说过人工智能一定是具有具体形态的呢？</p>
<p>当然，创作毕竟是创作，如电影中这样的强人工智能能不能诞生还很难说。这并不是否定我前面所说的强人工智能「总有一天将要到来」，而是因为人类可能无法到达强人工智能诞生的那一天就可能因为其他更严峻的问题遭受到重大打击甚至灭绝，比如与外星文明的接触（引力波被发现了还记得吗？）。</p>
<blockquote>
<p>如果你不觉得老婆比自己聪明会让自己显得没有尊严，那么机器比自己聪明同样不应该让你觉得丢脸。</p>
</blockquote>
<blockquote>
<p>—— 字节社创始人，《IT公论》主播不鳥萬如一</p>
</blockquote>
<p>其实，人工智能的胜利正是显示了人类创造的强大能力，但同时也应该清楚，人工智能很可能是人类有史以来最值得争议的创造，甚至可能决定了人类的存亡。是不是队友，现在还很难说。</p>
<p>不管你现在承不承认，强人工智能总有一天将会到来，并且 Ta 们的能力总有一天会超过人类。所以，让我们收起那些无处作祟的虚妄的自尊心吧。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>AlphaGo</tag>
      </tags>
  </entry>
  <entry>
    <title>无复屠苏梦，挑灯夜未央</title>
    <url>/2016/02/24/no-childhood-dream-night-does-not-fall/</url>
    <content><![CDATA[<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b672af6aaec0.gif"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b672af6894bf.gif"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b672af6a19b2.gif"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b672af6baeb1.gif"></div></div></div>

<span id="more"></span>

<br />

<p>图片已经过裁剪与压缩，原图在这里：<a href="https://maples7.tuchong.com/12896822/">https://maples7.tuchong.com/12896822/</a></p>
]]></content>
      <categories>
        <category>视觉动物</category>
      </categories>
      <tags>
        <tag>黑白</tag>
        <tag>Sony DSC-RX100</tag>
      </tags>
  </entry>
  <entry>
    <title>我的密码管理策略</title>
    <url>/2016/04/06/my-strategy-about-passwords-management/</url>
    <content><![CDATA[<p>[ 本文来自于<a href="https://www.zhihu.com/question/19695004/answer/93985563">我的知乎回答</a>，现整理修改后记于博客。]</p>
<p>随着互联网时代的发展，世界上的每个个体与互联网的关系也变得愈发紧密，而移动互联网更是极大的促进了这种趋势——一部手机，世界就在你手中。</p>
<p>伴随着这种趋势而来的，是个人对于互联网应用的依赖激增，每个人每天几乎同时使用着几十款互联网应用，如何管理这些互联网应用的个人密码并保证足够的安全性变得重要起来。</p>
<p>本文介绍一下我的密码管理策略。</p>
<span id="more"></span>

<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>有人可能会直接推荐使用一些密码管理工具（比如 1Password、LastPass 等）来管理自己的密码，但我不打算采用。任何工具在将来都存在不可靠的可能，但自己的大脑却是值得信赖的。</p>
<p>如果用做一款互联网产品的思维来思考，首先这套策略应该是对用户友好的（人脑可兼容的），但同时又必需在日益复杂的互联网环境中具有足够的强度。</p>
<p>列出的需求如下：</p>
<ul>
<li>强度足够；</li>
<li>易于记忆、输入方便；</li>
<li>方便生成与定期更换；</li>
<li>不借助密码管理工具，任何工具都不一定可靠；</li>
<li>不同应用的密码应该不一样，不把鸡蛋放一个篮子里；</li>
<li>加入随机因子（或伪随机因子）；</li>
<li>密码中无个人永久信息；</li>
</ul>
<p>其实这就是如何在方便和复杂这种天然的矛盾中找出人脑可记忆的那个平衡点。</p>
<h3 id="策略细节"><a href="#策略细节" class="headerlink" title="策略细节"></a>策略细节</h3><p>依据这样的需求，我构思了这样一种方案：</p>
<h4 id="构造基础字串：应用特征信息-私钥"><a href="#构造基础字串：应用特征信息-私钥" class="headerlink" title="构造基础字串：应用特征信息 + 私钥"></a>构造基础字串：应用特征信息 + 私钥</h4><ol>
<li><p>应用特征信息：</p>
<p> 由于需要每个应用密码都不同，而且自己又要记得住（或者可根据一定规则推算出来），所以基础字串中一定要有应用的特征信息，可以是 URL 的某一部分、应用名，甚至是页面源代码的倒数第五个非 html 元素等等。</p>
<p> 总之这个信息应该至少具备两个特点：基本不会变化 + 规则固定（最好是一眼就可以看出来的，取决于自己决定的规则）。</p>
</li>
<li><p>私钥（或者说 salt）:</p>
<p> 我决定用一段时间内自己特别关注的某个点来定义私钥，由于这个信息可能是自己在这一段时间内特别关注的，所以一般也不会忘记。</p>
<p> 这个的灵感来源于这个答案：<a href="https://www.zhihu.com/question/24306804/answer/29038524">用什么方式记密码最好？ - 匿名用户的回答</a>。你也可以根据这个答案的内容来确定自己某一段时间内的私钥。</p>
<p> 注意：由于私钥过一段时间更换一次，所以密码随着私钥更新也要更新（稍后会讲维护方法），这相当于添加的一些与应用无关的随机因素，而别人一般也不可能猜到。</p>
</li>
</ol>
<p>基础字串由应用特征信息和私钥组合而成，至于组合规则你可以简单拼接，或是更复杂的交叉拼接都可。不过这里还是建议简单点设计，便于记住。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>在基础字串的基础上，根据一些替换、交换次序等特有规则进行编码，灵感来源于 <a href="https://www.zhihu.com/people/e5fb0aab23f1ebca897594c74d178c79">@吴涛</a> 的这个回答：<a href="https://www.zhihu.com/question/19695004/answer/12976049">如何管理好自己的密码？ - 吴涛的回答</a>。这样的规则也不宜过多，总之以自己能方便记住和输入为原则。</p>
<p>一旦你的规则确定下来，这样就生成了你的某一个应用的唯一密码。</p>
<h3 id="具体实践"><a href="#具体实践" class="headerlink" title="具体实践"></a>具体实践</h3><p>对于具体实践，我还设计了这样的维护方案：</p>
<h4 id="根据规则写成脚本"><a href="#根据规则写成脚本" class="headerlink" title="根据规则写成脚本"></a>根据规则写成脚本</h4><p>如果会编程可以把以上自己确定下来的规则写成脚本，方便自己在电脑上使用时不用多想一键生成密码（注意脚本中是不记录你提取出的应用特征信息和私钥的，所以即便脚本不小心被别人拿走也不知道你构建基础字串的方法）。</p>
<p>但是，写脚本并不是为了让你总是依赖它来生成你的密码进行登录，<u><strong>你应该总是能够在短时间内根据自己设定的规则在脑中生成密码</strong></u>。</p>
<p>脚本存在的最大的意义在于：注册时尽量使用脚本生成的密码，避免你自己确定的密码生成规则存在歧义的情况下导致以后的自己会生成不一样的密码而无法登录，因为代码是不存在二义性的（无随机语句类似的情况时），这可以为以后确定密码提供一个依据。</p>
<p>所以如果你不会脚本也没有关系，只要你保证自己设定的规则没有歧义就可以了。</p>
<h4 id="维护一个有两个列表的文本文件"><a href="#维护一个有两个列表的文本文件" class="headerlink" title="维护一个有两个列表的文本文件"></a>维护一个有两个列表的文本文件</h4><ul>
<li><p>  列表一是你或常用或重要的应用列表，如果是网站就记录网址，如果是应用就记录名字等等。</p>
<p>  在这个列表中的所有应用，都是你的核心应用，并且网站开发者具有一定的技术实力，至少它的密码加密方式一定不是很随意可破解的。</p>
<p>  对于这些应用，私钥绝对要使用你的最新私钥。注意这个私钥不要记录下来，而应该是你在这段时间内一定不会忘记的某些信息，这样即便这个文本被泄露别人还是不知道你的最新的私钥（以及密码生成规则）。</p>
<p>  这个列表也可帮助你在更新私钥之后有次序的依次更新这个列表中应用的密码。</p>
</li>
<li><p>  列表二是一些不重要或技术水平存疑的网站，比如学校网站、政府网站等等，这样的网站或应用不仅需要记录它的 URL 或者名字，还应该记录一个注册时采用的私钥。也就是说，这些应用的私钥不是最新的，而且密码也一般是永远不会改变的。</p>
<p>  这样做的原因在于，如果这些技术水平存疑或者故意使坏的网站对于你的密码没有加密或加密可轻易破解，这样在类似于拖库之后你的私钥和密码生成规则很可能都会被猜到，如此便极有可能影响到那些对你而言重要的网站或应用，那样你就不得不更换算法了。所以这里采用过时的私钥，相当于加筑一道防火墙。</p>
<p>  （如果这里觉得麻烦，也可以简单的对这些不重要的网站采用同一个密码。<u>不过最好还是按上述做法。</u>）</p>
</li>
</ul>
<p>即便这个文本文件泄漏，别人也不会知道你的密码生成规则、基础字串的构建方法和最新的私钥。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，总结一下，你需要做的：</p>
<ol>
<li><p>记住：密码生成规则（使用几遍就可记住）+ 最新的私钥；</p>
</li>
<li><p>把脚本和本地的文本文件做好备份，可以备份到多个硬盘、U盘或者你绝对信得过的云盘。</p>
<p>不过即便你的这俩文件都丢失了，你依然可以凭最新的私钥生成密码，所以那些重要的应用依然不受影响。并且你可以在浏览器中对这些网站添加书签并云备份，所以你的重要列表也不会丢，但可能不重要列表中那些年代久远的密码就找不回了。不过既然不重要，那又能怎样呢？</p>
</li>
</ol>
<p>目前这套方案我已经稳定使用了很久了，有人可能觉得规则过于复杂难以记住，实际上我在规则确定的第二天就能稳定快速的对任一款应用生成自己的密码。而且你使用的次数越多，记忆会越来越深刻，也会越来越不容易出错，是个正反馈良性循环。</p>
<p>同时祝你使用愉快。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>密码管理</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>巴山蜀水毓灵秀</title>
    <url>/2016/06/10/mountains-in-chongqin-and-water-in-chengdu/</url>
    <content><![CDATA[<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b672af6a96f4.gif"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b672af68b036.gif"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b672af6a29bb.gif"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b672af6a482e.gif"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b672af6a5fdb.gif"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b672af6b7aa7.gif"></div></div></div>

<span id="more"></span>

<br />

<p>图片已经过裁剪与压缩，原图在这里：<a href="https://maples7.tuchong.com/13205116/">https://maples7.tuchong.com/13205116/</a></p>
]]></content>
      <categories>
        <category>视觉动物</category>
      </categories>
      <tags>
        <tag>Sony DSC-RX100</tag>
        <tag>城市</tag>
        <tag>光影</tag>
      </tags>
  </entry>
  <entry>
    <title>非关系型数据库中的「关系」实现</title>
    <url>/2016/04/06/how-to-implement-relationship-in-nosql/</url>
    <content><![CDATA[<p>这两三年来，伴随着大数据（Big Data）的空前火热，无论是在工程界还是科研界，非关系型数据库（NoSQL）都已经成为了一个热门话题。</p>
<p>相比于传统的关系型数据库，非关系型数据库天生从理念上就给数据存储提供了一种新的思路。而在实际应用中，它往往更轻巧灵活、扩展性高，并且更能胜任高性能、大数据量的场景。</p>
<p>值得一提的是，NoSQL并不是 “No SQL” 的意思，而是 “Not Only SQL” 的简写。</p>
<span id="more"></span>

<p>尽管非关系型数据库没有关系型数据库中很多预定义的死板模式的限制，但自然数据间总是充满联系的，所以在数据库中我们势必需要抽象出这种数据之间的联系。</p>
<p>本文就个人实践经验，总结一下 NoSQL 数据库中表现数据关系的常见办法，并且结合一个实践项目来举例说明（样例为 Node.js 项目，使用常用的文档型数据库 MongoDB（Mongoose 来操作）来举例）。</p>
<p>方法如下：</p>
<h3 id="1-嵌套"><a href="#1-嵌套" class="headerlink" title="1. 嵌套"></a>1. 嵌套</h3><p>得益于非关系型数据库的灵活数据类型，我们可以直接将 Schema A 中的某个属性设置为「数组」类型，用以存储所有与它有 1：N 关系的其他数据对象。</p>
<p>举例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> commentSchema = <span class="keyword">new</span> <span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">time</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Date</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">content</span>: <span class="title class_">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> messageSchema = <span class="keyword">new</span> <span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">content</span>: <span class="title class_">String</span>,</span><br><span class="line">  <span class="attr">time</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Date</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">comments</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: [commentSchema],</span><br><span class="line">    <span class="attr">default</span>: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在上例中，一个 <code>message</code> 文档可能包含很多 <code>comment</code> 文档，所以在 <code>messageSchema</code> 的 <code>comments</code> 属性中用一个数组来存储某个 <code>message</code> 的所有 <code>comment</code>。</p>
<p>值得注意的是，这里 <code>commentSchema</code> 并不实际对应一个数据集合，它只用于在这里帮助定义 <code>messageSchema</code>。</p>
<p>相比于下面要讲到的引用的办法，这个方法适合于查询频繁（少了引用查询）、有强逻辑联系的 1：N 关系（即每次显示 A 文档都需要显示众多 B 文档）、且 B 文档改动较少（毕竟嵌套操作相对复杂一些）的场景。</p>
<p>这种方法也是 NoSQL 数据库相比于传统的关系型数据库的优势所在。</p>
<h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2. 引用"></a>2. 引用</h3><p>NoSQL 数据库中并不存在传统关系型数据中类似于 join 的方法，所以这使得我们的复杂查询可能会变得相对困难，好在很多封装好的数据库包提供了很多便利。</p>
<p>引用方法又可分为两种：</p>
<h4 id="Ⅰ-手动引用"><a href="#Ⅰ-手动引用" class="headerlink" title="Ⅰ. 手动引用"></a>Ⅰ. 手动引用</h4><p>手动引用很简单，就是在 Schema A 中定义一个 Schema B 中唯一（<code>unique</code>）的属性（一般为<code>_id</code>），每次当查询 A 后又需要查询 B 时，需要自己根据 A 中定义的 <code>_id</code> 值手动去查询 B 的完整数据。</p>
<p>方法简单，不再举例赘述。</p>
<p>不过，在实践中唯一值得注意的是：A 中定义的与 B 相关的属性应该不具备业务语义，且基本不会被改动，否则当你对 B 中的相应属性进行改动的时候，所有引用此 B 文档的 A 文档，都需要对定义的引用属性进行更新，这是绝对需要避免的！这也是为什么一般引用 <code>_id</code> 的原因（一般在生命期内都不会被业务需求改变）。</p>
<h4 id="Ⅱ-自动引用"><a href="#Ⅱ-自动引用" class="headerlink" title="Ⅱ. 自动引用"></a>Ⅱ. 自动引用</h4><p>自动引用是借助于类似关系型数据库中定义的 Reference key 或 Foreign key 进行预先的引用定义。在查询时，数据库可以根据事先定义的「引用键」进行解引用，找到引用到的另一个集合中的文档。</p>
<p>在有一些封装好的数据库操作包中，可以实现自动解引用的功能，即凡是检测到引用键就自动的去查询对应的文档进而解引用。不过即便不是自动解引用，手动解引用也会花费开销进行查询，这也是为什么使用引用查询次数会更多的原因。试想如果对于「嵌套」方法中的样例，每次都进行自动解引用，那么在嵌套方法中可能进行的 1 次查询，在这里可能就需要 N+1 次了（N 为 <code>message</code> 中 <code>comments</code> 数组的长度）。</p>
<p>样例如下：</p>
<p>在 user.js 中定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userSchema = <span class="keyword">new</span> <span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">unique</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">password</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">email</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">intro</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 msgboard.js 中定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> messageSchema = <span class="keyword">new</span> <span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">user_id</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: mongoose.<span class="property">Schema</span>.<span class="property">ObjectId</span>,</span><br><span class="line">    <span class="attr">ref</span>: <span class="string">&#x27;User&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">content</span>: <span class="title class_">String</span>,</span><br><span class="line">  <span class="attr">time</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Date</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里，我们在 <code>messageSchema</code> 中定义了一个引用键 <code>user_id</code> 引用到 <code>userSchema</code> 中 <code>_id</code> 字段。<br>注意：MongoDB 会自动为文档创建唯一的 <code>_id</code> 字段！</p>
<p>如此，便在 Schema 层次上定义好了引用。具体在查询时，我们可以根据具体使用的包的特性来决定如何进行解引用的操作。</p>
<p>在 Mongoose 里，可以使用 <code>populate</code> 方法。详细的使用方法可以参考 Mongoose API 文档，这里仅给出一个样例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Message</span>.<span class="title function_">find</span>(query)</span><br><span class="line">  .<span class="title function_">populate</span>(<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">  .<span class="title function_">skip</span>((page - <span class="number">1</span>) * <span class="variable constant_">NUM_EACH_PAGE</span>)</span><br><span class="line">  .<span class="title function_">limit</span>(<span class="variable constant_">NUM_EACH_PAGE</span>)</span><br><span class="line">.<span class="title function_">sort</span>(&#123;<span class="attr">time</span>: -<span class="number">1</span>&#125;).<span class="title function_">exec</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">messages</span>) &#123;</span><br><span class="line">    <span class="comment">// do something with messages</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(messages);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里用 Promise（异步流程控制方式的一种） 链式操作的方进行对 <code>messages</code> 进行查询，同时 <code>skip</code> 和 <code>limit</code> 用于翻页。</p>
<p>重点可关注 <code>populate</code> 方法，我们在这里获取了引用到的 <code>user</code> 文档 <code>name</code> 字段的值。</p>
<p>对于自动引用方式而言，由于在同等数据量的情况下查询次数一般要多，所以适用于查询不大频繁、具有相对更弱逻辑性的数据关系之间（不是 A 出现 B 一定需要出现的关系），而且用它既定义了数据之间的关系，也方便对数据进行各种 CURD 操作（没有嵌套或少嵌套了）。</p>
<p>注：本文在 NoSQL 数据库中使用关系型数据库中的「字段」的概念，实际是表示 NoSQL 数据库文档中的属性。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 中的模块循环依赖及其解决</title>
    <url>/2016/08/17/cyclic-dependencies-in-node-and-its-solution/</url>
    <content><![CDATA[<p>Node.js 开发一般不容易遇到真正的模块循环依赖的情况，可是当你的项目开始达到一定的复杂度之后，你很有可能在你的 Node.js 编码生涯中遇到几次。而且如果你之前没有关于这方面的意识，Debug 可能会花费不少的时间。</p>
<p>我在最近的项目中就遇到了这种情况，而且不能轻易通过项目架构的重构来解决。具体来说，A 文件中需要用 B 文件中某些函数，B 文件又需要用到 A 文件中的某些函数。</p>
<span id="more"></span>

<h3 id="定义问题"><a href="#定义问题" class="headerlink" title="定义问题"></a>定义问题</h3><p>实际上，Node.js 官网上就有<a href="https://nodejs.org/api/modules.html#modules_cycles">关于模块循环 <code>require()</code> 的说明</a>。</p>
<p>在官网给出的例子中，有 3 个模块：<code>main.js</code>、<code>a.js</code>、<code>b.js</code>。其中 <code>main.js</code> 有对 <code>a.js</code> 和 <code>b.js</code> 的引用，而 <code>a.js</code> 和 <code>b.js</code> 又是相互引用的关系（详细情况请参阅上段末的超链接）。</p>
<p>官网上点出了这种模块循环的情况，并且解释清楚了原因（但并没有给出具体可行的解决方案）：</p>
<blockquote>
<p>When <code>main.js</code> loads <code>a.js</code>, then <code>a.js</code> in turn loads <code>b.js</code>. At that point, <code>b.js</code> tries to load <code>a.js</code>. In order to prevent an infinite loop, an <strong>unfinished copy</strong> of the <code>a.js</code> exports object is returned to the <code>b.js</code> module. <code>b.js</code> then finishes loading, and its exports object is provided to the <code>a.js</code> module.</p>
</blockquote>
<p>简单说就是，为了防止模块载入的死循环，Node.js 在模块第一次载入后会把它的结果进行缓存，下一次再对它进行载入的时候会直接从缓存中取出结果。所以在这种循环依赖情形下，不会有死循环，但是却会因为缓存造成模块没有按照我们预想的那样被导出（export，详细的案例分析见下文）。</p>
<p>官网给出了三个模块还不是循环依赖最简单的情形。实际上，两个模块就可以很清楚的表达出这种情况。根据递归的思想，解决了最简单的情形，这一类任意大小规模的问题也就解决了一半（另一半还需要探明随着问题规模增长，问题的解将会如何变化）。</p>
<p>下面是一个两个模块循环依赖的问题最简情形：</p>
<p><code>A.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./B&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A: before logging b&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A: after logging b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">A</span>: <span class="string">&#x27;this is a Object&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>B.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./A&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B: before logging a&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B: after logging a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">B</span>: <span class="string">&#x27;this is b Object&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行 <code>A.js</code>，将会看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B: before logging a</span><br><span class="line">&#123;&#125;</span><br><span class="line">B: after logging a</span><br><span class="line">A: before logging b</span><br><span class="line">&#123; B: &#x27;this is b Object&#x27; &#125;</span><br><span class="line">A: after logging b</span><br></pre></td></tr></table></figure>

<p>JavaScript 作为一门解释型的语言，上面的打印输出清晰的展示出了程序运行的轨迹。在这个例子中，<code>A.js</code> 首先 <code>require</code> 了 <code>B.js</code>, 程序进入 <code>B.js</code>，在 <code>B.js</code> 中第一行又 <code>require</code> 了 <code>A.js</code>。</p>
<p>如前文所述，为了避免无限循环的模块依赖，在 Node.js 运行 <code>A.js</code> 之后，它就被缓存了，但需要注意的是，此时缓存的仅仅是一个未完工的 <code>A.js</code>（an <strong>unfinished copy</strong> of the <code>a.js</code>）。所以在 <code>B.js</code> <code>require</code> <code>A.js</code> 时，得到的仅仅是缓存中一个未完工的 <code>A.js</code>，具体来说，它并没有明确被导出的具体内容（<code>A.js</code> 尾端）。所以 <code>B.js</code> 中输出的 <code>a</code> 是一个空对象。</p>
<p>之后，<code>B.js</code> 顺利执行完，回到 <code>A.js</code> 的 <code>require</code> 语句之后，继续执行完成。</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>想要解决这个问题有一个很简明的方法，那就是在循环依赖的每个模块中先导出自身，然后再导入其他模块（对于本文的举例来说，实际只需改动 <code>A.js</code> 就可以达到效果）。</p>
<p>话不多说，放码过来：</p>
<p><code>A.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">A</span>: <span class="string">&#x27;this is a Object&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./B&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A: before log b&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A: after log b&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>B.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">B</span>: <span class="string">&#x27;this is b Object&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./A&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B: before log a&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B: after log a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>此时，在 A 和 B 中，都在 <code>require</code> 之前就导出了自身需要导出的模块，此时输出则是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B: before log a</span><br><span class="line">&#123; A: &#x27;this is a Object&#x27; &#125;</span><br><span class="line">B: after log a</span><br><span class="line">A: before log b</span><br><span class="line">&#123; B: &#x27;this is b Object&#x27; &#125;</span><br><span class="line">A: after log b</span><br></pre></td></tr></table></figure>

<p>可以看到 B 中按我们的预期输出了 A 中导出的值。</p>
<p>这种解决办法可行的原因也很简单，还是因为 JavaScript 是一门解释型的语言，在 <code>require</code> 其他模块之前，已经把自身需要导出的部分都导出了，所以即便有模块载入缓存，也不影响最终结果按预期进行。</p>
<p>这种办法几乎没什么副作用，唯一稍令强迫症感到不快就是这种顺序与我们通常的书写顺序不符。一般我们都会先把 <code>require</code> 写在源文件开头，<code>exports</code> 放到后面的位置。唯一需要祈祷的是，之后接手项目的代码猴儿不会因为觉得这个顺序看着碍眼又把它改回去。鉴于此点，<u><strong>在导入导出语句上添加合理的解释性注释变得很重要</strong></u>。</p>
<h3 id="其他相关问题"><a href="#其他相关问题" class="headerlink" title="其他相关问题"></a>其他相关问题</h3><p>实际上，我还自己实验并查阅了一些资料来探索是否有其他的解决办法，但那些办法要么是适用于特定的情形和设计模式之下，要么就没有上述方法简洁，本文就不赘述了。如果有兴趣，可以参看本文末尾的 References 链接。如果你发现有更好的解决办法，欢迎在评论区留言。</p>
<p>要想彻底弄明白 Node.js 模块加载的相关问题，一定得去读读 Node.js 相关部分的源码。其次，推荐阅读<a href="https://book.douban.com/subject/25768396/">《深入浅出 Node.js》</a>第二章与<a href="http://www.ruanyifeng.com/blog/2015/05/require.html">阮一峰的这篇日志</a>。</p>
<p>有趣的是，ES6 特性中已经有了更优秀的 <code>import/export</code> 模块加载机制，就不会存在这样的问题（原因参考 References 第5条），然而 Node.js 还并不支持。Github 上有人提出过这个问题，Node.js 基金会成员 <a href="https://github.com/bnoordhuis">@bnoordhuis</a> 对此的回复是：</p>
<blockquote>
<p>In a nutshell, <code>require()</code> is not going anywhere - removing it would break too much for too little gain - but we’ll almost certainly end up supporting ES6 import&#x2F;export somehow, details TBD.</p>
<p>Support for ES6 modules first needs to land in V8.</p>
</blockquote>
<p>详细的讨论可以到<a href="https://github.com/nodejs/help/issues/53">这里</a>查看。</p>
<p>虽然因为 V8 的原因 Node.js 官方还不能支持 <code>import/export</code>，不过我们依然可以借助 Babel 来提前在 Node.js 使用这个特性，感兴趣的同学可以参考<a href="http://taobaofed.org/blog/2016/01/07/find-back-the-lost-es6-features-in-nodejs/">这里</a>。 </p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol>
<li><a href="https://nodejs.org/api/modules.html#modules_cycles">Modules | Node.js Documentation</a></li>
<li><a href="https://coderwall.com/p/myzvmg/circular-dependencies-in-node-js">Circular dependencies in node.js</a></li>
<li><a href="https://cnodejs.org/topic/4f16442ccae1f4aa27001045">node.js的循环依赖 - cnode</a></li>
<li><a href="https://segmentfault.com/a/1190000004151411">Node.js 中的循环依赖 - sf</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html">JavaScript 模块的循环加载 - 阮一峰</a></li>
<li><a href="https://github.com/Gaubee/blog/issues/65">nodejs中模块循环依赖的解决方案 #65</a></li>
</ol>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>循环依赖</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>用 ES6 特性实现一个标准的轻量级 Promise</title>
    <url>/2016/08/29/implement-a-clean-promise-with-es6-features/</url>
    <content><![CDATA[<p>Promise 应该是目前 JavaScript 中最流行的异步流程控制解决方案，本文将介绍如何使用 JavaScript ES6 的语言特性，实现一个轻量级的通过了所有<a href="https://github.com/promises-aplus/promises-tests">官方测例</a>标准的 Promise 库。了解其原理，深入其实现。实际上，Promise 也早已被写入 JavaScript ES6 的标准，作为官方支持的标准异步流程控制解决方案之一。用 ES6 语法实现一个 ES6 中的 Promise，虽然看似没有必要，不过对于深入理解 Promise 以便更好的使用大有裨益。</p>
<p>为了您的最佳阅读体验，在阅读本文之前，建议您已经做到如下事情：</p>
<ul>
<li>可以熟练使用至少任意一个 Promise 库，如 bluebird、Q 等；</li>
<li>了解 Promise 标准，可以<a href="https://promisesaplus.com/">看这里</a>；</li>
<li>熟悉主要的 JavaScript ES6 特性；</li>
</ul>
<span id="more"></span>
<h3 id="构造函数之前的准备"><a href="#构造函数之前的准备" class="headerlink" title="构造函数之前的准备"></a>构造函数之前的准备</h3><p>我们都知道，Promise 总共有三种状态：pending、fullfilled（resolved）和 rejected。所以我们对于每一个 Promise 实例都需要一个变量记录其现有的状态。</p>
<p>然后还需要一个变量记录其 settled 之后的结果。另外，Promise 作为一个异步流程控制库，在上游的 Promise 还处于 pending 状态时下游 Promise 是不能执行的，所以我们至少需要一个数组来记录当前 Promise 还未 settled 时它后续的一些操作（你可以用两个数组分别记录 resolved 和 rejected 之后不同的操作；也可以用一个数组，然后每个元素都是包含两个属性的对象，分别记录 resolved 和 rejected 之后不同的操作）。</p>
<p>另外，借用面向对象的说法，这些变量对 Promise 而言应该是私有的，即不应该对外界暴露（这也是符合标准的）。所以待会儿构造函数之中应该定义一些私有变量，而 ES6 的 Symbol 类型则可以完美实现我们所需的私有变量。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 Promise 状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">STATUS</span> = &#123;</span><br><span class="line">    <span class="attr">PENDING</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">RESOLVED</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">REJECTED</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _status = <span class="title class_">Symbol</span>(<span class="string">&#x27;status&#x27;</span>); <span class="comment">// 用于 status 私有变量的 Symbol</span></span><br><span class="line"><span class="keyword">const</span> _result = <span class="title class_">Symbol</span>(<span class="string">&#x27;result&#x27;</span>); <span class="comment">// 用于 result 私有变量的 Symbol</span></span><br><span class="line"><span class="keyword">const</span> _callbacks = <span class="title class_">Symbol</span>(<span class="string">&#x27;callbacks&#x27;</span>); <span class="comment">// 用于 callbacks 私有变量的 Symbol</span></span><br></pre></td></tr></table></figure>

<p>这里我们将 Promise 状态定义到一个对象之中，并且用属性名语义化状态，值其实没什么意义，但是这样写符合「让错误更早的暴露出来」的编程原则，让编译器（或解释器）去帮我们提前检测错误，总比写在字符串在运行时才把定位还不一定准确的错误暴露出来要好。</p>
<p>其次，还定义了几个用于定义私有变量的 Symbol。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数无非是给变量做一些初始化的工作，然后执行用户传入的函数。关键在于我们需要定义好传入的函数的参数，即<code>resolve</code>和<code>reject</code>函数。</p>
<p>先看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">exec</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(<span class="title function_">typeof</span> (exec) === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Promise constructor argument exec must be a function.&#x27;</span>) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self[_status] = <span class="variable constant_">STATUS</span>.<span class="property">PENDING</span>; </span><br><span class="line">    self[_result] = <span class="literal">undefined</span>;</span><br><span class="line">    self[_callbacks] = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (self[_status] === <span class="variable constant_">STATUS</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">                self[_status] = <span class="variable constant_">STATUS</span>.<span class="property">RESOLVED</span>;</span><br><span class="line">                self[_result] = value;</span><br><span class="line">                self[_callbacks].<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> cb.<span class="title function_">onResolved</span>(self[_result]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">        <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (self[_status] === <span class="variable constant_">STATUS</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">                self[_status] = <span class="variable constant_">STATUS</span>.<span class="property">REJECTED</span>;</span><br><span class="line">                self[_result] = reason;</span><br><span class="line">                self[_callbacks].<span class="title function_">map</span>(<span class="function"><span class="params">cb</span> =&gt;</span> cb.<span class="title function_">onRejected</span>(self[_result]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">exec</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造函数里，首先限制了用户传入的参数必须为函数，然后将状态置为<code>pending</code>，并初始化<code>result</code>和<code>callbacks</code>。</p>
<p>之后，尝试运行用户传入的函数，并提供我们自己定义的<code>resolve</code>和<code>reject</code>函数作为参数。因为运行函数可能会抛出难以预期的错误，所以外面用<code>try...catch</code>包裹一层，并把错误用<code>reject</code>处理，表示当前 Promise 被 reject。</p>
<p>这里的关键在于我们自己定义的<code>resolve</code>和<code>reject</code>函数。</p>
<p>其实<code>resolve</code>和<code>reject</code>的逻辑也很简单，首先因为标准里规定对于<code>resolve</code>和<code>reject</code>的调用必须是异步的，来避免阻塞（<code>.then</code>方法的两个参数同理），所以外面套了一层<code>nextTick</code>（这里对前后端做了兼容，前端指向<code>setTimeout</code>，后端指向<code>process.nextTick</code>）。内层首先保证当前 Promise 还处于<code>pending</code>状态（标准规定状态只能由<code>pending</code>转向其他两个，并且一经转变不能更改），然后分别将状态置为<code>resolved</code>或<code>rejected</code>，最后顺次执行之前由于还未 settled 时存储在<code>callbacks</code>里面的后续回调函数集。</p>
<h3 id="then"><a href="#then" class="headerlink" title=".then"></a>.then</h3><p><code>.then</code>函数接受两个函数作为参数，分别对应前一个 Promise 被 resolve 或 reject 之后的回调。</p>
<p>首先来看一下函数的主逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (self[_status]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable constant_">STATUS</span>.<span class="property">RESOLVED</span>:</span><br><span class="line">        childPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="title function_">childExec</span>(self[_result], onResolved, resolve, reject, childPromise));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable constant_">STATUS</span>.<span class="property">REJECTED</span>:</span><br><span class="line">        childPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="title function_">childExec</span>(self[_result], onRejected, resolve, reject, childPromise));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable constant_">STATUS</span>.<span class="property">PENDING</span>:</span><br><span class="line">        childPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            self[_callbacks].<span class="title function_">push</span>(&#123;</span><br><span class="line">                <span class="attr">onResolved</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="title function_">childExec</span>(value, onResolved, resolve, reject, childPromise),</span><br><span class="line">                <span class="attr">onRejected</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="title function_">childExec</span>(value, onRejected, resolve, reject, childPromise)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>: </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Invalid status value&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前一个 Promise 的状态，分三种情况，其中<code>resolved</code>和<code>rejected</code>时是类似的：<code>new</code>一个新的 Promise 实例作为当前的 Promise，同理异步执行传入的函数（细节见下文<code>childExec</code>函数）。而当状态是<code>pending</code>时，我们只能先把回调函数先压入前一个 Promise 的回调函数队列，等<code>settled</code>后再执行。</p>
<h4 id="childExec"><a href="#childExec" class="headerlink" title="childExec"></a>childExec</h4><p><code>childExec</code>本身是为了最大化复用代码而重构独立出来的一个函数，代码很简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">childExec</span>(<span class="params">value, onDone, resolve, reject, childPromise</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        value = <span class="title function_">onDone</span>(value);</span><br><span class="line">        <span class="title function_">solver</span>(childPromise, value, resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下：不管是前一个 Promise 是<code>rejected</code>还是<code>resolved</code>，用传入<code>.then</code>的对应的回调函数执行前一个 Promise settled 之后的结果<code>result</code>，然后执行<code>solver</code>（见下文对<code>solver</code>的分析）。同样的，外面需要包裹一层<code>try...catch</code>。</p>
<h4 id="solver"><a href="#solver" class="headerlink" title="solver"></a>solver</h4><p><code>solver</code>函数是不同的 Promise 实现之间（比如 bluebird 对 Promise 的实现与 ES6 原生对 Promise 的实现）能够无缝调用的关键。对此，<a href="https://promisesaplus.com/#point-45">Promise 标准中也有详述，甚至已经把这个函数的逻辑和流转都已经完完本本的列出来了，任何 Promise 实现只要遵循这个标准，就可以实现不同 Promise 实现之间的交叉调用</a>。</p>
<p>看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">solver</span>(<span class="params">promise, result, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> then, settled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (promise === result) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cycle Promises&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result[_status] === <span class="variable constant_">STATUS</span>.<span class="property">PENDING</span>) &#123;</span><br><span class="line">            result.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="title function_">solver</span>(promise, v, resolve, reject), reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((result !== <span class="literal">null</span>) &amp;&amp; (<span class="title function_">typeof</span> (result) === <span class="string">&#x27;object&#x27;</span> || <span class="title function_">typeof</span> (result) === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            then = result.<span class="property">then</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">typeof</span> (then) === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                then.<span class="title function_">call</span>(result, <span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (settled) <span class="keyword">return</span>;</span><br><span class="line">                    settled = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_">solver</span>(promise, s, resolve, reject);</span><br><span class="line">                &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (settled) <span class="keyword">return</span>;</span><br><span class="line">                    settled = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_">reject</span>(r);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">resolve</span>(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (settled) <span class="keyword">return</span>;</span><br><span class="line">            settled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>如果上一个 Promise 的<code>result</code>跟子 Promise 还是同一个对象，显然是循环调用了，按标准规定抛出<code>TypeError</code>；</li>
<li>如果上一个 Promise 的<code>result</code>还是本 Promise 实现的实例，那挺好，直接调用它的<code>then</code>就好。不过，上一个 Promise 返回的新 Promise 可能还没有 settled，所以如果没有 settled，我们在它的<code>onResolved</code>函数中直接继续执行<code>solver</code>直到它被 settled（看起来像用递归的形式表现循环迭代）；</li>
<li>如果返回的不是当前 Promise 实现的实例，但是它是一个有<code>.then</code>方法的对象或者函数，那我们直接用它的<code>then</code>方法<code>call</code>在<code>result</code>上，并且在它的回调函数<code>onResolved</code>中用<code>.then</code>传递的<code>s</code>继续调用<code>solver</code>或者在<code>onRejected</code>函数中<code>reject</code>掉这个 Promise。值得注意的是，由于一个 Promise 只能被 settled 一次，而第三方的<code>.then</code>方法我们不知道里面具体是什么内容，所以用一个<code>Boolean</code>量<code>settled</code>来标记，保证它只被 settled 一次，之后的调用都直接被忽略（标准也是这样规定的）；</li>
<li>如果只是一个简单值，直接<code>resolve</code>。</li>
</ul>
<p>另外，尽管在<code>childExec</code>中我们已经用<code>try...catch</code>包裹了一层，但是异步调用的错误依然可能不会被捕获，所以这里依然需要<code>try...catch</code>。</p>
<p>至此，一个符合标准的 Promise 最小化实现就已经完成了。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在你的 Promise 写好后，需要进行测试，至少需要通过的官方测例在这里：<a href="https://github.com/promises-aplus/promises-tests">Promises&#x2F;A+ Compliance Test Suite</a>。通过所有测例之后表明你的 Promise 实现是基本符合标准的。</p>
<p>按其说明，你需要提供一个这样的类静态函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">deferred</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dfd = &#123;&#125;;</span><br><span class="line">    dfd.<span class="property">promise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        dfd.<span class="property">resolve</span> = resolve;</span><br><span class="line">        dfd.<span class="property">reject</span> = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数返回一个对象，并用<code>resolve</code>和<code>reject</code>属性引用构造函数中自定义的<code>resolve</code>和<code>reject</code>函数，用<code>promise</code>属性引用一个 Promise 实例。</p>
<p>之后用<code>promises-aplus-tests</code>命令运行测试（需要提前安装<code>promises-aplus-tests</code>包）。</p>
<h3 id="常用的其他辅助接口"><a href="#常用的其他辅助接口" class="headerlink" title="常用的其他辅助接口"></a>常用的其他辅助接口</h3><p>一个成熟的 Promise 包肯定不会只有一个简单的<code>.then</code>方法，不过其他的的辅助接口都是在此最简基础上慢慢迭代出来的，相当于是一些方便用户使用的语法糖。</p>
<p>你可以在下文给出的 GitHub 源码链接中查看我的其他辅助方法的实现，逻辑基本都很清晰，本文不赘述了。</p>
<h3 id="Join-Me"><a href="#Join-Me" class="headerlink" title="Join Me"></a>Join Me</h3><p>目前，我的这个 Promise 实现已经放在了 npm 和 GitHub 上：</p>
<ul>
<li>npm：<a href="https://www.npmjs.com/package/clean-promise">clean-promise</a></li>
<li>GitHub: <a href="https://github.com/Maples7/clean-promise">Maples7&#x2F;clean-promise: a minimal implement of Promise</a></li>
</ul>
<p>Any issues and PRs are welcomed! :D</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果要细致的讲解每一个细节，恐怕 5 篇这样长度的文章还显不够，本文也只是将实现的骨架勾勒了出来。不过，源码是一个软件产品最好的背书，我就不啰嗦了。</p>
<p>个人觉得实现 Promise 的难度在于它本身的逻辑比较绕，因为标准设计得就比较精巧，每一个地方的衔接都经过深思熟虑，往往一个方法就会产生一个新的 Promise，有一种层层迭代的感觉，类似于「蚕」的结构，所以把层次厘清确实需要花一番功夫，要有耐心。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol>
<li><a href="https://github.com/xieranmaya/blog/issues/3">剖析 Promise 内部结构，一步一步实现一个完整的、能通过所有 Test case 的 Promise 类 #3 </a>；</li>
<li><a href="https://promisesaplus.com/">Promises&#x2F;A+</a>；</li>
</ol>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>构建合格的 RESTful API Server</title>
    <url>/2016/09/05/build-qualified-restful-api-server/</url>
    <content><![CDATA[<p>这一篇我要把 References 写在前面：</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=401902529&idx=1&sn=575ae8fdf163afa30604d712a73079fd&scene=21#wechat_redirect">再谈 API 的撰写 - 总览</a>；</li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=401924543&idx=1&sn=97de2e09c9fddfd905992c19aedb6182&scene=1&srcid=0427sAmgXKhksqURPXRj2cxv#wechat_redirect">再谈 API 的撰写 - 架构</a>；</li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=402076898&idx=1&sn=32b7591a6385ab695d5070061bf18a0a&scene=1&srcid=04276Jyhm6g4QMOyPgfm8jxj#wechat_redirect">再谈 API 的撰写 - 子系统</a>；</li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=402114651&idx=1&sn=a7b891f532e29b73afd83f17ae071023&scene=1&srcid=0427CHvTKeMIQsr5uT3x9nIN#wechat_redirect">再谈 API 的撰写 - 契约</a>；</li>
</ul>
<p>通过这一系列文章，大神已经自顶向下的把构建一个合格的 RESTful API Server 的要点都涉及到了，并且基本都是最佳实践，值得反复咀嚼。这一篇我结合自己的实践做一些 localization 的总结和实践归纳。文中都以 Node.js 的 Express 框架来举例。</p>
<span id="more"></span>

<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><blockquote>
<p>All problems in computer science can be solved by another level of indirection.<br>—— David Wheeler</p>
</blockquote>
<p>分层架构是最常见的软件架构，作为 API Server，一般我们也采用这样的架构，而在 Web 后端架构中最流行的当然是 MVC 的架构模式。不过，View 层对于 API server 是没有的。</p>
<p>先梳理一下操作流程，前端请求 URL 经过 Router 匹配，之后 Controller 层进行数据处理，不过数据处理一般是繁杂的，这里可以再分一层叫 Service 层，处理所有与数据库直接交互的部分，也便于 Controller 层对于相同功能进行再拆分和复用，最后返回。这样的分层模型我们不如叫 MRCS 比较精确。</p>
<p>具体来说：</p>
<ul>
<li>Model：与数据库的数据模型一一对应，定义了整个项目的所有数据操作的模型基础；</li>
<li>Router：API Server 所有定义的路由；</li>
<li>Controller：因为已经有 Service 层，所有这里仅进行一些输入参数的验证和解析以及结果数据的重新组织和返回，更底层的数据库交互交给 Service 层；</li>
<li>Service：所有与数据库和缓存的数据交互都在这里，这里的函数不是与 Controller 层的函数一一对应的，而应该是更细小颗粒功能的划分，让 Controller 层来进行组织，从而实现对底层功能的充分复用。</li>
</ul>
<h2 id="文档与接口参数验证"><a href="#文档与接口参数验证" class="headerlink" title="文档与接口参数验证"></a>文档与接口参数验证</h2><p>一个普通的网站可以没有对外的文档，可是一个 API Server 却一定得有文档，没有文档的 API Server 毫无意义。</p>
<p>而且，文档和接口参数验证是紧密相关的，如果你把这两部分分开了，那说明你一定是在某处重复定义了接口的参数模型。所以这两部分放在一起来讲。这也就是说，不管具体是写在哪，接口参数模型只手写定义一次，文档生成和参数验证都以这同一个定义为依据来进行（这样也极大的增强了文档与代码一致性的可能）。接口参数验证的同时也可以进行部分参数解析的工作，比如还原参数的类型（前端传递过来的都是 String），甚至还可以顺手把数据组织成 Controller 层需要的格式。</p>
<p>程序员一般而言都是不喜欢写文档的，团队也通常没有更多的资源让专人来维护文档，所以如何花费最小的代价完成与代码一致的高质量的文档是一个很重要的课题。</p>
<p>一个好的文档系统应该具备的特性：</p>
<ul>
<li>具有良好的机制尽可能保证代码和文档的一致性；</li>
<li>不同版本之间<code>diff</code>的功能；</li>
<li>每一个定义的接口下面可以直接在线进行类似于 Postman 的接口可用性测试；</li>
<li>需要重复定义的部分可以抽象出来，定义一次，多处复用；</li>
</ul>
<p>如果你时间充裕，并且想做边际效应高的事情，那么你可以考虑使用 Swagger。这是一个庞大的文档框架体系，工具全面且强大，但有些门槛，需要学习一段时间（使用可以参看我的下一篇博文：<a href="http://maples7.com/2016/09/06/build-doc-system-of-express-api-server-with-swagger/">使用Swagger构建Express API Server的文档系统</a>）。类似的还有RAML，这是一门基于 YAML 的文档建模语言，用法灵活，功能强大，但是目前工具还不是很靠谱，或许因为用的人也不是很多，项目显得有些缺乏维护，不过我觉得它对于构建文档系统的指导思想是很先进的。</p>
<p>如果是为了花费最小的成本，可以使用 apidoc，这就是一个普通的 npm 包，你可以直接使用它从函数注释生成 HTML 文档，支持版本对比，支持继承复用，支持接口在线可用性测试。另外，使用这个包的插件可以直接从 json-schema 中导入对参数模型的定义，这样只需要定义一次，就可以同时用 json-shcema 进行接口参数验证和生成文档。<del>目前我一般选择这种方案。</del>不过你也可以反过来，先在注释上定义所有的文档参数模型，然后用一个 Parser 解析从而验证参数（我相信 apidoc 中是有一个这样的 Parser 的，不过对外没有提供参数验证的功能，我也没有找到第三方的插件可以实现，或许有时间可以自己去写一个插件或者直接在 apidoc 上实现）。如果你采用后一种方案，那么分清程序的<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=402003317&idx=1&sn=68dabd5cbf565ab3fd99f90641a01a9f&scene=21#wechat_redirect">「编译时」和「运行时」</a>很重要，因为如果你要从注释解析后验证参数，那么你必须在「编译时」就已经从注释获得了所有的接口参数的定义模型，只有这样在「运行时」才能快速进行接口参数模型的匹配与验证。</p>
<p>文档最后需要部署到一个外部可以查看到的地方供使用者查阅和测试，这时可以借助 gulp 等类似工具来尽可能自动化的实现。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>一般的软件可能需要开发书写单元测试，可是个人觉得 API Server 的单元测试和接口测试实际上做的是很多重复的工作。所以我觉得 API Server 直接对接口进行功能性测试就好。</p>
<p>不过接口测试是非常难写的，一个接口需要完整测试的 test cases 可能高达十几个甚至几十个。除了更好的对接口进行划分外，目前我还没想好如何缓解这个问题。</p>
<p>不管怎么说，需要持续维护的项目都应该写测试，API Server 依然可以用<code>Mocha/should/supertest/istanbul/gulp</code>这套技术栈来书写自动化的接口测试。</p>
<h2 id="统一数据返回"><a href="#统一数据返回" class="headerlink" title="统一数据返回"></a>统一数据返回</h2><p>好的 API Server 应该定义统一的数据返回格式，这应该成为与前端的固定约定，这样前端才能方便的对返回数据进行验证和进一步操作。这就好比浏览器通过 Status Code 来进行对应的后续操作一样。</p>
<p>为了实现这一点，所有的接口调用在返回给前端之前都应该经过至少同一个中间件进行数组格式的重新组织，并且匹配到合适的 HTTP Status Code 以及自定义的返回码（非正常的数据返回时自定义的返回码，这个也是与前端的约定之一）和明确的返回信息，JSON 化之后返回。</p>
<h2 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h2><p>数据序列化分为输入数据的序列化和输出数据的序列化。</p>
<p>输入数据的序列化可以在前文所述的接口参数验证时完成（不复杂的情况下），也可以单独在一个中间件中完成。其实这一步不是必要的，因为通常各个接口的 Controller 需求是各不一样的，这里只能进行一些通用化的序列化操作。</p>
<p>相比于输入数据的序列化，输出数据的序列化要重要得多，而且一般通用性更强。举例来说，你有很多个接口都需要返回数据库中的同一个数据实例，但是不同接口需要返回给前端的字段和内容可能是各不一样的，此时就可以在这一步把输出数据序列化成前端的要求。最后的返回数据都是最精简且语义化良好的。这一步的操作可以有效节省网络流量，对移动端和处女座程序员都很有意义。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存不是必需的，但却是对高性能服务的基本要求。一个好的缓存设计不仅对性能有影响，而且对后期的开发调试也有很大影响。毕竟，解决了缓存，你就已经解决的计算机科学中一半的难题（:D）：</p>
<blockquote>
<p>There are only two hard things in Computer Science: cache invalidation and naming things.<br>—— Phil Karlton</p>
</blockquote>
<p>你可以进行路由层级的缓存设计，也可以进行数据库操作层级的缓存设计。但不管缓存怎样设计，除去基本的可用性和鲁棒性之外，最大的目标应该是对使用者尽可能友好：</p>
<blockquote>
<p>Simplicity is the ultimate sophistication.   - Leonardo Da Vinci</p>
</blockquote>
<p>「对使用者尽可能友好」指的是：</p>
<ol>
<li>接口调用简单，甚至不需要手动调用；</li>
<li>缓存可以自动过期；</li>
<li>尽可能保证已经无效的缓存（缓存数据已经与真实数据不一致，也可以称为旧的缓存）可以无遗漏的尽快被删除；</li>
</ol>
<p>第3点尤其重要，因为如果程序员手动控制缓存删除，那么对同一个数据块缓存的操作代码可能分散在项目各处，很难保证及时和没有遗漏。不过目前我也没有找到比较好的实现方案，初步的想法是如果能实现有一个 watcher 可以监听某一个数据块是否即将被改动（或者是否刚刚已经被改动）就好了。如果即将被更改，那在更改后立刻自动删除旧缓存。其实我觉得这个方案可以在 ORM 中实现，但目前没有发现有 ORM 支持这一点。</p>
<p>与「设计」一样，缓存系统的终极目标应该是使上层使用者根本感觉不到它的存在。这是指，当你调用获取数据的底层接口时，你无需知道数据是来源于真实数据库还是缓存。做到这一点无疑很难，不过你至少可以做到把对上层系统的影响降到最低，也就是说，使用缓存和不使用缓存只需要更改尽可能少的代码即可以轻易实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文没有提到标题中 RESTful 相关的东西，主要是路由设计的时候遵循 RESTful 的原则就可以了，无需多讲。</p>
<p>另外，很多东西还只是提供了一个基本的方向和原则，还有待更多的实践来验证和改进。</p>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><ol>
<li><p>Facebook 提出了一种新的不同于 REST 的 API 数据查询标准——<a href="http://graphql.org/">GraphQL</a>，这套标准可以让前端（广义的，包含移动端）来定义需要获取的数据模型，这样做可以极大的减轻后端对于前文所述的文档、接口参数验证、统一数据返回、数据序列化的工作，看起来很有意思。更多了解除了<a href="http://graphql.org/">官网</a>之外，还可以参考这篇文章：<a href="http://imweb.io/topic/58499c299be501ba17b10a9e">《新一代数据查询语言 GraphQL 来啦！》</a>。</p>
</li>
<li><p>Google 在这方面当然也毫不示弱，它家的 Google+ API 中也有类似的思想：<a href="https://developers.google.com/+/web/api/rest/#partial-response">Partial Responses</a>。具体说，利用请求的参数<code>fields</code>来由客户端决定哪些返回参数是我这次请求所需要的。当然，这没有 Facebook 的 GraphQL 功能系统和强大，只能返回一个API全集数据的一个子集，不过它是完全基于REST的，这意味着你可能只需对你现有的系统做最小的改动即可实现类似的功能，减轻后端对于输出数据序列化的负担。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>RESTful</tag>
        <tag>API</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Swagger 构建 Express API Server 的文档系统</title>
    <url>/2016/09/06/build-doc-system-of-express-api-server-with-swagger/</url>
    <content><![CDATA[<p>如<a href="http://maples7.com/2016/09/05/build-qualified-restful-api-server/">上一篇博客</a>所说，好的文档系统对 API Server 至关重要，本文介绍在 Express 框架中使用 Swagger 构建一个良好的项目文档系统的基本流程，同时明确一些实践过程中肯定会遇到的问题的解决方案。本文遵循<code>Swagger 2.0</code>使用规范。</p>
<img data-src="https://i.loli.net/2018/08/06/5b672f1a563d0.png" class="" title="Swagger——The Most Popular Framework for APIs of The World" alt="图片显示错误">

<span id="more"></span>

<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>文档生成的「源」（或者说「依据」）与代码不分离，即直接用<code>jsdoc</code>注释生成文档；</li>
<li>可以用同样的「源」同时实现对接口输入输出参数的验证，最大化保证文档与后端具体实现之间的一致性；</li>
<li>文档在线可用性测试，并且可以完美解决跨域请求的问题；</li>
<li>在后端接口还未完成时，可以 Mock 返回数据；</li>
<li>最好能自动生成一些测试数据甚至自动进行测试；</li>
</ul>
<h2 id="从-JSDoc-到可视化文档"><a href="#从-JSDoc-到可视化文档" class="headerlink" title="从 JSDoc 到可视化文档"></a>从 JSDoc 到可视化文档</h2><h3 id="Step-1：定义接口模型"><a href="#Step-1：定义接口模型" class="headerlink" title="Step 1：定义接口模型"></a>Step 1：定义接口模型</h3><p>在 Controller 层每一条路由的函数注释上（具体来说，Routes 目录下或 Controller 目录下均可，只要配置好<code>Step 2</code>中的<code>swagger-jsdoc</code>，明确「源」所在的目录即可）按<code>Swagger YAML</code>语法定义接口模型，示例如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@swagger</span></span></span><br><span class="line"><span class="comment"> * definition:</span></span><br><span class="line"><span class="comment"> *   Puppy:</span></span><br><span class="line"><span class="comment"> *     properties:</span></span><br><span class="line"><span class="comment"> *       name:</span></span><br><span class="line"><span class="comment"> *         type: string</span></span><br><span class="line"><span class="comment"> *       breed:</span></span><br><span class="line"><span class="comment"> *         type: string</span></span><br><span class="line"><span class="comment"> *       age:</span></span><br><span class="line"><span class="comment"> *         type: integer</span></span><br><span class="line"><span class="comment"> *       sex:</span></span><br><span class="line"><span class="comment"> *         type: string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@swagger</span></span></span><br><span class="line"><span class="comment"> * /api/puppies:</span></span><br><span class="line"><span class="comment"> *   get:</span></span><br><span class="line"><span class="comment"> *     tags:</span></span><br><span class="line"><span class="comment"> *       - Puppies</span></span><br><span class="line"><span class="comment"> *     description: Returns all puppies</span></span><br><span class="line"><span class="comment"> *     produces:</span></span><br><span class="line"><span class="comment"> *       - application/json</span></span><br><span class="line"><span class="comment"> *     responses:</span></span><br><span class="line"><span class="comment"> *       200:</span></span><br><span class="line"><span class="comment"> *         description: An array of puppies</span></span><br><span class="line"><span class="comment"> *         schema:</span></span><br><span class="line"><span class="comment"> *           $ref: &#x27;#/definitions/Puppy&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/api/puppies&#x27;</span>, db.<span class="property">getAllPuppies</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@swagger</span></span></span><br><span class="line"><span class="comment"> * /api/puppies:</span></span><br><span class="line"><span class="comment"> *   post:</span></span><br><span class="line"><span class="comment"> *     tags:</span></span><br><span class="line"><span class="comment"> *       - Puppies</span></span><br><span class="line"><span class="comment"> *     description: Creates a new puppy</span></span><br><span class="line"><span class="comment"> *     produces:</span></span><br><span class="line"><span class="comment"> *       - application/json</span></span><br><span class="line"><span class="comment"> *     parameters:</span></span><br><span class="line"><span class="comment"> *       - name: puppy</span></span><br><span class="line"><span class="comment"> *         description: Puppy object</span></span><br><span class="line"><span class="comment"> *         in: body</span></span><br><span class="line"><span class="comment"> *         required: true</span></span><br><span class="line"><span class="comment"> *         schema:</span></span><br><span class="line"><span class="comment"> *           $ref: &#x27;#/definitions/Puppy&#x27;</span></span><br><span class="line"><span class="comment"> *     responses:</span></span><br><span class="line"><span class="comment"> *       200:</span></span><br><span class="line"><span class="comment"> *         description: Successfully created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/api/puppies&#x27;</span>, db.<span class="property">createPuppy</span>);</span><br></pre></td></tr></table></figure>

<p>一些抽象出来的<code>definition</code>直接在前面的<code>/** */</code>注释中定义即可。</p>
<p>在生成的完整配置中，同一个路径下的配置（比如上述示例中<code>/api/puppies</code>下的<code>get</code>与<code>post</code>）会合并在这同一个路径之下，所以同一个路径下的全局配置只用写一遍就行了（比如下文<code>Mock返回数据</code>小节中使用<code>Swagger Router</code>中间件需要的<code>x-swagger-router-controller</code>配置）。</p>
<h3 id="Step-2：生成-Swagger-接口定义"><a href="#Step-2：生成-Swagger-接口定义" class="headerlink" title="Step 2：生成 Swagger 接口定义"></a>Step 2：生成 Swagger 接口定义</h3><p>用 <a href="https://github.com/Surnet/swagger-jsdoc">swagger-jsdoc</a> 生成 JSON 格式的 Swagger 接口定义。<br>Demo：<a href="https://github.com/mjhea0/node-swagger-api">mjhea0&#x2F;node-swagger-api</a>。</p>
<p>这里不用把生成的 JSON 保存在本地磁盘上，直接用一个变量引用即可。</p>
<h3 id="Step-3：用-Swagger-UI-生成可视化文档"><a href="#Step-3：用-Swagger-UI-生成可视化文档" class="headerlink" title="Step 3：用 Swagger UI 生成可视化文档"></a>Step 3：用 Swagger UI 生成可视化文档</h3><p>在线查看：打开<a href="http://petstore.swagger.io/">http://petstore.swagger.io/</a>，在顶部的 URL 栏输入可以获取<code>Step 2</code>中生成的 JSON 格式的 Swagger 文档定义的 URL，<del>一般来说可以是<a href="http://localhost:3000/swagger.json">http://localhost:3000/swagger.json</a> （需要自己手动在代码中书写路由和请求的返回）</del> 在使用了后文要说明的<a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md#swagger-ui">Swagger UI 中间件</a>之后按照默认配置是 <a href="http://localhost:3000/api-docs">http://localhost:3000/api-docs</a> （注意最后没有<code>/</code>）。这种方式需要解决跨域请求的问题，详见后文。</p>
<p>本地离线查看：<del>直接在本项目 public（静态文件目录）下放置离线版<code>Swagger UI</code>，直接打开即可查看。详见<code>Step 2</code>中的 Demo 及作者的博文说明。</del>使用<code>swagger-tools</code>中的<a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md#swagger-ui">Swagger UI 中间件</a>，如果你直接使用默认配置：</p>
<ul>
<li><a href="http://localhost:3000/docs/">http://localhost:3000/docs/</a> 可以看到完整的可视化文档；</li>
<li><a href="http://localhost:3000/api-docs">http://localhost:3000/api-docs</a> （注意最后没有<code>/</code>）可以看到自己在<code>Step 2</code>中自动生成的 Swagger 接口定义。</li>
</ul>
<p>这个中间件可以让你在开发时再也无需操心可视化文档的前端实现和如何查看自动生成 Swagger 接口定义（以便确定是否符合规范和自己的需求）的问题。</p>
<h2 id="一些常见问题"><a href="#一些常见问题" class="headerlink" title="一些常见问题"></a>一些常见问题</h2><h3 id="解决跨域请求的问题"><a href="#解决跨域请求的问题" class="headerlink" title="解决跨域请求的问题"></a>解决跨域请求的问题</h3><p>官方说明见：<a href="https://github.com/swagger-api/swagger-ui#cors-support">https://github.com/swagger-api/swagger-ui#cors-support</a>。<br>在<code>app.use(&#39;/&#39;, routes);</code>之前加一个如下的中间件设置一些 cors 相关的头可以解决问题:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://petstore.swagger.io&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">setHeader</span>(</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;GET, POST, DELETE, PUT, PATCH, OPTIONS&#x27;</span></span><br><span class="line">  );</span><br><span class="line">  res.<span class="title function_">setHeader</span>(</span><br><span class="line">    <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type, api_key, Authorization&#x27;</span></span><br><span class="line">  );</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="接口参数验证"><a href="#接口参数验证" class="headerlink" title="接口参数验证"></a>接口参数验证</h3><p>使用<code>swagger-tools</code>中的<a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md#swagger-metadata">Swagger Metadata</a>和<a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md#swagger-validator">Swagger Validator</a>中间件：</p>
<ul>
<li><a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/QuickStart.md">swagger-tools Quick Start</a>；</li>
<li><a href="https://github.com/apigee-127/swagger-tools/tree/master/examples/2.0">Demo</a>；</li>
</ul>
<p>其中 Swagger Metadata 中间件做了匹配请求路由与 Swagger 定义路由以及解析参数的工作，Swagger Validator 中间件做了验证参数类型和其他已定义的参数限制的工作。</p>
<h3 id="Mock-返回数据"><a href="#Mock-返回数据" class="headerlink" title="Mock 返回数据"></a>Mock 返回数据</h3><p>使用<code>swagger-tools</code>中的<a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md#swagger-router">Swagger Router 中间件</a>即可实现。</p>
<p>正常情况下，根据你的 Swagger 定义会返回<code>Response Code</code>为<code>200</code>（当 Swagger 定义中已定义<code>200</code>的返回时）的类似这样的数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sample text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;breed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sample text&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sample text&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h3 id="自动生成测试代码"><a href="#自动生成测试代码" class="headerlink" title="自动生成测试代码"></a>自动生成测试代码</h3><p>使用<a href="https://github.com/apigee-127/swagger-test-templates">apigee-127&#x2F;swagger-test-templates</a>可以根据你的 Swagger 定义自动生成对所有接口功能测试的脚手架代码（基本可以自动确定的地方都自动生成了），在你把自动生成的代码写入磁盘文件后，只需修改极少量的地方（一般是提供一些需要测试的参数）就可以使用测试。</p>
<p>自动生成的代码长成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ZSchema</span> = <span class="built_in">require</span>(<span class="string">&#x27;z-schema&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> validator = <span class="keyword">new</span> <span class="title class_">ZSchema</span>(&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> supertest = <span class="built_in">require</span>(<span class="string">&#x27;supertest&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> api = <span class="title function_">supertest</span>(<span class="string">&#x27;http://localhost:3000&#x27;</span>); <span class="comment">// supertest init;</span></span><br><span class="line"></span><br><span class="line">chai.<span class="title function_">should</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;/api/puppies&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">describe</span>(<span class="string">&#x27;get&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&#x27;should respond with 200 An array of puppies&#x27;</span>, <span class="keyword">function</span>(<span class="params">done</span>) &#123;</span><br><span class="line">      <span class="comment">/*eslint-disable*/</span></span><br><span class="line">      <span class="keyword">var</span> schema = &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;array&#x27;</span>,</span><br><span class="line">        <span class="attr">items</span>: &#123;</span><br><span class="line">          <span class="attr">$ref</span>: <span class="string">&#x27;#/definitions/Puppy&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*eslint-enable*/</span></span><br><span class="line">      api</span><br><span class="line">        .<span class="title function_">get</span>(<span class="string">&#x27;/api/puppies&#x27;</span>)</span><br><span class="line">        .<span class="title function_">set</span>(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">        .<span class="title function_">expect</span>(<span class="number">200</span>)</span><br><span class="line">        .<span class="title function_">end</span>(<span class="keyword">function</span>(<span class="params">err, res</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">done</span>(err);</span><br><span class="line"></span><br><span class="line">          validator.<span class="title function_">validate</span>(res.<span class="property">body</span>, schema).<span class="property">should</span>.<span class="property">be</span>.<span class="property">true</span>;</span><br><span class="line">          <span class="title function_">done</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">describe</span>(<span class="string">&#x27;post&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&#x27;should respond with 200 Successfully created&#x27;</span>, <span class="keyword">function</span>(<span class="params">done</span>) &#123;</span><br><span class="line">      api</span><br><span class="line">        .<span class="title function_">post</span>(<span class="string">&#x27;/api/puppies&#x27;</span>)</span><br><span class="line">        .<span class="title function_">set</span>(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">        .<span class="title function_">send</span>(&#123;</span><br><span class="line">          <span class="attr">puppy</span>: <span class="string">&#x27;DATA GOES HERE&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">expect</span>(<span class="number">200</span>)</span><br><span class="line">        .<span class="title function_">end</span>(<span class="keyword">function</span>(<span class="params">err, res</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">done</span>(err);</span><br><span class="line"></span><br><span class="line">          res.<span class="property">body</span>.<span class="property">should</span>.<span class="title function_">equal</span>(<span class="literal">null</span>); <span class="comment">// non-json response or no schema</span></span><br><span class="line">          <span class="title function_">done</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>之后可以考虑用 gulp 把测试串联起来进行自动化测试。npm 上已经有<a href="https://www.npmjs.com/package/gulp-swagger-test-templates">这样的包</a>，不过我还没有试过。</p>
<p>目前这个包对于<code>Swagger 2.0</code>的支持还不是很完全，尤其是对<code>$ref</code>不能自动解析，这样的话需要手动改动的测试代码多一些，不过他们正在着力解决这个问题，估计下一个版本（1.3.0）就会加入对<code>$ref</code>的解析，详细的讨论可以<a href="https://github.com/apigee-127/swagger-test-templates/issues/104">看这个 issue</a>。同时，他们还在考虑添加通过 JSON-Schema 自动批量生成测试数据的功能，目测<a href="https://github.com/apigee-127/swagger-test-templates/pull/107">也将在下一个版本中推出</a>，值得期待。</p>
<h3 id="Mock-或-Swagger-UI-失效"><a href="#Mock-或-Swagger-UI-失效" class="headerlink" title="Mock 或 Swagger UI 失效"></a>Mock 或 Swagger UI 失效</h3><p>由于异步的问题，如果你把<code>app.lieten</code>写在<code>swaggerTools.initializeMiddleware</code>的回调函数外面，那很可能在你的应用已经启动时，<code>swagger-tools</code>的中间件并没有加载完毕，导致中间件失效（不会报错）。</p>
<p>鉴于此，应该尽量把<code>swaggerTools.initializeMiddleware</code>写在中间件链的后面部分，然后把位于其后的<code>app.use</code>（比如<code>app.use(&#39;/&#39;, routes);</code>）和<code>app.listen</code>写在<code>swaggerTools.initializeMiddleware</code>的回调函数内部。所以，<code>Express 4</code>中提倡的用<code>./bin/www</code>来启动应用的要求在这里可能无法被遵循了。</p>
<p>更详细的讨论<a href="https://github.com/apigee-127/swagger-tools/issues/328">看这个 issue</a>。</p>
<p>另外，Mock 失效还有可能是你已经提供了对应 Controller 来 Handle 对应的 Route 请求。并不是将 Swagger Router 中间件中的<code>useStubs</code>设为<code>true</code>就一定会启动 Mock，官方对此说明是：</p>
<blockquote>
<p>Stubs only work for requests where the controller and&#x2F;or controller method is missing. Since you have a working controller method, enabling stub mode doesn’t do anything. It’s working as designed.</p>
</blockquote>
<p>更详细的讨论可以<a href="https://github.com/apigee-127/swagger-tools/issues/48">看这个 issue</a>。</p>
<h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><p>使用<code>DEBUG=swagger-tools* node app</code>启动项目，控制台会输出更多详细的信息。</p>
<h2 id="完整的-Demo"><a href="#完整的-Demo" class="headerlink" title="完整的 Demo"></a>完整的 Demo</h2><p><a href="https://github.com/Maples7/swagger-express-demo">Maples7&#x2F;swagger-express-demo</a>： 将前面所讲的内容整合进了一个小示例中，以供参考。</p>
<h2 id="上手必读"><a href="#上手必读" class="headerlink" title="上手必读"></a>上手必读</h2><ol>
<li><a href="http://swagger.io/specification/">swagger-spec</a>；</li>
<li><a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/QuickStart.md">swagger-tools&#x2F;docs&#x2F;QuickStart.md</a>；</li>
<li><a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md">swagger-tools&#x2F;docs&#x2F;Middleware.md</a>；</li>
<li><a href="https://github.com/apigee-127/swagger-tools/blob/master/docs/API.md">swagger-tools&#x2F;docs&#x2F;API.md</a>；</li>
</ol>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>API</tag>
        <tag>Express</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>完全理解同步/异步与阻塞/非阻塞</title>
    <url>/2016/08/24/understand-sync-async-and-blocking-non-blocking/</url>
    <content><![CDATA[<p>随便翻开一本 Node.js 入门书籍的绪论部分，一般都可以看到「异步」、「单线程」、「非阻塞」这样的字眼。因其采用异步非阻塞的模型而构建，Node.js 得以能充分利用 CPU 资源，具有极强的处理高并发请求的能力。</p>
<p>可是到底什么是同步和异步？什么是阻塞和非阻塞？同步就意味着阻塞吗？异步就一定是非阻塞吗？即便是业务经验十分丰富的 Node.js 程序员，都不一定对这些概念辨别得十分明晰。</p>
<p>本文力求以简明的语言来解释清楚这几个概念并加以区分，但不涉及到 Node.js 底层的具体实现。</p>
<span id="more"></span>

<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>从简单的开始，我们以经典的读取文件的模型举例。（对操作系统而言，所有的输入输出设备都被抽象成文件。）</p>
<p>在发起读取文件的请求时，应用层会调用系统内核的 I&#x2F;O 接口。</p>
<p>如果应用层调用的是阻塞型 I&#x2F;O，那么在调用之后，应用层即刻被挂起，一直出于等待数据返回的状态，直到系统内核从磁盘读取完数据并返回给应用层，应用层才用获得的数据进行接下来的其他操作。</p>
<p>如果应用层调用的是非阻塞 I&#x2F;O，那么调用后，系统内核会立即返回（虽然还没有文件内容的数据），应用层并不会被挂起，它可以做其他任意它想做的操作。（至于文件内容数据如何返回给应用层，这已经超出了阻塞和非阻塞的辨别范畴。）</p>
<p>这便是（脱离同步和异步来说之后）阻塞和非阻塞的区别。总结来说，是否是阻塞还是非阻塞，关注的是接口调用（发出请求）后等待数据返回时的状态。被挂起无法执行其他操作的则是阻塞型的，可以被立即「抽离」去完成其他「任务」的则是非阻塞型的。</p>
<p><img data-src="https://i.loli.net/2018/08/06/5b672dabdf36a.png" alt="阻塞和非阻塞调用模型"></p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>阻塞和非阻塞解决了应用层等待数据返回时的状态问题，那系统内核获取到的数据到底如何返回给应用层呢？这里不同类型的操作便体现的是同步和异步的区别。</p>
<p>对于同步型的调用，应用层需要自己去向系统内核问询，如果数据还未读取完毕，那此时读取文件的任务还未完成，应用层根据其阻塞和非阻塞的划分，或挂起或去做其他事情（所以同步和异步并不决定其等待数据返回时的状态）；如果数据已经读取完毕，那此时系统内核将数据返回给应用层，应用层即可以用取得的数据做其他相关的事情。</p>
<p>而对于异步型的调用，应用层无需主动向系统内核问询，在系统内核读取完文件数据之后，会主动通知应用层数据已经读取完毕，此时应用层即可以接收系统内核返回过来的数据，再做其他事情。</p>
<p>这便是（脱离阻塞和非阻塞来说之后）同步和异步的区别。也就是说，是否是同步还是异步，关注的是任务完成时消息通知的方式。由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。</p>
<p><img data-src="https://i.loli.net/2018/08/06/5b672dabecc59.png" alt="同步和异步调用模型"></p>
<h3 id="Node-js-的异步非阻塞模型"><a href="#Node-js-的异步非阻塞模型" class="headerlink" title="Node.js 的异步非阻塞模型"></a>Node.js 的异步非阻塞模型</h3><p>完整来说，一个最高效且理想的文件读取异步非阻塞模型应该是这样的：应用层发起调用后系统内核立即返回（还没有文件内容数据），应用层继续做其他无关的事情，在系统内核从磁盘读取完数据之后主动通知应用层任务已完成，应用层此时接收系统内核返回的数据，然后继续做其他相关或不相关的事情。</p>
<p>可以看到，在这个模型中，没有无谓的挂起、休眠与等待，也没有盲目无知的问询与检查，应用层做到不等候片刻的最大化利用自身的资源，系统内核也十分「善解人意」的在完成任务后主动通知应用层来接收任务成果。</p>
<p>Node.js 是不是就是这样实现的呢？是，也不是。</p>
<p>现实总是比理想骨感，系统内核并没有理想中那样「善解人意」。异步模型的内核调用在各个平台上实现不一，而且各有各的问题，所以实际上， Node.js 其实是借助多线程来模拟实现了上述理想的异步非阻塞模型。</p>
<p>有人可能有疑问，前面不是说 Node.js 是单线程的吗？</p>
<p>实际上单线程是对用户（使用 Node.js 进行上层开发的程序员，而不是开发 Node.js 的人员）而言的。Node.js 在底层对多个 I&#x2F;O 操作是借助多线程实现异步非阻塞的，具体来说，Node.js 总是存在一个主线程，用来管理调度 I&#x2F;O 线程并进行运算，而其他的线程都是 I&#x2F;O 线程。I&#x2F;O 线程在主线程的调度下与系统内核进行交互完成完成 I&#x2F;O 操作并把数据返回给主线程，而主线程对 I&#x2F;O 线程的调度就完全是上述异步非阻塞的（至于 I&#x2F;O 线程是异步还是同步、阻塞还是非阻塞，已经不重要了，因为它不影响主线程的效率，只要它能按时返回预期的数据就行）。我们平时所说的 Node.js 是单线程的，就是指 Node.js 的主线程。I&#x2F;O 线程完全是对用户屏蔽的，所以用户根本无需关心。</p>
<p>这也解释了为什么我们要避免书写计算密集型或者阻塞的代码，一旦主线程被阻塞，那整个应用就是真的都被阻塞了。</p>
<h3 id="场景举例与总结"><a href="#场景举例与总结" class="headerlink" title="场景举例与总结"></a>场景举例与总结</h3><p>最后，再来举一个我们日常的例子来加深对这几个概念的理解。</p>
<p>假设小明需要在网上下载一个软件：</p>
<ul>
<li>如果小明点击下载按钮之后，就一直干瞪着进度条不做其他任何事情直到软件下载完成，这是同步阻塞；</li>
<li>如果小明点击下载按钮之后，就一直干瞪着进度条不做其他任何事情直到软件下载完成，但是软件下载完成其实是会「叮」的一声通知的（但小明依然那样干等着），这是异步阻塞；（不常见）</li>
<li>如果小明点击下载按钮之后，就去做其他事情了，不过他总需要时不时瞄一眼屏幕看软件是不是下载完成了，这是同步非阻塞；</li>
<li>如果小明点击下载按钮之后，就去做其他事情了，软件下载完之后「叮」的一声通知小明，小明再回来继续处理下载完的软件，这是异步非阻塞。</li>
</ul>
<p>相信看完以上这个案例之后，这几个概念已经能够分辨得很清楚了。</p>
<p>总的来说，同步和异步关注的是<strong>任务完成消息通知的机制</strong>，而阻塞和非阻塞关注的是<strong>等待任务完成时请求者的状态</strong>。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol>
<li><a href="https://book.douban.com/subject/25768396/">《深入浅出 Node.js》</a>第三章；</li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTA1MDUyMA==&mid=2655435714&idx=2&sn=dd23e9d357c3adce3bc1b78956d10105&scene=1&srcid=0423LaJvwtyeAr3OMFwcJeAg#wechat_redirect">聊聊同步、异步、阻塞与非阻塞</a>；</li>
</ol>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>同步</tag>
        <tag>异步</tag>
        <tag>阻塞</tag>
        <tag>非阻塞</tag>
        <tag>「完全理解」系列</tag>
      </tags>
  </entry>
  <entry>
    <title>失落之星</title>
    <url>/2016/09/10/lost-stars/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=28747428&auto=0&height=66"></iframe>
_Life is like a long journey_   
_Some ones get on and some off_   
_Those can accompany me to the destination are rare_   
_Even none_   
_Do not feel bad or complain_    
_Farewell and thanks to each for the company_

<span id="more"></span>  
<p>译自：</p>
<blockquote>
<p>人生就像一场长途旅行<br>有人上车 也有人下车<br>能陪我坐到最后的人少之又少<br>甚至 可能没有<br>所以不要对下车的人太不舍 也不要怨愤<br>要好好跟他们道别<br>感谢彼此陪伴的这一段旅程   </p>
</blockquote>
<p><em>From:</em> <a href="http://m.weibo.cn/5505502029/4018205955518754?uicode=10000002&moduleID=feed&featurecode=10000001&mid=4018205955518754&luicode=10000001&_status_id=4018205955518754&rid=20_0_8_2666547007196013052&fromlog=100013888197280&lfid=100013888197280">Sina Weibo: Pepe佩佩小姐</a></p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>Lost Stars</tag>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title>编程的快感之「易于驾驭的介质」</title>
    <url>/2016/09/20/pleasure-of-programming-media-easy-to-manipulate/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p><em>编程快乐是一种创建事物的纯粹快乐，这种快乐的来源之一来自于在易于驾驭的介质上工作</em></p>
<p><strong>《人月神话》</strong></p>

</blockquote>

<p><a href="https://book.douban.com/subject/1102259/">《人月神话》</a>是几乎每个程序员都或多或少了解过的一本书，著名的<a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">「没有银弹(No Silver Bullet)」</a>的软件工程理论就被其作者<a href="https://en.wikipedia.org/wiki/Fred_Brooks">Fred Brooks</a>收录在这本书中。</p>
<p>这本书的第一章「焦油坑」就讨论了「编程的快感是什么？」这样一个对大多数程序员来说不言而喻，但如果要具体说说或许又难以准确表达出来的一个问题。简要归纳一下，原书提供了这样几个答案：</p>
<span id="more"></span>
<ul>
<li>一种创建事物的纯粹快乐</li>
<li>开发对他人有用的东西</li>
<li>开发过程的强大魅力——将相互啮合的零部件组装在一起</li>
<li>持续学习的快乐以及非重复性</li>
<li><strong>在易于驾驭的介质上工作</strong></li>
</ul>
<p>我对「在易于驾驭的介质上工作」这个原因尤其认同，结合当下的现实，谈谈我的体会和想法。</p>
<h3 id="什么是「易于驾驭的介质」？"><a href="#什么是「易于驾驭的介质」？" class="headerlink" title="什么是「易于驾驭的介质」？"></a>什么是「易于驾驭的介质」？</h3><p>要说这个世界上最易于驾驭的介质是什么，我目前能想到的就是人的大脑（思维）。没有具体的形态，无需任何实体的操作，你想到了什么思维就已经被你操纵到了哪里（我不大确定到底是你在操作大脑还是大脑在操纵你）。你可以在大脑里创造出各种各样没有实体的东西。程序员或者文艺工作者往往有这样的体验，当你才思泉涌时，往往觉得双手都跟不上大脑运转的速度，就好像高速运转的 CPU 无法容忍相对而言低速的 I&#x2F;O 操作一样。</p>
<p>我无法给「易于驾驭的介质」下一个明确的定义，不过如果假设大脑（思维）就是这个世界上最易于驾驭的介质的话，那我可以自然地说能被操纵（manipulate）的速度越接近大脑的速度，这种介质就是越容易被驾驭的。</p>
<h3 id="为什么代码是易于驾驭的介质？"><a href="#为什么代码是易于驾驭的介质？" class="headerlink" title="为什么代码是易于驾驭的介质？"></a>为什么代码是易于驾驭的介质？</h3><p>我的个人经历就可以告诉我，代码绝对是工程领域最易于驾驭的介质。不同于传统的工科领域总是有具体的实体操纵对象或者危险难以控制的操纵对象，编程所操纵的对象——代码——算是太容易操纵的了，这是软件与硬件天然的区别。你无法说你磁盘上的那一串串 0 和 1 是实体的或者是危险的。即使不知名的宇宙射线打过来反转了你电脑内存中的某一个比特位，相信我，也不会有什么东西会爆炸的（或者极小概率）。</p>
<p>基于此，编程工作的易于操作性在于，你只消用你的个人电脑，按照一定的规则在键盘上对代码做出任何你想要的更改，你的程序就可以按照你的预期做出你想要的行为，尽管它没有实体无法给你端茶倒水，但在今天这个互联网时代，却已经创造出了前所未有的价值。</p>
<p>代码之于电脑，就像大脑之于人体一样。</p>
<h3 id="这种易于驾驭的介质带来了什么？"><a href="#这种易于驾驭的介质带来了什么？" class="headerlink" title="这种易于驾驭的介质带来了什么？"></a>这种易于驾驭的介质带来了什么？</h3><ol>
<li><strong>低廉的操作成本</strong>：与世俗的观念还是倾向于不想为看不见的东西的付费有关，操作代码的成本是低廉的，你只需要一台可计算设备即可。</li>
<li><strong>容易传播和产生影响</strong>：下载和使用一个软件现在已经是秒秒钟的事情，好的软件已经非常容易传播和拥有庞大的用户，这同时意味着代码中的任何问题也可能会造成巨大的破坏。</li>
<li><strong>低廉的试错成本</strong>：每一个产品迭代可能需要很多次才能达到用户满意的标准，一个不关键的 bug 可能需要很多次更新才能彻底解决，然而一个医生却无法把病人当成「小白鼠」来多次试验，一个建筑师却难以修补已建成建筑的设计缺陷。（此点灵感来自于：<a href="https://zhuanlan.zhihu.com/p/19690214">程序员混日子不完全手册</a>）</li>
</ol>
<p>把任何实体产业尽量转化为电脑中的 0 和 1，再利用其转化后的优势产生价值，这便是互联网+的本质。<br><br /></p>
<center><b>诸位，幸福地来码代码吧！</b></center>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>程序员</tag>
        <tag>《人月神话》</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存可以用来做些什么</title>
    <url>/2016/10/08/what-can-cache-do/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p><em>There are only two hard things in Computer Science: cache invalidation and naming things.</em><br>—— <strong>Phil Karlton</strong></p>

</blockquote>
<p>缓存是高性能 Web 服务的基本要求，然而对缓存的处理和使用不当将带来一系列的副作用，尤其是同时考虑到服务的高可用性和同步的问题时。</p>
<p>本文将简单探讨 Web 服务中哪些功能适合用缓存（此文均指 Web 后端自行实现的缓存，如使用 Redis）来完成。</p>
<span id="more"></span>

<h2 id="提高性能"><a href="#提高性能" class="headerlink" title="提高性能"></a>提高性能</h2><p>提高服务的性能是缓存最原始的目的，对于数据库中查询频繁而改动不频繁的数据都可以使用缓存以提高服务的性能，这往往是低成本大幅度提高服务性能的手段之一，收效也会非常明显。</p>
<p>对于一个 Web 服务而言，缓存可以从不同的层级高度来展开：</p>
<ul>
<li><strong>路由层级的</strong>：如果是前后端不分离的 Web 服务，可以直接把某个路由下的静态页面缓存（比如未登录情况下具有高访问量的主页，并且不经常被更改时）；如果是前后端分离的 API Server，则是从 API 层级进行的缓存，此时需要注意缓存的 key 一定需要涵盖所有会控制 API 输出的参数。</li>
<li><strong>单个数据库查询层级的</strong>：我们可以把缓存细化到某个数据库查询操作后的数据返回，这样缓存的数据将更细化和可控，缓存的 key 也可以直接对应 SQL 语句中某些关键的参数。此时需要注意的是，被缓存的数据在其他路由或 API 下被更改时，需要即刻删除（对于一般具有实时性要求的服务，否则可以把过期时间设短一些），这样设置缓存操作和删除缓存操作往往分离在不同的路由或 API 中，需要良好的机制来进行一致性的管理和维护。</li>
<li><strong>数据库单条记录层级的</strong>：层级再向下，我们甚至可以从数据库中的单条记录为单位进行缓存。此时缓存数据库实际已经变成了总的持久性数据库的一个子集。这种情况下其实可以把缓存操作从应用层开发隐藏，直接在 ORM 中进行完整闭合的操作，也就是说，应用层无需再关心数据是从缓存来的还是从持久性数据库来的，ORM 在持久性数据库的基础上自行维护好的缓存，这将极大的降低应用层开发的缓存维护工作，同时也可以在一定程度上提高性能。不过相应的，应用层也失去了对缓存的控制力。</li>
</ul>
<p>在一个应用中，可以混合不同层级高度的缓存，以达到服务性能和开发维护成本之间的平衡。</p>
<h2 id="优雅实现指定间隔时间后的内容更新"><a href="#优雅实现指定间隔时间后的内容更新" class="headerlink" title="优雅实现指定间隔时间后的内容更新"></a>优雅实现指定间隔时间后的内容更新</h2><p>一个典型的场景是新浪微博的热门话题：每隔十分钟更新一次，而且访问量极高，此时我们可以把该数据完全用缓存来存储，并且把过期时间设置为十分钟，这样每十分钟缓存失效后，自动从数据库获取（组装）新的热门话题数据并存入缓存，在下一个十分钟内，所有的对热门话题的访问都是直接从缓存中拉取数据的。这样利用过期时间的合理设置来实现完全服务业务需求的功能，连手动删除缓存都免了。</p>
<p>当然，这样的业务需求可遇不可求，遇到一次就要好好把握充分利用。</p>
<h2 id="作为定时器"><a href="#作为定时器" class="headerlink" title="作为定时器"></a>作为定时器</h2><p>相比上一点的业务需求，定时器的需求要常见得多，比如每天定时进行数据同步、日志导出等等，都需要用到定时任务。从 Node 生态来看，实现定时任务的方式很多，最常见的莫过于使用社区提供的<a href="https://github.com/kelektiv/node-cron">cron库</a>。我不知道 cron 库是如何来实现定时任务的，这里仅探讨定时任务的缓存实现。</p>
<p>用缓存实现定时任务其实很简单，本质上跟在程序中设置一个 flag 的思想是一致的，当 flag 的状态翻转时，相当于触发了一个事件，此时响应这个事件来执行一些任务。不同的是，程序中的 flag 是没有过期时间的，它只能在一些特定情形下或者另一些事件后改变状态。而利用缓存的过期时间，我们就可以完成一些定时任务了。</p>
<p>具体来说，我们在缓存中设置一个 flag，并且把过期事件设置为我们需要的定时时间，然后视具体业务对定时的容错情况不断来访问缓存中的这个 flag（为了不阻塞主线程，可能需要多线程支持），当该 flag 不存在后，便执行所需的任务。这样就用缓存实现了定时任务。</p>
<h2 id="node-redis-cache"><a href="#node-redis-cache" class="headerlink" title="node-redis-cache"></a>node-redis-cache</h2><p>在用 Express 开发 API Server 时，没有在 Github 和 NPM 上找到满意的缓存库，于是想自己来重复造轮子了。</p>
<p><a href="https://github.com/Maples7/node-redis-cache">node-redis-cache</a>是我建立并想持续维护的一个缓存库，目前基于<a href="https://github.com/luin/ioredis">ioredis</a>并且被设计成单个数据库查询层级，已经实现了一些常用的兼容原生 Redis 接口的 API，具体使用时只需要在对应的数据库查询外面包裹（wrap）一层即可。</p>
<p>欢迎加入并共同完善！</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Express</tag>
        <tag>缓存</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>我心中理想的 Web 开发流程</title>
    <url>/2016/10/19/ideal-web-development-work-flow/</url>
    <content><![CDATA[<p>本文总结一下在几个月的 Web 开发实践后，我认为的<strong>目前</strong>进行 Web 开发的一些<strong>工作流程</strong>上的最佳实践。</p>
<p>需要事先声明的是，「最佳实践」这个词是相对的。一方面，Web 开发的世界纷繁复杂，我仅有的经验还远远只是管中窥豹的水平；另一方面，使用不同技术栈的人对某一些问题的答案往往存在争议，不同的人从不同的视角来了解 Web 开发这个庞大的领域，产生不同的理解和世界观也是十分正常的事情，需要理性看待。</p>
<span id="more"></span>

<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>都已经是 2016 年了，如果你还只是借助模板引擎在做一些前后端不分离的项目那你已经是 Out 了。</p>
<p>相对于传统意义上的 Web 项目，前后端分离的（本文指的不仅仅是开发模式上的分离，代码上同样也进行分离）Web 开发实践主要有以下几个优点：</p>
<ol>
<li><p>前端和后端并行敏捷开发，而不是传统的瀑布式开发模式：大概几年前，主流的 Web 开发模式还是前端基本完成后，后端再在前端基础上进行不分离的开发。而如今，这种开发模式已经跟不上日新月异的互联网世界的步伐。现在，在前后端统一了 API 规范之后，前端和后端的开发完全可以各自独立的进行，甚至是完全不同的立项。不过，在这种模式下，「契约」变得尤其重要。也就是说，一旦前后端对于 API 的约定一旦达成，就不要进行轻易的更改，如果实在是需要更改，则务必及时沟通协调进行修正（关于开发中的「契约」，建议深度阅读<a href="http://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&mid=402114651&idx=1&sn=a7b891f532e29b73afd83f17ae071023">这篇文章</a>）。在具体的实践上，我建议前后端先使用 Swagger 进行 API 设计和约定，后端迅速搭建出项目框架并定义好 API（但实际功能尚不实现），这样，一个简单的后端框架甚至可以直接作为 Mock Server 提供给前端进行开发使用，进一步降低前后端之间的耦合（关于 Node.js Web 开发下使用 Swagger 进行 API 文档系统的构建的具体实践，可以参考<a href="http://maples7.com/2016/09/06/build-doc-system-of-express-api-server-with-swagger/">我的这篇文章</a>）。</p>
</li>
<li><p>适应现在多形态终端的需求：无论是传统的 Browser 还是如今的各种移动端（手机、平板等），在前后端分离之后，后端都只需要进行统一的一次性开发就可以满足各个终端的数据需求，大大减少了工作量。这才是完完全全的后端只处理纯粹的数据，前端来处理应对各种需求的表现形式。</p>
</li>
<li><p>提高 Web 应用的性能：相对于传统模式，不需要进行模板渲染了，而且分离的模式会更有利于利用 HTTP 头来进行浏览器的页面缓存。</p>
</li>
</ol>
<p>以上还只是从实用主义的角度来看待前后端分离的优点，实际上这种开发方式也符合现在流行的「微服务」的理念。各个模块之间完全只通过 API 跟外界通信。只要 API 约定不变，里面怎么改都可以。高内聚，低耦合。</p>
<h2 id="使用现代化的前端框架"><a href="#使用现代化的前端框架" class="headerlink" title="使用现代化的前端框架"></a>使用现代化的前端框架</h2><p>商业实践目的的后端开发几乎不可能不使用成熟的框架，前端在近几年也频繁涌现出越来越多良好的开发框架。不过，目前前端在是否使用框架这一点上还是仁者见仁、智者见智。就个人而言，我还是推荐使用诸如 Vue.js、Angular.js、React.js 这样的现代化前端框架。原因在于，使用这些框架可以对前端开发进行更好的分层，从而使得项目变得<strong>更加易于维护</strong>。是的，我没有说其他原因，而仅仅是分层模型带来的更易于维护的优势。良好的分层架构可以使前端开发摆脱以前混乱且不统一的布局和架构，使得庞大的项目也能得到有效的维护。</p>
<h2 id="Git-与-Code-Review"><a href="#Git-与-Code-Review" class="headerlink" title="Git 与 Code Review"></a>Git 与 Code Review</h2><p>现代开发团队没有不使用团队协作开发工具的，而这之中最重要的工具就是源代码管理工具。</p>
<p>使用 Git（而不是 SVN）吧！Git 是目前设计理念最先进、使用也最广泛的源代码管理工具，相比一些老式的源代码管理工具有诸多优势（不然 Linus 也不会想去重复造新轮子了）。简单举例来说，Git 创建分支只是添加一个引用，十分迅速，而像 SVN 这样的老式工具，几乎只是在 branch 目录下将当前的主分支复制了一遍。如果你们团队还在使用 SVN 等老式的源代码管理工具，那说明你们的开发团队可能已经掉队很久了。</p>
<p>另一个使用 Git 的好处是，方便团队进行 Code Review。我这里说的 Code Review 不仅仅是很多团队口头上说说、实际却只是有空在代码提交 Log 里面随便看看的那种 Code Review，而是要真正落实到制度和规范上的 Code Review。具体来说，你可以利用一些与 Git 相关的现有的工具来实现一些强制的 Code Review 的规则，比如某个人的代码提交之后，会随机抽取团队中的其他三个人在 48 小时内进行 Review，只有三个人全部都 Review 通过之后，代码才真正提交到测试服务器。团队内部甚至可以做一个绩效考核的应用，可视化的展示团队中人员的代码提交以及 Code Review 的次数等指标（排行榜啊什么的，虽然程序员的绩效实际很难考核，但是不涉及实际利益的绩效展示玩具却可以有效激发程序员的创作欲），这样也可以侧面趣味性的激励团队成员进行 Code Review。</p>
<p>对于团队而言，进行 Code Review 的意义在于：</p>
<ul>
<li>代码质量和软件质量的重要保证；</li>
<li>缩短团队成员之间技术水平上的差距：看优秀的代码可以有效的提高技术水平，Code Review 不仅会促使成员写出高质量的代码，也会迅速把团队中暂时掉队的成员拉到团队的同一水平线上。实际上，软件开发也是有短板效应的，尤其是涉及到安全领域的开发时（Web 安全是 Web 开发中的重要一环），从这一点上看，Code Review 更加具有非凡的意义了；</li>
<li>团队代码风格会更加的统一：简单的制定代码风格规范并不能有效保证团队成员写出风格良好的代码，而 Code Review 机制则可以把良好的代码风格沉淀下去。</li>
</ul>
<h2 id="自动化测试与-CI"><a href="#自动化测试与-CI" class="headerlink" title="自动化测试与 CI"></a>自动化测试与 CI</h2><p>没什么太多可说的，在成熟的团队中，开发人员应该有写单元测试的责任。不写测试的后果是：手动测试浪费大量的人力物力、后期维护极其麻烦且成本高昂（而且任何微小的修改理论上就得手动测试一遍）、代码质量得不到根本上的保证、容易写出架构不合理或者分层不明确的代码。</p>
<p>更进一步来说的话，团队中应该配备有专门的测试人员进行比单元测试层级更高的测试（如集成测试），而且应当尽可能的自动化进行。</p>
<p>如果团队的自动化测试工作做得足够好，那你们应该更进一步考虑整合持续集成（Continuous Integration，简称CI）。这也是前文所说的使用 Git 的优势之一，它对于自动化测试和 CI 都是非常友好的。</p>
<p>至于使用哪种具体的 CI 构建工具，这里没有定论。反正宗旨就是：自动化程度要高、工具鲁棒性要好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下本文提倡的基本的 Web 开发工作流程：前后端制定 API 规范 –&gt; 前后端完全分离开发（使用框架、Git &amp; Code Review） –&gt; 进行自动化测试 –&gt; CI 整合。
 </p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Web 开发</tag>
        <tag>工作流程</tag>
      </tags>
  </entry>
  <entry>
    <title>从个人经历漫谈传统教育与编程</title>
    <url>/2016/11/27/traditional-edu-and-programming/</url>
    <content><![CDATA[<center><b>1</b></center>

<p>这一两年以来，我越来越避免在 Web 的公开领域（甚至在微信朋友圈）说一些有关个人经历的事情，即便有时候为了情境必须得说出一些关于自己的东西，也会在事后把它删除或隐藏。不是担心个人隐私什么的（或者只是很小的一部分原因，这个年代还有个人隐私可言吗？），而是在玩遍社交网络之后，我觉得没必要在虚假的网络说上太多个人相关的东西。真实的世界才是真实，对于网上的东西没必要过于认真，很多事情我们永远无法知道背后的真相到底是什么。</p>
<span id="more"></span>

<p>另外一个原因是，我不希望人们通过网络来认识自己，尤其是对于新认识的朋友。更多地，我还是希望相互的了解能尽量通过 one-on-one 的形式来进行，即便是不能线下有约，通过微信<strong>私</strong>聊也会更好。我们在朋友圈或者微博发的东西都是面向所有人的，在某个情境和上下文下，你在网上发表了一些东西，但我不希望人们在看到这些东西的时候会产生对这个人的「刻板印象」，因为那些东西不能代表一个人本身。</p>
<p>所以，在个人博客中我也是如此，都尽量写一些相对客观实在的谓之「干」的东西，能产生一些价值。但是这篇文章我想说说传统教育和编程，会扯上一些个人的经历来背书，内容很湿很不客观，诸位姑且一看。</p>
<center><b>2</b></center>

<p>我是在进入高中后开始接触编程的，那个时候有幸进入了全省最好的高中（至少是最好的四个之一吧）的理科实验班学习，每个同学都必须在数学、物理、化学、生物以及信息学这五大学科中选择一门作为自己的竞赛科目。基于初中的经验我本来是打算选择物理的，但听说信息学更容易出成绩，年少的我也对这门神秘的学科充满好奇。由于当时做决定的时间很紧张，于是我还没多想就懵懵懂懂的选择了信息学竞赛。这大概是我这辈子在最无知的情况下做出的最正确的决定，如果不是这个选择，我可能还跟很多在校大学生甚至已经毕业了很多年的毕业生一样，完全不知道自己想做什么，想从事什么样的事业，自己真正的兴趣在哪里。</p>
<p>这么多年回过头再去想，即便之后的种种决定都经过了慎重的考虑、广泛的参考，也做出了不少很浑的选择，这之中就包括大学和专业的选择。哈哈，人生有时候就是这么讽刺，上帝他老人家就是很喜欢跟无知的人类开玩笑——「人类一思考，上帝就发笑」。可见，人生很多时候还是需要依赖一些运气和感性的直觉，才不像那些鸡汤中所说的全靠个人的努力和理性的判断，「选择大于努力」，说的就是这样。当然，我现在还不能给每一个选择是对是错下定论，人生一世，谁说得准呢。我只是站在现在这个人生节点上回头望去，非常主观和极其不负责任的对这些选择「狂妄」地评判一番而已。</p>
<p>扯远了。在接触编程之后，我就像 11 岁的 Harry Potter 一样立马被这个「神奇的魔法世界」吸引了。那个时候我们学的是 Pascal 语言（如今这门语言基本只存在于信息学竞赛领域，而且大有被淘汰的趋势），经常解决一个算法问题花费一整天、一晚上而不自知，而且往往还自得其乐。在问题没解决时，它还会萦绕在你的心头，甚至可能在你吃饭时迸发出一些灵感。而在解决问题之后的巨大喜悦，更是让人陶醉。我大概是在编程之后才开始真正学会如何系统地有逻辑地去思考问题的。乔布斯<a href="https://movie.douban.com/subject/6974319/">就在访谈中说过</a>，他觉得每个人都应该学习编程，因为那会教会一个人思考问题的方式，exactly。</p>
<p>虽然高中生参加竞赛本来就是带着很功利的目的的（高考加分和保送政策），但那个时候我却在这件看似功利的事情中找到了真正的快乐。如果现在要来描述这种快乐的话，我推荐你去看看《人月神话》的第一章以及《黑客与画家》，如果没那么多时间也可以看看我的<a href="http://maples7.com/2016/09/20/pleasure-of-programming-media-easy-to-manipulate/">这篇文章</a>，不过我仅仅阐释了能够产生这种快乐的一个方面。</p>
<p>那个时候，比尔盖茨还没有退休，并且常年霸占着福布斯富豪榜头条，苹果和乔布斯在中国还没那么广泛的被人所知，绝大部分人还使用着质量杠杠的诺基亚。那个时候，我深刻的了解到世界上有那么一群人正是在用 IT 技术创造着一些奇妙的东西，他们不用枯燥的背着「之乎者也」「碳氮磷钾」、不用配着莫名其妙的化学方程式、不用算着复杂的二次曲线方程、不用去记可能一辈子用不到的英语单词。他们离我们那么近、那么远……</p>
<center><b>3</b></center>

<p>与创造和用编程解决具体问题的快乐比起来，高考下机械古板的学业压力就显得没那么「可爱」了。我在我身上发现了一个不大不小的规律，一旦我打心底里接受并认同了的事情，我可以把它做得非常好，甚至是强迫症般的追求完美，然而要是我是被迫着去做某些事情，即便我可以强迫着自己很努力，我也无法在潜意识里欺骗自己，而且其结果往往让所有人失望。这也是我<a href="http://maples7.com/about/">自称是「坚定的理想主义者」</a>的原因之一。</p>
<p>高一结束，因为其他学科被我落下很多，在老师和家长的联合「劝说」下，我极其不情愿地退出了信息学竞赛。那时候还中二的我问自己最多的问题是：为什么一定要高考呢？</p>
<p>之后便是枯燥的高中两年，然后是高考失利。然后是非常幼稚的选择大学和专业——说出来你可能不信，即便是经过了充分地考虑，我却没有在那个时候选择计算机专业，大概是高中后两年已经让我忘记了编程能带来的快乐了吧。然后开始憧憬大学生活，而进入大学之后我才被官僚、照本宣科以及本质上与高中无异依然是为了考试而学习的大学生涯感到彻底失望，还算幸运的是自己加入了某个校级组织的技术团队，才让我又重拾了一些创造的快乐。而在大学期间我也利用 MOOC 平台学习了很多计算机相关的课程，因为是真正喜欢编程，这些课程我都取得了不错的成绩，其中两三门还在下一次的开课中担任了助教。</p>
<p>关于大多数国内大学的转专业制度，我很想问这样一个问题：只有当成绩处于当前专业的前百分之十时才能够转到其他专业，既然我本来就对当前的专业不感兴趣，那为什么要先花费大量时间强迫自己应付考试直到排名至前百分之十才能转到其他专业呢？从兴趣驱动学习的角度来说，这难道不是一个本末倒置的逻辑吗？我现在能想到的原因就只能是，那些不进行一线教学工作的教务行政人员为了简化自己的工作而不得不用利用排名制定的门槛罢了。</p>
<p>从那时候开始，我学会了真正的自己为自己做决定，遵照自己内心最本真的声音，放下桎梏地去探索自己真正想要的东西，去创造属于自己的快乐。</p>
<center><b>4</b></center>

<p>关于大学，我并没有大多可说的东西，可笑和不那么让人愉快的事情还有很多，我开始认识到这个世界的真实和形色各异的人类。不过，为了能体现自己主观的态度，做到全文皆是「极其不客观的湿货」，引述一下别人的观点：</p>
<ul>
<li><a href="http://baike.baidu.com/view/2564858.htm">阮一峰</a>，上海财经大学世界经济学博士，目前在上海一所大学任教，同时在国内 Web 开发领域颇有名气，中文版《黑客与画家》就是他的译作。他在<a href="http://www.ruanyifeng.com/blog/2016/10/online_education.html">最近的一篇博文</a>中这样说：</li>
</ul>
<blockquote>
<p>当代的大学起源于欧洲修道院的模式。学生要经过多年的苦修，经过考核，才能毕业。如果想成为高级僧侣，就必须再多熬几年。另外，还有导师作为监督人，防止你学到歪门邪说。这种模式的两大弊端，演变到今天，已经越来越严重了：一个是传授的知识老化，另一个是极其浪费学生的时间。</p>
<p>什么知识才是有用的知识？农业社会，上一代人的知识可以一成不变地用在下一代。而在信息社会，前几年的知识，再过几年就不能用了。</p>
<p>这种情况下，大学应该教什么，我们根本不知道。学生毕业后的行业，现在根本还没有出现。因此，大学只能重点教基础类课程，但这样就会学到大量没用的东西。学生感叹，考试一结束，许多课程这辈子再没有用到的机会了。</p>
<p>更糟糕的是，学生的培养计划，都是一些二三十年前毕业、然后一直待在大学里、与社会生产实践脱节的人制定的。他们的知识和思维早已过时了。这样的人指定你应该学习的知识，很可能在你学的时候就已经没用了。</p>
<p>退一步说，就算你在大学里能学到真正的知识，也不应该在那里待四年。如果只学最需要学习的东西，一年就够了。四年时间足以让一个人在任何领域成为资深业者，甚至专家。可是我们的大学生呢，经过本科四年，不要说领域专家，甚至能力强的学生都寥寥无几。我们的大学制度用了四年时间，培养出了大量一无所长的、迷茫困惑的、市场滞销的年轻人。</p>
<p>18 岁是人生最有热情和精力投入一项事业的时候，但是，大学将你一连四年关在教室和图书馆里，把考试和绩点伪装成你奋斗的目标，人为将你与真实世界隔离，引导你去关注那些对未来人生毫不重要的事情。经过这样四年的歧途，等你真正走上社会、要跟全世界竞争的时候，你的竞争力不是变强了，而是变弱了。换句话说，四年制大学很可能是削弱你，而不是让你变得更强。</p>
<p>世界著名程序员 Jamie Zawinski 曾经解释，为什么他只读了一个学期的大学就退学：「进了大学以后，每天 8 点就要起床，开始训练记忆力。有一门课我早就会了，想申请免修。教务长说不行，你必须上，这是政策。见鬼，我为什么要自己付钱，来这种地方。我就退学了，从来没后悔过。」</p>
<p>我们时代的很多成功者—-乔布斯、比尔盖茨、扎克伯格等等—-都是退学生，这绝不是偶然的。不是他们在大学待不下去，而是他们发现，没必要在那个地方待四年。如果他们咬着牙忍受下去，熬到拿到文凭的那一天，苹果公司和微软公司可能都不会有了。</p>
<p>读大学，只是 18 岁时很多种选择中的一种，不是唯一的选择，更谈不上是最好的选择。校园是一个美丽的地方，但是如果一定要在里面待上四年，那还是算了吧。</p>
</blockquote>
<ul>
<li><a href="http://tchen.me/pages/aboutme.html">陈天</a>，北航软件工程毕业，企业家和全栈工程师，现居旧金山。他在 2014 年的一篇微信公众号（programmer_life）文章<a href="http://mp.weixin.qq.com/s/pIJYSOEeaeu6HTobFvg4sw">《谈谈大学》</a>中这样说：</li>
</ul>
<blockquote>
<p>很多课本我自学的效果要比听老师讲还好 —— 其实大部分时间，老师不是在讲，而是在板书。学过的好几门专业课中，老师板书的欲望比小男生们想妹纸的欲望还要强烈。</p>
<p>所以我逃课的概率越来越大，参加科协活动的时间越来越长。我喜欢和一群对技术有着挚爱的人聚在一起，哪怕他们在贬低我的 asp，抬高他们的 php，我也无所谓，只要不要让我听到粉笔敲击黑板的声音就成。</p>
</blockquote>
<blockquote>
<p><em>（另一段）</em> 比赛归来，我正式加入了实验室的 863 项目组，研究扯淡的虚拟企业信息集成。扯淡归扯淡，论文还是要发表滴。经历几次失败后，我摸索出发论文的技巧，成功以第一作者身份在核心期刊「计算机应用」（成都的，好像是这个名字）发了一篇文章。我默默地感觉在国内核心期刊上发表论文也不过如此 —— 精髓就几个字：「把简单问题复杂化」。比如说，一个你跟同学都能说得明白的算法肯定上不了台面，必须将其公式化，公式越复杂越好，最好看的人觉得「哇靠，屌爆了」，那你就成功了。当然，光有公式化的算法还不够，你还要有牛逼的定义，再辅以云里雾里的示意图。示意图和公式要一个德性，不是用来让人看懂的，而是让人看不懂 —— 别人越看不懂，你的逼格就越高。如法炮制，我又发表了两篇核心期刊。</p>
<p>之后再发表就没有意思了。整个学术界的迂腐让我震惊，大家都不得不跟吞了鸦片一样，在烟雾缭绕中极尽浪费生命之能来摧残自己的智商。</p>
</blockquote>
<p>在传统的世俗成败观上，这两人都可以说是在现行大学体制下颇为成功的人物，但他们依然发出了这样的声音。</p>
<p>引述他们的这些文字基本能够表达我主观的意思。传统教育尽管确实问题百出，但我觉得最让人感到绝望的一点还在于，十年前在用的教育制度和理念，十年后居然还是一层不变，看不到一点改观和生机。实在很难让人相信这是被誉为「象牙塔」的大学教育。</p>
<center><b>5</b></center>

<p>不过，客观地讲，我并不认为大学教育是完全不必要和一无是处的。大学的可取之处不在于它现行的教育体制和教育方式，而是它能够为刚结束高考步入成年社会的少年们搭建这样一个相对自由的平台和环境。在这样的环境中，你第一次开始有了比较充分的自主权，开始认识各种各样的人、经历各种各样事情，开始学会独立思考，开始懂得如何成为一个有血有肉有更高追求的高素质的人。随之而来的眼界的提升、视野的开阔、综合素养的培养等等，不必多说。当然，准确地说，这些好处是这样的客观环境所带来的，而不是现行大学制度主观培养出来的。也就是说，只要客观提供这样的平台和时间（比如四处游历，但我不确定），不一定非得在大学，一样可以得到这样的培养。</p>
<center><b>6</b></center>

<p>最后，为了避免有人随便看了一眼内容中的几个词就给我主观臆断的随意贴上「反智」的标签，我提前给出我的解释：我推崇纯粹而自由地学习各种各样自己感兴趣的知识，不分文理，不分学科，这些知识不一定非得是客观有用能立即产生价值的，但绝对不是绑定了太多功利目的或因为制度的缺陷和僵化而半被迫的去学的。底线的条件的是，它得是你真正感兴趣并自发的愿意去深入学习的。</p>
<p>编程就是这样一个我愿意自发的去探索的领域，但你的领域可能并不在这里。值得一提的是，随着近年互联网势头的火热，很多人抱着很功利的目的成为了程序员，但他的实际兴趣可能并不在此，工作也只是应付过去，当然也没有更高的技术追求和主动探索的动力。我并不看好这样的人，我只能真心的希望他们能早日听到内心的声音，发现真正的兴趣，早日打开新世界的大门。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>程序员</tag>
        <tag>教育</tag>
      </tags>
  </entry>
  <entry>
    <title>学生心态与产品演进之路</title>
    <url>/2016/11/22/stay-hungry-stay-foolish/</url>
    <content><![CDATA[<p>对于工作稳定的开发者而言，我们每天大多数时间都是在做着我们熟悉的事情。一个又一个不同的业务丢过来，我们却基本上总是使用着我们早已熟悉的技术栈。很多技术先驱们提倡开发者要学会远离自己的 comfort zone，学习一些新的我们所不曾了解的东西。是的，一个没有更高技术追求的开发者很难长久的在技术这条路上走得长远，更是难以达到一定的技术高度。</p>
<p>选择了开发者这条职业之路，也就同时意味着这将是一条不断学习新知的道路。这篇文章将指出一个已经对自己常用的技术栈熟知的开发者，在学习新知的过程中可能会遇到的一个典型的问题。也许这个问题不仅仅是针对开发者，任何一个对自己常接触的业务领域技能熟知的职业人，在接触到新的知识领域时，都有可能会遇到这样的问题。</p>
<span id="more"></span>

<p>作为开发者，一个典型的场景就是我们需要在已有技术知识的基础上学习一些新的技术。你可能需要学习一个新框架如何使用、一个第三方服务的 API 如何合理的调用，更甚者，你可能得从后端开发转到前端开发、从移动端开发转到后端开发等等。在学习新东西的过程中，我发现我们极易犯一个心态上的错误——即不能正确的以一个小白的心态来学习新的知识。</p>
<p>这样说可能对开发者而言有失公允，实际情况可能是，我们会主动的使用我们已经掌握的知识作为参考和背景知识来辅助学习新的知识，这其实是一件很自然也很正确的事情。然而，不知道有没有人有这样的感觉，一个已经有一定使用某一框架开发经验的程序员，与一个毫无开发经验的毕业生，同时学习另一个新的框架来实现一个不算太有难度的业务，往往那个毕业生可以先交出成品。当然，这件事不尽然，但确实有这样的情况发生。表面上，似乎已有的开发经验成为了我们学习新知的负担，真的是这样吗？</p>
<p>造成这种现象的原因我觉得可能有以下几种：</p>
<p><strong>1. 可能你并没有真正打心底里认同这门新的技术。</strong></p>
<p>你可能一开始只是听别人说，有些好奇，于是尝试着去了解这门新的技术，然而发现它并没有你想像的那么好，很多指导思想十分陈旧，使用起来也不是那么的优雅。情况可能真的就如你想的那样，也许你已经掌握的技术确实比这门新技术设计上要先进一些，但我觉得另一种概率更大的可能是你还没有真正体会到这门新技术的精髓。它可能表面上看起来有一些蠢，和你已有的认知有一些出入，但你不妨再耐心一些，深入进去，多问一些为什么，了解这门技术这样设计的真正动因，当你真正开始认同这门新技术的时候，你可能就真正打开了另一个新世界的大门了。</p>
<p>我之所以说「你可能还没有真正了解新技术的精髓」这种情况的概率更大的原因是，我们在已有技术的基础上，往往能一眼分辨出比这种技术设计更丑陋的技术有哪些，却不能立马分辨出比这种技术设计更优秀的优秀之处在哪里，这是我们所掌握的编程思想所决定的。既然是能诱使你好奇去尝试学习使用的技术，我想一般应该是设计更先进的技术吧。</p>
<p>当然，你也可能完全是因为团队或上级要求，去学习一门新的技术，如果这门技术的确比你已经掌握的技术设计上更糟糕（或者技术社区中确实大部分人都这样认为），那确实挺难打心底里去认同的。这种情况我建议你好好准备准备，充分了解这门新技术比你掌握的技术差在哪里，然后跟团队的技术 Leader 好好谈谈，争取策反他吧。</p>
<p><strong>2. 你对自己的代码质量要求太高了。</strong></p>
<p>这种情况可能更普遍。对于大多数摆正心态的有经验的程序员而言，并不是他们没有认真学习新的知识，而往往是他们对自己的代码质量要求太高。</p>
<p>我们在已有的知识积累中沉淀出了一些做任何类型开发都需要了解的一些知识，并内化到了自己的知识体系中，比如一些软件工程的思想、一些常用的设计模式等，这些经典的思想限制着我们不愿意写出太烂的代码。我们总是想着我们的代码分层良好、复用程度高、易于后期维护、易于扩展、安全性更好等等，然而此时我们对具体的新技术的掌握还并不允许我们写出这个技术领域符合这些通用技术思想要求的代码。这种具体的技术可能是一门新的语言，你在对这种语言的语法都还不熟悉的情况下，是不可能写出高质量的代码的。然而犹如一张白纸的应届生是不会有这样的顾虑的，能够实现功能可能对他们就已经一种全新的尝试了，所以他们往往可能能更快的做出一个成形的东西来。</p>
<p>这可以说是一种「了解得更多的烦恼」，我们唯一能做的就是摆正心态，再脚踏实地一些，不要还没学会走路就企图要跑。新技术在你还没掌握之前对你而言它就是新的。如果你以前用你已经了解过的技术随随便便就能写出高质量的代码，那么在这个全新的领域里，我们还是得从一行行的烂代码开始积累起。</p>
<p>另外需要说明的是，原有的经验积累并不是毫无用处的，我们正是因为了解我们写出的新代码的缺陷可能在哪些地方，我们才能更加明确我们改进的方向。如果要比较谁能把工程代码写得（或改进得）更好，那我想应届生们是断然比不过有经验的老程序员们的。其次，一些其他的软技能，比如查找资料的能力、借助互联网解决问题的能力、对 Bug 可能原因的敏感度等等，这些也是宝贵经验带来的财富。</p>
<p>其实做产品也很容易犯这样类似的错误。</p>
<p>一些没有经验的产品经理或者做自己 Side Project 的程序员，往往一开始就把自己的产品构思得很好，并且企图第一版就把功能做得很完美。这样的想法能好，但是太不现实。「罗马不是一天建成的」，任何伟大的产品也是从一点一滴琐碎的改进中积累来的。一开始，它们可能很烂，性能差、页面分布不合理，甚至有明显的 Bug 等等，但经过不断的迭代与打磨，慢慢的它才会变得优秀、变得无可替代、变得不可或缺。尤其是在这样一个互联网浪潮下，任何的机会都经不起犹豫和等待，一个一开始就追求完美的产品，等不到出生，就已经死了。</p>
<p>说了这么多（甚至个人觉得好像有点儿鸡汤味儿……），其实总结起来也就还是乔布斯的那句话：</p>
<p><em>Stay hungry, stay foolish.</em></p>
<p>不仅仅是在行动上，更是在心态和产品设计理念上，用这句话来武装自己。保持学生心态，一点一滴脚踏实地的积累和迭代，才能调和出不一样的色彩。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>学生心态</tag>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Node.js 正名的二三事</title>
    <url>/2016/12/15/awesome-node/</url>
    <content><![CDATA[<p>这篇文章的起因是《程序员》杂志上的这两天在前端界闹得沸沸扬扬的文章——<a href="http://geek.csdn.net/news/detail/128912">《2016 年前端技术观察》</a>，我在知乎上看到相关文章的时候大概已经是凌晨两点，看完后（准确说，前端我不大了解的部分没怎么细看）「精神抖擞」，当即在知乎写下了这个回答：<a href="https://www.zhihu.com/question/53625757/answer/135902282">如何评价真阿当的文章：《2016 年前端技术观察》？</a>。</p>
<p>前端不够了解就不多说什么的了，但我发现现在确实还有一些不搞 Node.js 的人像上文作者那样把 Node.js 当做「玩具」来看待，所以才想写下这篇文章。</p>
<span id="more"></span>

<p>我是在大一从 PHP 和 Python 入的 Web 后端的坑，当时在学校技术组织还基本是玩票的性质，等真正在工业实践中进行 Web 后端开发，则完全是从 Node.js 开始的（老实讲，我看到的工业实践中的代码还真不一定比在学校的技术组织的代码质量高）。期间也搞过 ASP.NET Core（C#），而且目前大多数时间还是在写 PHP。我之所以要说这些是因为，总是有人会说 Node.js 只是那些前端的人才玩的，说那些人没有后端思维什么的云云。我承认前端开发与后端开发考虑的问题确实很不一样，但如果你硬要认为前端的人来搞 Node.js 不能准确的对 Node.js 在后端开发的表现进行评估，那我可是一开始就真真切切的从一个后端的角度来看待 Node.js 的。</p>
<p>第一个需要为 Node.js 正名的是：Node.js 在目前主要还是后端的技术（至少肯定不是前端的技术）。尽管前端的同学常拿 NPM 来做包管理、用 Node.js 来写一些自动化脚本，也改变不了 Node.js 是为 Web 后端设计的本质。当然，现在 Node.js 跟很多主要用来做 Web 后端的语言一样，也可以来写 PC 端应用，但还不是主流。岗位划分上，很多公司把 Node.js 归类到前端组，这在一定程度上误导了初学者。 </p>
<p>从我在 PHP、Python、ASP.NET Core（C#）、Node.js 这些 Web 后端的体验来看，我非但没有觉得 Node.js 在后端开发上有什么明显的不足，反而觉得在很多方面比那些传统主流的 Web 后端技术要好上不少。下面来一一分析。</p>
<h2 id="不稳定？"><a href="#不稳定？" class="headerlink" title="不稳定？"></a>不稳定？</h2><p>这大概是我最常听到的对 Node.js 的质疑。当跟不熟悉 Node.js 的开发者讨论的时候，他们总是会质疑用 Node.js 写的应用是不是不稳定？能不能写大型应用？有哪些业界有名的公司在使用它？……然而如果问他们为什么说 Node.js 不够稳定时，他们开始变得支支吾吾，说自己不是主要搞 Node.js 的对此并不了解，只是听别人常这么说。</p>
<p>我不知道质疑 Node.js 是否稳定的疑虑是从哪里跑出来的（早期不成熟版本给人的印象？我不知道……），从我个人的开发经验来看，那些写过 Node.js（以下或简称为 Node） 还质疑其稳定性的人往往是因为自己对 Node 的理解不够深。比如经典的异步流程控制问题，在具体写代码时确实需要注意一些细节，但关键还是要理解 Node 异步的本质，这样才能轻松写出符合自己对它的行为期望的代码。但不能因为自己对语言最大的特点理解不够，写出了自己难以解释其行为的代码，就对别人说这门语言（或者说实现）不稳定吧。</p>
<p>如果你还是对 Node 的稳定性有疑虑，你知道 <a href="https://github.com/Unitech/pm2">PM2</a> 吧？那 <a href="https://github.com/foreverjs/forever">Forever</a> 呢？如果你依然不放心，那你还可以在 Node 应用外加一层反向代理，过滤掉网络世界里一些「肮脏」的信息。</p>
<h2 id="性能不够？"><a href="#性能不够？" class="headerlink" title="性能不够？"></a>性能不够？</h2><p>Node 当初就是以单线程异步非阻塞特性在高并发下的优良表现进入大家的视野的，加上 Google 的 V8 JavaScript 引擎，在性能上至少绝对不会成为其短板。虽然微软新推出的 ASP.NET Core 一度宣称<a href="https://blogs.msdn.microsoft.com/dotnet/2016/06/27/announcing-net-core-1-0/#user-content-net-core-usage">其性能是 Node.js 的 8 倍</a>，但脱离的具体的业务场景来谈性能完全就是耍流氓，这种测试与其说是技术上性能的对比，不如说是为了 marketing 的目的而制造的噱头。</p>
<p>进一步说，真实的业务场景中语言（或者说其实现和技术栈，以下同）几乎不可能真正成为性能瓶颈，带来的瓶颈的往往是 I&#x2F;O 部分。注意，这并不说语言对此没有责任，难以优化的 I&#x2F;O 性能瓶颈可能是因为开发人员由于语言特性写出了不易扩展和优化的代码，这往往是对性能产生更大影响也更有意义的方面，所以因此换语言也是有可能的（比如 <a href="https://www.quora.com/Why-did-Twitter-switch-to-a-Java-based-front-end-after-successfully-using-Ruby-on-Rails-with-200-million-users">Twitter 曾经从 Rails 换到 Scala</a>），但不是说语言本身的运行性能有什么太大的问题。</p>
<h2 id="第三方库的质量太差？"><a href="#第三方库的质量太差？" class="headerlink" title="第三方库的质量太差？"></a>第三方库的质量太差？</h2><p>我认为这非但不是 Node 技术生态圈的缺点，反而是其对比其他技术生态圈最大的优势。无非你遇到什么问题，无论你想找什么样的解决方案，在 2016 年接近尾声的今天，你都可以在社区找到灵感、吸收别人的养分、站在巨人的肩膀上。换句话说，你在社区提出一个问题，你可以快速且明显地感受到社区的热情。</p>
<p>截至目前，NPM 上已经有 385684 个 packages。而 GitHub 上 2016 年流行语言排名，JavaScript 更是<a href="https://octoverse.github.com/">超过第二名两倍还不止</a>（当然这之中前端 JS 的贡献也很大）：</p>
<p><img data-src="https://i.loli.net/2018/08/06/5b6730412457a.png" alt="15 most popular languages used on GitHub in 2016"></p>
<p>可以说，目前没有一个技术社区的社区活跃度比得上 Node&#x2F;JS 社区。</p>
<p>而至于质疑第三方包质量太差缺乏审核……诶，你是知道广电的电影审查制度的吧？</p>
<p>正是因为 NPM 使得发布一个包变得如此的简单，才极大的激发了开发者的热情。积木总是越搭才会越高的，需求也总是多种多样的，正是庞大的第三方包的基数使得开发者们有了更多的选择，优秀的第三方包也会在绝对数量上越来越多，从而可以实现更复杂更困难的业务需求。</p>
<h2 id="其他问题……"><a href="#其他问题……" class="headerlink" title="其他问题……"></a>其他问题……</h2><h3 id="自动化文档？参数验证？"><a href="#自动化文档？参数验证？" class="headerlink" title="自动化文档？参数验证？"></a>自动化文档？参数验证？</h3><p><a href="http://swagger.io/">Swagger</a> 不是针对某一门特定语言的（<a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger">ASP.NET Core 的官方文档就是推荐的 Swagger 作为文档系统</a>），也可以参考我的这篇文章：<a href="http://maples7.com/2016/09/06/build-doc-system-of-express-api-server-with-swagger/">使用 Swagger 构建 Express API Server 的文档系统</a>。</p>
<h3 id="Express-不够强大？不够标准？"><a href="#Express-不够强大？不够标准？" class="headerlink" title="Express 不够强大？不够标准？"></a><a href="http://expressjs.com/">Express</a> 不够强大？不够标准？</h3><p>Express 可以很好的让初学者了解一个常规的 Web 框架在底层是怎么处理问题的，甚至还可以阅读其源码了解其实现。但如果你还是因为不管什么原因不喜欢它，你还可以有各种各样的选择：<a href="http://nodeframework.com/">Hand-picked registry of Node.js frameworks</a>。这里我想着重提一下 <a href="http://feathersjs.com/">FeathersJS</a>，如果你觉得 Express 对于 HTTP(S) 或者 REST <strong>标准</strong>的支持不够专一和规范，你可以考虑看看这个框架，个人认为它在很多关键问题的处理上都有很规范的做法（拿 Express 跟它比可能对 Express 不大公平，它本身是基于 Express 的更高层次上的封装）。</p>
<h3 id="自动化测试？"><a href="#自动化测试？" class="headerlink" title="自动化测试？"></a>自动化测试？</h3><p>不必多说什么，mocha&#x2F;should(chai)&#x2F;supertest&#x2F;istanbul 基本已经成为共识，大不了再加个 rewire。而如果这样你还觉得麻烦，社区里已经有各种各样基于这些包的使用更方便的封装了，基本思路大概是像写配置一样写测试样例，然后写 Parser 把这些测例加载并解析再去自动化测试。</p>
<h3 id="……"><a href="#……" class="headerlink" title="……"></a>……</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实上述我说的这些问题早就有技术前辈们的布道和背书，我也不过是拾拾牙慧而已。技术人还是要多保持独立思考，与其道听途说，不如实实在在的自己去了解实践，亲身去感受，得出自己的结论。</p>
<p>哦，对了，<a href="https://www.zhihu.com/question/53625757/answer/135981220">我这篇文章也可能完全都是错的</a>。</p>
<p>:D</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Web 开发</tag>
      </tags>
  </entry>
  <entry>
    <title>2016 年书单</title>
    <url>/2016/12/31/2016-booklist/</url>
    <content><![CDATA[<p>从今年开始，打算每年年终的时候总结这一年读过的书的书单，看看我能坚持多少年。不求看书数量上的多少，只求在每本看过的书中都能找到一些能内化成自己所能掌握的东西。这样做也是希望即便已经没有校园里大把的闲散时间读「野书」，也能不放弃这样的习惯。</p>
<p>今年是个人状态变化非常大的一年，走出校园，面向社会，经历了找工作、毕业季的纷扰、实习等等各个阶段，总是有些杂七杂八的事情要处理，看的书也不多。而且基本是初次正式的接触 JavaScript 和 Node.js，也接触了很多商业实践中正在使用的热门的应用类技术，需要学习的东西很多，所以看的技术类的书也会多一些。</p>
<span id="more"></span>

<p>以下书单基本按照今年读过时间顺序排列，每本书配有自己的打分和一两句话（链接大部分指向豆瓣的地址，给出版本和出版社等更多信息），这一两句话可能是对书内容的简要总结，也可能是自己的点评。</p>
<ol>
<li><p><a href="https://book.douban.com/subject/25862578/">解忧杂货铺</a>：★★★★<br>非典型东野圭吾式小说，故事设计精巧，叙述方式是小说的亮点。不过整篇下来感觉有点单薄，没有他巅峰时期写的小说看得过瘾。<br>像豆瓣上有人说的，这是东野圭吾写给成年人看的童话。</p>
</li>
<li><p><a href="https://book.douban.com/subject/20443559/">小王子</a>：★★★★☆<br>读正文之前一定得先读读李继宏写的导读，写得十分出色。<br>这本书一点都不长，任何大人初看起来都会觉得这是写给小孩子看的童话。但如果你不能用心来尊重这部作品，那就像书中所说，「大人是无法看懂的咯」。虽然表明上看是童话，但作者字字珠玑，无处不透露着生活的哲理和对人性的思考。<br>其次，作为诗人的作品，实在文笔简练优美、朴素纯净、充满诗意。<br>永葆童心，在你还能认真对待这本书的时候。<br>「大人们真奇怪。」<br>「真正的东西肉眼是无法看见的，要用心。」<br>我以后一定会给我的孩子读这本书的。</p>
</li>
<li><p><a href="https://book.douban.com/subject/20471120/">打造 Facebook</a>：★★★★<br>在我看来，这本书相当有价值，尤其是对于一线互联网工程师来说。<br>豆瓣的评论中有人说书名「打造 Facebook」写得太大，内容并不是真正教你如何「打造」一个 Facebook 的。我觉得有这样想法的人过于功利和浮躁。<br>实际上，作者已经把他在 Facebook 高速发展阶段的观察和经验，尤其是作为一个「潜在」创业者的角色和心态深入内部来仔细考察这个目前世界上最伟大的互联网公司之一的杰出经验，都写出来了。这些经验不仅有针对工程师（技术）的，也有针对管理者的。    </p>
</li>
<li><p><a href="https://book.douban.com/subject/10546125/">JavaScript 高级程序设计（第三版）</a>：★★★<br>所有与前端相关的部分我都没看，我觉得是一本明显在国内过誉了的 JS 入门书，不如犀牛书讲得透彻。</p>
</li>
<li><p><a href="https://book.douban.com/subject/3590768/">JavaScript 语言精粹</a>：★★★★<br>一本其他与 JavaScript 相关的书籍都会「恭维」一下的 JavaScript 书。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25767596/">了不起的 Node.js</a>：★★★★<br>非常好的 Node.js 实操入门！不过中文版错误有点多，版本有点老。</p>
</li>
<li><p><a href="https://book.douban.com/subject/24697636/">三重门</a>：★★<br>文字过于老成，思想过于中二。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25867920/">Node.js 实战</a>：★★★★<br>实战两字不虚。</p>
</li>
<li><p><a href="https://book.douban.com/subject/10789820/">Node.js 开发指南</a>：★★★★★<br>不如叫《Node.js 入门精粹》吧！</p>
</li>
<li><p><a href="https://book.douban.com/subject/26301434/">Node 与 Express 开发</a>：★★★<br>全、泛、广、浅、新，且翻译不畅，不过算个不错的技术栈索引。</p>
</li>
<li><p><a href="https://book.douban.com/subject/5313010/">Facebook 效应</a>：★★★★<br>Facebook 的人文社科历史进程。</p>
</li>
<li><p><a href="https://book.douban.com/subject/1024570/">编码的奥秘</a>：★★★★★<br>一本足以让国内数电、单片机教材汗颜的书，写了一些程序员必须了解的底层知识。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25891771/">失乐园</a>：★★★★<br>性、爱、死亡与人生。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25786138/">Effective JavaScript</a>：★★★★<br>给《JavaScript 语言精粹》做的完美补充。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26579320/">JavaScript 函数式编程</a>：★★★★<br>打开函数式编程新世界的大门。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25747921/">从你的全世界路过</a>：★★★<br>嗯哼。反正是过了看这种书的年纪了。</p>
</li>
<li><p><a href="https://book.douban.com/subject/1012611/">乌合之众：大众心理研究</a>：★★★★<br>一本百年前写的却依然对现实社会具有诸多指导意义的书。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26351021/">你不知道的 JavaScript（上卷）</a>：★★★★<br>不如叫《JavaScript 语言剖析》吧！<br>作者十分幽默，但是观点也不能全信，不信你可以敲一敲示例代码看看结果。</p>
</li>
<li><p><a href="https://read.douban.com/ebook/20769128/">北京折叠</a>：★★★★★<br>科幻中折射出了最真的现实。<br>一两个小时就可以看完，预计两年之内会被翻拍成电影。</p>
</li>
<li><p><a href="https://read.douban.com/ebook/23111860/">请发猫照片</a>：★★★<br>大概是想说人要对自己负责吧，可是真的没必要套上 AI 的外壳的。     </p>
</li>
<li><p><a href="https://book.douban.com/subject/25127404/">人间失格</a>：★★★★★<br>颓圮就像咖啡色儿的毒药，有一种致命的美。</p>
</li>
<li><p><a href="https://book.douban.com/subject/1102259/">人月神话</a>：★★★★<br>每一个优秀的产品经理或者策划都比程序员更应该好好看看这本书。     </p>
</li>
<li><p><a href="https://book.douban.com/subject/25768396/">深入浅出 Node.js</a>：★★★★★<br>中文出版界 Node.js 第一书！<br>觉得这书写得不好的只是因为自身 Node 的火候还不到而已，源码永远是一个软件最好的背书。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25962533/">神奇动物在哪里</a>：★★★★<br>罗琳是唯一能和魔法世界对话的人，她把她知道的故事讲给麻瓜听。<br>这是一本让麻瓜有魔法世界浸入式体验的神奇动物百科全书，邓布利多亲自作序，适合哈迷细细考究。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26854244/">你不知道的 JavaScript（中卷）</a>：★★★★☆<br>三年前 JavaScript 进阶你可能会推荐看《JavaScript 语言精粹》，但现在我推荐这个系列。<br>实际上中卷对《JavaScript 语言精粹》里的很多偏见做了更辩证更符合当下实践需求的深入阐述。<br>不过，书中观点依然还是要辩证看待，而且还有一些明显的小 bug，但基本不影响阅读。   </p>
</li>
<li><p><a href="https://book.douban.com/subject/26871656/">哈利·波特与被诅咒的孩子</a>：★★★☆<br>时空穿越本身带来的漏洞多得都不敢想，所以罗琳才会机智的在原著第五部中把所有的时间转换器给毁了。而这本书却刻意制造了这样一个 bug。<br>对不起，即便是情怀最多也就三星半。<br>当然，本书也不是一无是处，想看的话随便看看就好，别太当真，但一旦开始看了就坚持到最后，因为后面还是有一些看点的。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25826578/">MacTalk·人生元编程</a>：★★★★<br>一本高质量的博文汇编成的书，非常适合程序员入门 macOS。而且内容干湿比例匀称，更重要的是还有作者作为开发者一路走来的各种心得体会、人生经验，以及人文关怀。<br>可以买来作为睡前读物。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25985021/">人类简史</a>：★★★★☆<br>看完这本书我更加相信，人类从农业革命以来就构建了不正确的社会形态，奠定了阶级与剥削罪恶的源头。<br>看来只有传说中的共产主义社会能够拯救人类了&lt;滑稽脸&gt;。<br>但可悲的是，共产主义社会，也很可能只是我们想象出来的维持现有社会秩序的虚假故事罢了。是的，从农业革命开始，人类就已经不可能脱离想象来构建秩序。<br>第 6 章和第 16 章写得极好。       </p>
</li>
<li><p><a href="https://github.com/addyosmani/essential-js-design-patterns">Learning JavaScript Design Patterns</a>：★★★★<br>这本书的中文译本翻译得实在太烂了，我这么不挑剔的人看了前几十页实在看不下去了。译者态度显然有问题，比机翻的质量好不到哪里去。所以之后果断选择的阅读英文原版（链接给出的是这本书的 GitHub 地址，原版可以随时免费在网上阅读）。<br>反对一切原本适用于 OO 的模式硬往 JavaScript 身上套，但是有常用的设计模式理念和思想确实是有用的。</p>
</li>
</ol>
<p>另外，今年我还重温了一些日久弥新的经典著作，因为是「重温」，就不列举了。</p>
<p>看书不必刻意追求数量和速度（尤其对于技术类书籍），但事后这样一算，今年平均每个月大概是两本多新书，对于今年的状况来说，基本正常。 </p>
<p>实际上，读书也只是学习知识（甚至是消遣和打发时光）的一种方式，在这个时代，还有很多的方式可以选择。对于程序员来说，读一些优质的博客、看技术文档、逛技术论坛、听技术播客，甚至看 MOOC 都有机会可以学到很多东西，有些东西是拓展自己知识的广度（视野）的，有些则可能完全是干货。而一般来说，看电影、看剧、出去旅行都可以提升自己。我这样说的意思是，在这样一个开放多元的互联网时代，思想不要太保守，不必过于迷信一定要通过读书的方式充实自己，找到适合自己的方式就好。</p>
<p>至于是看纸质书还是电子书的争论，我个人的喜好是，技术类书籍有纸质书更好，没有的话电子版也能看下去（重点是边看边实践，旁边有笔电比纸质书更重要）。而对于非技术类书籍，除非是收藏的目的，否则我是不会带着厚厚的纸质书到处跑的。哦，对了，我用 iPad 看电子书，常用的 App 是多看和豆瓣阅读。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员：请不要丢失你的敬畏心</title>
    <url>/2016/12/09/show-your-respect/</url>
    <content><![CDATA[<center><b>暗</b></center>

<p>或许是因为整天抓着代码里的 Bug 从而锻就了能敏锐发现世界缺憾的能力，抑或是这个世界本来就充满着污秽与糟粕，大多数技术人员都普遍缺乏敬畏之心。</p>
<p>他们习惯性的高高在上俯瞰着众生的琐碎，从不懂得尊重其他人的劳动和创作；<br>他们在自己狭窄可怜的 comfort zone 里游刃有余，认为自己了解到就是全世界，而剩下的全是垃圾；<br>他们自以为是的对待自己所遇到的一切事物，以为看一眼书名就能通晓书中的精华，瞥一眼标题就能知道全文在讲些什么，瞅一眼角色的长相就能知道是好人还是坏人；<br>……</p>
<span id="more"></span>

<p>他们局限在自己固若金汤的生活里，选择性的忽视着他们不擅长的世界的 B 面，一边自得其乐的吐槽着世界的种种不完善，一边心满意足的看着综艺刷着微博写着不思进取的代码。</p>
<p>他们的宗旨是，自己最聪明，别人的产品都充满问题。他们觉得，对于自己了解的部分自己说的都是对的，对于自己不了解的部分根本没有存在的必要，不屑于去了解。无知成为了他们的一种幸福。</p>
<p>这样的人，永远心安理得的停留在原地，嘲笑着汗流浃背奔跑的人。</p>
<p>其实，他们不仅仅是技术工作着，他们可能是我们每一个人。<br><br /></p>
<center><b>明</b></center>

<p>国人的劣根性也好，人性的自然缺憾也罢，就跟古时候「文人相轻」的现象一样，技术工作者往往也有同源的类似的问题。想想永远活跃于各大社交网络的编程语言之争、技术范式之争、工具链之争等等就不难发现，很多技术工作者都真情实意的认为自己研究的东西最重要、自己写出的代码赏心悦目，而往往对别人的工作和自己尚不了解的领域充满偏见。</p>
<p>诚然，大多数技术工作者确实有着严谨的逻辑思维、强悍的学习能力、不畏艰难的卓绝品质，但也许正是这些表象的或者是世俗眼中的刻板印象，浇灌了技术工作者心里的自我满足感。</p>
<p>最近在看《人类简史》，作者在第十四章中明确指出近代欧洲文明正是在认识到自身的无知之后，才开始对未知的世界进行探索，从而一跃成为世界文明的中心。一个典型的现象是最初欧洲人所测绘的地图事无巨细、没有空白，认为自己所认知的世界就已经是全世界，而他们在探索到新大陆发现了自身的无知之后，地图测绘上开始学会了留白，坦诚的面对自己所还未曾涉足的地域。而同时代的近代中国却固步自封、骄傲自大，之后的故事大家都耳熟能详了。</p>
<p>就像读书的三境界一样，关于认知也有四重境界：</p>
<ol>
<li>You don’t know that you don’t know</li>
<li>You know that you don’t know</li>
<li>You know that you know</li>
<li>You don’t know that you know</li>
</ol>
<p>大多数人都只是在第一重境界，但这之中却有不少人误以为自己在第三境界。放下自己认知上的自我满足感，不断去探求新知，才只是从第一境界过渡到第二境界而已。</p>
<p>果粉熟知的乔布斯关于 “connect the dots” 的论断也有异曲同工之妙，你永远也不会知道现在你所了解到的看似无用的新事物会不会在未来的某个时刻成为组成你的伟大的不可或缺的重要的一部分。</p>
<p>所以，程序员，请不要丢失你的敬畏心，这个世界你不了解的事情不胜枚举。用开放的心态拥抱自己不了解的领域，你会无意中打开更多新世界的大门。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>敬畏之心</tag>
      </tags>
  </entry>
  <entry>
    <title>译文 | 为什么面向对象很糟糕</title>
    <url>/2017/02/09/why-oo-sucks/</url>
    <content><![CDATA[<blockquote>
<p>作者简介：Joe Armstrong，编程语言 Erlang 之父。<br>参考原文地址：<a href="http://harmful.cat-v.org/software/OO_programming/why_oo_sucks">Why OO Sucks by Joe Armstrong</a>。</p>
</blockquote>
<p>当我第一次接触到面向对象编程的概念时，我是持怀疑态度的，可是我并不知道这是为什么——我就是觉得哪里不大对。在面向对象编程的概念面世后，它很快变得非常流行（稍后我会解释这是为什么），而对它的批评之声就像是「教堂里的誓言」（译注：形容微不足道）。面向对象的特性变成了每个受人尊敬的编程语言都不得不拥有的东西。</p>
<p>在 Erlang 变得越来越流行的过程中，我们经常被人问：Erlang 是面向对象的吗？好吧，尽管正确的答案是「不，当然不是」，但我们并没有当面大声的说出来。我们发明了一系列独创的方式来回答这个问题，以便给人 Erlang 是（有几分）支持面向对象但又不真的是的印象。</p>
<span id="more"></span>

<p>此刻我想起了在巴黎第七届 IEEE 逻辑编程大会上， IBM （法国）的老板在演讲中向听众强调的事情。IBM 的 prolog 已经被加入了很多面向对象的扩展，当问起为什么时他回答说：</p>
<blockquote>
<p>我们的顾客想要面向对象的 prolog，所以我们创造了面向对象的 prolog。</p>
</blockquote>
<p>我始终记得如此简单的回答，没有良心不安，也没有灵魂拷问，更没有问一句：面向对象真的是正确的做法吗？</p>
<h2 id="为什么面向对象很糟糕"><a href="#为什么面向对象很糟糕" class="headerlink" title="为什么面向对象很糟糕"></a>为什么面向对象很糟糕</h2><p>对于面向对象，我主要的反对点要落实在相关的基础概念上，我将会列出这些概念和我反对的理由。</p>
<h3 id="反对点-1：数据结构和函数不应该被绑定在一起"><a href="#反对点-1：数据结构和函数不应该被绑定在一起" class="headerlink" title="反对点 1：数据结构和函数不应该被绑定在一起"></a>反对点 1：数据结构和函数不应该被绑定在一起</h3><p>对象在不可分割的微小单元里把函数和数据结构绑定在一起。我认为这是一个根本的错误，因为函数和数据结构完全属于不同的世界。为什么呢？</p>
<p>函数用来做事情，它们有输入和输出。输入和输出是数据结构，并且被函数所改动。在大部分编程语言里，函数由一系列指令组成：先做这个然后去做那个事情。为了理解函数，你必须理解事情被完成的顺序（在惰性函数式编程语言和逻辑语言里，这个限制没那么严格）。</p>
<p>数据结构就是数据结构，它们不做事情。它们本质上是声明式的。理解一个数据结构比理解一个函数要简单得多。</p>
<p>函数被视为转换输入成输出的黑匣子。如果我理解了输入和输出我就理解了这个函数，但这并不意味着我已经能够写出这个函数了。</p>
<p>函数通常通过观察来理解，它们是计算系统中的一部分，这个系统的工作就是把类型为 T1 的数据结构转换为类型为 T2 的数据结构。</p>
<p>因为函数和数据结构是完全不同的东西，所以把它们硬绑定在一起在根本上就是错误的。</p>
<h3 id="反对点-2：万物皆对象"><a href="#反对点-2：万物皆对象" class="headerlink" title="反对点 2：万物皆对象"></a>反对点 2：万物皆对象</h3><p>我们来考虑一下「时间」。在一门面向对象的语言里，「时间」必须是一个对象。但是在一个非面向对象的语言里，「时间」是一种数据类型的实例。例如，在 Erlang 里，有许多不同种类的时间，它们能够用类型声明来清清楚楚的定义出来，就像下面这样：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">-deftype day<span class="params">()</span> = 1..<span class="number">31</span>.</span><br><span class="line">-deftype month<span class="params">()</span> = 1..<span class="number">12</span>.</span><br><span class="line">-deftype year<span class="params">()</span> = int<span class="params">()</span>.</span><br><span class="line">-deftype hour<span class="params">()</span> = 1..<span class="number">24</span>.</span><br><span class="line">-deftype minute<span class="params">()</span> = 1..<span class="number">60</span>.</span><br><span class="line">-deftype second<span class="params">()</span> = 1..<span class="number">60</span>.</span><br><span class="line">-deftype abstime<span class="params">()</span> = &#123;abstime, year<span class="params">()</span>, month<span class="params">()</span>, day<span class="params">()</span>, hour<span class="params">()</span>, min<span class="params">()</span>, sec<span class="params">()</span>&#125;.</span><br><span class="line">-deftype hms<span class="params">()</span> = &#123;hms, hour<span class="params">()</span>, min<span class="params">()</span>, sec<span class="params">()</span>&#125;.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>注意这些定义不属于任何特定的对象。它们无处不在，并且用数据结构来表示的时间能够被系统中的任何函数操作。</p>
<p>这里没有与之相关联的那些方法。</p>
<h3 id="反对点-3：在一门面向对象的编程语言里，数据类型定义散落在各个地方"><a href="#反对点-3：在一门面向对象的编程语言里，数据类型定义散落在各个地方" class="headerlink" title="反对点 3：在一门面向对象的编程语言里，数据类型定义散落在各个地方"></a>反对点 3：在一门面向对象的编程语言里，数据类型定义散落在各个地方</h3><p>在一门面向对象的编程语言里，数据类型定义属于对象。所以我不能在某个地方找到所有的数据类型定义。在 Erlang 或者 C 里，我可以在一个简单的 include 文件或者数据字典里定义我的所有的数据类型。在面向对象语言里我不能这样做，数据类型定义散落在各个地方。</p>
<p>我来举个例子。假设我要定义一种无处不在的数据结构。「无处不在」指的是在系统的各个地方都有可能出现。</p>
<p>Lisp 程序员可能早已知道，相比于大量的数据类型和一小撮作用于它们的函数来说，定义一小部分无处不在的数据类型和大量作用于它们的函数会更好。</p>
<p>一种无处不在的数据结构是那种类似于链表、数组、哈希表或者时间、数据或文件名这样更高级的对象的东西。</p>
<p>在面向对象编程语言里，我不得不选择某个基础的对象去定义普遍存在的数据结构，所有其他想要使用这些数据结构的对象都必须继承这个基础对象。假设我现在想要创造某个「时间」对象，它应该属于哪里呢……</p>
<h3 id="反对点-4：对象有私有状态"><a href="#反对点-4：对象有私有状态" class="headerlink" title="反对点 4：对象有私有状态"></a>反对点 4：对象有私有状态</h3><p>状态是万恶之源。在特定的有副作用的函数里应该被避免。</p>
<p>虽然编程语言中的状态可以是不可获得的，但现实世界里的状态却十分之多。我对我银行账户的状态十分感兴趣，并且当我从中存入和取出一些钱的时候，我也希望我的银行账户的状态能够被正确地更新。</p>
<p>提出一个问题：在现实世界里存在的状态，一门编程语言应该提供什么工具来处理它们呢？</p>
<ul>
<li>面向对象编程语言说：从程序员那里隐藏这些状态。这些状态被隐藏并且只能通过特定的访问函数来获得。</li>
<li>传统的编程语言（比如 C，Pascal）说：状态变量的可见性由语言的作用域规则来控制。</li>
<li>纯粹的声明式语言说：这里没有状态一说。</li>
</ul>
<p>系统的全局状态从各个函数中进进出出。像单体结构（对于函数式编程语言）和分布式结构（对于逻辑语言）这样的机制被用来从程序员手中隐藏状态，这样他们就可以像「状态似乎不重要」一样来编程。不过，拥有对系统状态的全部访问权限是必要的。</p>
<p>面向对象编程语言选择「从程序员手中隐藏状态」是十分糟糕的选择。它们不但不展现状态和找到减少令人讨厌的状态的方法，反而把它们都藏了起来。</p>
<h2 id="为什么面向对象如此流行？"><a href="#为什么面向对象如此流行？" class="headerlink" title="为什么面向对象如此流行？"></a>为什么面向对象如此流行？</h2><ul>
<li>理由一：它被认为是容易学习的</li>
<li>理由二：它被认为可以使代码更易复用</li>
<li>理由三：是炒作</li>
<li>理由四：它创造了一个新的软件产业</li>
</ul>
<p>我没有明白理由一和理由二为什么成立。理由三和四似乎是技术背后的驱动力量。如果一门语言技术是如此糟糕但是它却创造了一个新的产业来解决它自己产生的问题，那对于很多想赚钱的人来说一定是个好主意。</p>
<p>这就是面向对象背后真正的驱动力量。</p>
<blockquote>
<p>译注：文章观点仅供参考，作者本人后来也说自己的观点或许有些不成熟。</p>
</blockquote>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>Erlang</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 慢查询优化</title>
    <url>/2017/03/08/mysql-run-faster/</url>
    <content><![CDATA[<p>在前一篇博客<a href="http://maples7.com/2017/03/03/express-run-faster/">《Express 性能调优》</a>中，我讲述了 Express 项目应该如何进行性能优化，但那些基本都只是官方文档上就已经明确指出的东西，也是对一个 Express 项目<strong>在性能上的基本要求</strong>。如果你已经足够仔细的阅读过文档，那么上一篇文章对你的收益几乎是 0。</p>
<p>除了规范所指出的基本要求，要优化一个 Web 项目的方法还有很多，比如合理的在后端给返回数据加缓存、充分利用浏览器的前端缓存、CDN，实在不行甚至需要「劳师动众」的部署多台机器做集群和负载均衡等等。这一篇博客的重点将放在数据库慢查询的优化上，这个话题对于 Web 项目而言更具有普适的意义。一方面它不局限于任何一种技术栈（当然这一篇以使用最普遍的 MySQL 为例），另一方面它更是直接在业务逻辑层面从代码本质上来优化你的项目性能，这往往也是单实例服务下性能的瓶颈所在。</p>
<span id="more"></span>

<p>实际上，这也是上一篇博客所讲的的同一个实践项目性能优化的深入。本来那个项目已经基本按文档规范进行了部署（<code>NODE_ENV</code> 的问题只是为了新版展示的临时修改），在那些方面能够对其进行优化的空间已经有限了，所以这个话题才是长期的项目维护实践中更有意义的部分。</p>
<h2 id="开启-MySQL-慢查询日志"><a href="#开启-MySQL-慢查询日志" class="headerlink" title="开启 MySQL 慢查询日志"></a>开启 MySQL 慢查询日志</h2><p>一个起步就不简单的原因是，我们如何才能定位到那些真正形成瓶颈的慢查询。一个普通项目中的 SQL 可能就有大几十甚至上百个，而「凶手们」就藏匿其中。</p>
<p>一个朴素的想法是在项目中每一个 SQL 执行前后打上时间戳来估计执行时间，暂且不论由于各种因素的影响这种估算可能不准确，更让人不可接受的是这对原始代码造成的极大的侵入。</p>
<p>好在 MySQL 提供了慢查询日志。这个日志会记录所有执行时间超过 <code>long_query_time</code>（默认是 10s）的 SQL 及相关的信息。</p>
<p>在 MySQL 的 Console 中：  </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;long_query_time&#x27;</span>;</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| Variable_name   | Value     |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">| long_query_time | 10.000000 |</span><br><span class="line">+-----------------+-----------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like <span class="string">&#x27;slow_query%&#x27;</span>;</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| Variable_name       | Value                                |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| slow_query_log      | OFF                                  |</span><br><span class="line">| slow_query_log_file | /var/log/mysql/log-slow-queries.log  |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span></span><br></pre></td></tr></table></figure>

<p>在这里，<code>slow_query_log</code> 指的是慢查询日志是否开启，<code>slow_query_log_file</code> 指明了日志所在的位置。</p>
<p>在 MySQL 的配置文件 my.cnf 的 <code>[mysqld]</code> 项下可以配置慢查询日志开启，一般来讲如下配置即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log=1</span><br><span class="line">slow_query_log_file=/var/log/mysql/log-slow-queries.log</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure>

<p>需要注意的是，应该赋予 <code>slow_query_log_file</code> 指向的目录 mysql 用户的写入权限：<code>chown mysql.mysql -R /var/log/mysql</code>，一般用默认的目录就好。详细的文档可以看这里：<a href="https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html">6.4.5 The Slow Query Log</a>。</p>
<p>之后需重载 MySQL 配置生效：<code>/etc/init.d/mysql reload</code>。</p>
<h2 id="分析慢查询日志"><a href="#分析慢查询日志" class="headerlink" title="分析慢查询日志"></a>分析慢查询日志</h2><p>在开启了 MySQL 慢查询日志一段时间之后，日志中就会把所有超过 <code>long_query_time</code> 的 SQL 记录下来。另一个有用的相关 MySQL 命令是 <code>mysqldumpslow</code>：由于慢查询日志可能很大或者很难分析，使用它可以获得 MySQL 对慢查询日志的一个总结报告，直接获得我们想要的统计分析后的结果。详细的文档可以看这里：<a href="https://dev.mysql.com/doc/refman/5.7/en/mysqldumpslow.html">5.6.8 mysqldumpslow — Summarize Slow Query Log Files</a>。</p>
<p>当然，你也可以打开日志文件自己来查询、分析。</p>
<h2 id="优化-SQL"><a href="#优化-SQL" class="headerlink" title="优化 SQL"></a>优化 SQL</h2><p>在得知哪些 SQL 是慢查询之后，我们就可以定位到具体的业务接口并针对性的进行优化了。</p>
<p>首先，你要看是否能在不改变现有业务逻辑的前提下改进查询的速度。一个典型的场景是，你需要查询数据库中是否存在符合某个条件的记录，返回一个布尔值来表示有或者没有，一般用于通知提醒。如果程序员在撰写接口时没把性能放在心上，那么他就有可能写出 <code>SELECT count(*) FROM tbl_xxx WHERE XXXX</code> 这样的查询，当数据量一大时（而且索引不恰当或没有索引）这个查询会相当之慢，但如果改成 <code>SELECT id FROM tbl_xxx WHERE XXXX LIMIT 1</code> 这样来查询，对速度的提升则是巨大的。这个例子并不是我凭空捏造的，最近在实际项目中我就看到了跟这个例子一模一样的场景。</p>
<p>能够找到上述的通过改变查询方式而又不改变业务逻辑的慢查询是幸运的，因为这些场景往往意味着只需重写 SQL 语句就能带来显著的性能提升，而且稍有经验的程序员在一开始就不会写出能够明显改良的查询语句。在绝大多数情况下，SQL 足够复杂而且难以做任何有价值的改动，这时就需要通过优化索引来提升效率了。</p>
<p>如何更好的创建数据库索引绝对是一门技术活，我也并不觉得简简单单就能厘得很清楚，很多时候还是得具体 SQL 具体分析，甚至多条 SQL 一起来分析。可以先读一读这篇美团点评技术团队的文章：<a href="http://tech.meituan.com/mysql-index.html">MySQL索引原理及慢查询优化</a>，更深入的了解则可以阅读<a href="https://book.douban.com/subject/23008813/">《高性能MySQL》</a>一书。引用一下美团点评技术团队文章中提到的几个原则：</p>
<blockquote>
<ol>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整；</li>
<li>&#x3D;和in可以乱序，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式；</li>
<li>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)&#x2F;count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录；</li>
<li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’);</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
</ol>
</blockquote>
<p>常用的套路是在定位到慢查询语句之后，使用 <code>EXPLAIN</code> + <code>SQL</code> 来了解 MySQL 在执行这条数据时的一些细节，比如是否进行了优化、是否使用了索引等等。基于 <code>Explain</code> 的返回结果我们就可以根据 MySQL 的执行细节进一步分析是否应该优化搜索、怎样优化索引。</p>
<p>就在这几天，美团技术团队开源了一款用于分析如何优化 SQL 的工具——<a href="https://github.com/Meituan-Dianping/SQLAdvisor">SQLAdvisor</a>，有兴趣可以试试。</p>
<p>优化索引也并不是万能的，这种情况下只能考虑通过其他方式来缓和性能上的瓶颈了。</p>
<blockquote>
<p>查询容易，优化不易，且写且珍惜！</p>
</blockquote>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Express 性能调优</title>
    <url>/2017/03/03/express-run-faster/</url>
    <content><![CDATA[<p>最近遇到了一个奇怪的事情，自己负责的一个项目的 RC（Release Condidate）版本突然在某一天打开时访问非常之慢，达到了完全不能接受的程度。奇怪的是，就在前一天，页面的访问速度至少是不会让人觉得不可接受的。更加奇怪的是，代码我完全没有改动过。</p>
<h2 id="NODE-ENV-production"><a href="#NODE-ENV-production" class="headerlink" title="NODE_ENV&#x3D;production"></a>NODE_ENV&#x3D;production</h2><p>在查找了一番资料之后，我在 <a href="http://expressjs.com/zh-cn/advanced/best-practice-performance.html">Express 官网上</a>发现了这样一段以前一直没有特别留意过的一段话：     </p>
<span id="more"></span>

<blockquote>
<p>NODE_ENV 环境变量指定运行应用程序的环境（通常是开发或者生产环境）。为了改进性能，最简单的方法是将 NODE_ENV 设置为“production”。     </p>
<p>将 NODE_ENV 设置为“production”会使 Express：</p>
<ul>
<li>高速缓存视图模板。</li>
<li>高速缓存从 CSS 扩展生成的 CSS 文件。</li>
<li>生成简短的错误消息。</li>
</ul>
<p>测试表明仅仅这样做就可以使应用程序性能提高 3 倍多！         </p>
</blockquote>
<p>遂顿悟！</p>
<p>事情是这样的，之前我们项目的 RC 版本都是使用的 production 作为环境变量，而且与正式发布的版本使用的是同样量级的数据大小，但最近我们项目有一个相对较大的版本更新，于是我为了配置一些特殊的变量供需求方能方便的检查效果和进一步评估改动，所以把 RC 版本所在服务器的 NODE_ENV 变量改成了其他值（为了适配另外的一套配置）。而测试环境下由于数据量非常小，所以根本察觉不到这个问题。</p>
<p>为了验证这个有文档说明来佐证的原因，我使用 ab（<a href="https://en.wikipedia.org/wiki/ApacheBench">ApacheBench</a>，一般用来做压力测试）进行了 A&#x2F;B 测试（<a href="https://en.wikipedia.org/wiki/A/B_testing">A&#x2F;B testing</a>，与前文的 ApacheBench 不是同一个概念）。</p>
<p>需要提前说明的是，为了尽可能排除网络环境的干扰，我是在内网环境下测试的，两次测试完全只有环境变量不同（也就是说里面的配置、所用的数据库、是否有缓存等都完全是一样的）。而且测试的是项目的一个主要接口，这个接口提供了页面的大部分数据，内部的业务逻辑也比较复杂，做的事情比较多。</p>
<p>测试结果如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># NODE_ENV=development</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">$ &gt;&gt; ab -c 10 -t 3 http://localhost:3000/XXXXX                                                     </span><br><span class="line"></span><br><span class="line">This is ApacheBench, Version 2.3 &lt;<span class="variable">$Revision</span>: 1706008 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking localhost (be patient)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:</span><br><span class="line">Server Hostname:        localhost</span><br><span class="line">Server Port:            3000</span><br><span class="line"></span><br><span class="line">Document Path:          XXXXX</span><br><span class="line">Document Length:        42477 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      10</span><br><span class="line">Time taken <span class="keyword">for</span> tests:   3.002 seconds</span><br><span class="line">Complete requests:      124</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      5467136 bytes</span><br><span class="line">HTML transferred:       5437056 bytes</span><br><span class="line">Requests per second:    41.31 [#/sec] (mean)</span><br><span class="line">Time per request:       242.097 [ms] (mean)</span><br><span class="line">Time per request:       24.210 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          1778.48 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.3      0       1</span><br><span class="line">Processing:   191  231  20.2    230     300</span><br><span class="line">Waiting:      191  230  20.0    229     296</span><br><span class="line">Total:        191  232  20.2    230     300</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain <span class="keyword">time</span> (ms)</span><br><span class="line">  50%    230</span><br><span class="line">  66%    234</span><br><span class="line">  75%    235</span><br><span class="line">  80%    238</span><br><span class="line">  90%    246</span><br><span class="line">  95%    285</span><br><span class="line">  98%    294</span><br><span class="line">  99%    298</span><br><span class="line"> 100%    300 (longest request)</span><br><span class="line">Finished 124 requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line"><span class="comment"># NODE_ENV=production</span></span><br><span class="line"><span class="comment"># ======================================================</span></span><br><span class="line">$ &gt;&gt; ab -c 10 -t 3 http://localhost:3000/XXXXX                                                     </span><br><span class="line"></span><br><span class="line">This is ApacheBench, Version 2.3 &lt;<span class="variable">$Revision</span>: 1706008 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking localhost (be patient)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:</span><br><span class="line">Server Hostname:        localhost</span><br><span class="line">Server Port:            3000</span><br><span class="line"></span><br><span class="line">Document Path:          XXXXX</span><br><span class="line">Document Length:        42477 bytes</span><br><span class="line"></span><br><span class="line">Concurrency Level:      10</span><br><span class="line">Time taken <span class="keyword">for</span> tests:   3.006 seconds</span><br><span class="line">Complete requests:      209</span><br><span class="line">Failed requests:        0</span><br><span class="line">Total transferred:      8926808 bytes</span><br><span class="line">HTML transferred:       8877693 bytes</span><br><span class="line">Requests per second:    69.53 [#/sec] (mean)</span><br><span class="line">Time per request:       143.828 [ms] (mean)</span><br><span class="line">Time per request:       14.383 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          2900.06 [Kbytes/sec] received</span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    0   0.3      0       1</span><br><span class="line">Processing:   113  142  17.5    137     189</span><br><span class="line">Waiting:      112  141  17.5    137     188</span><br><span class="line">Total:        114  142  17.5    137     189</span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain <span class="keyword">time</span> (ms)</span><br><span class="line">  50%    137</span><br><span class="line">  66%    143</span><br><span class="line">  75%    156</span><br><span class="line">  80%    160</span><br><span class="line">  90%    168</span><br><span class="line">  95%    179</span><br><span class="line">  98%    183</span><br><span class="line">  99%    185</span><br><span class="line"> 100%    189 (longest request)</span><br><span class="line">Finished 209 requests</span><br></pre></td></tr></table></figure>

<p>可以看见，对比 QPS（或 RPS，Requests per second），<code>development:production = 41.31:69.53 [#/sec] (mean)</code>；对比平均用户请求等待时间（Time per request），<code>development:production = 242.097:143.828 [ms] (mean)</code>。基本上单个请求快了 100 ms 左右。</p>
<p>虽然没有官网上说的「3 倍」那么夸张，不过按文档上说还会「高速缓存视图模板」和「高速缓存从 CSS 扩展生成的 CSS 文件」，而我测试的是一个纯 API 接口，只返回 JSON 数据，所以理论上 HTML 页面打开的速度的对比应该会更加明显（之后也测试了这种情况，速度要快 1&#x2F;3 左右）。</p>
<h2 id="其他-Express-性能调优技巧"><a href="#其他-Express-性能调优技巧" class="headerlink" title="其他 Express 性能调优技巧"></a>其他 Express 性能调优技巧</h2><p>总结一下官网上所说的关于性能调优的基本还有以下几条：</p>
<ul>
<li><strong>使用 gzip 压缩响应</strong>：用 <a href="https://www.npmjs.com/package/compression">compression</a> 中间件；</li>
<li><strong>代码中不使用同步函数</strong>：项目启动时可以一次性使用同步函数进行一些有时序性的操作（比如加载路由），但在之后的长期运行过程中，具体对外的接口执行流程中不应该存在同步函数；</li>
<li><strong>正确进行日志记录</strong>：不要简单的用 <code>console</code>（都是同步函数）或自己写文件操作，直接用成熟的日志包（如 Winston、Bunyan、log4js 等），必要的情况下可能还需要使用消息队列；</li>
<li><strong>使用进程管理器</strong>：除了提高应用的可用性之外，还可以根据 CPU 核心数生成相应的应用实例，充分利用 Node.js 的优势压榨 CPU 的资源，常用的有 StrongLoop Process Manager、PM2、Forever；</li>
<li><strong>使用反向代理</strong>：直接用 Nginx 做反向代理吧，一方面可以做 CDN 缓存静态资源，另一方面还能够利用它做简单的负载均衡。不过需要注意的几点是：<ul>
<li>多实例下「粘性会话」需要把状态存储在第三方高速介质中，一般用 Redis 就好；或者，采用 JWT 鉴权方案实现接口无状态（更推荐，同时为了安全站点一定要强制使用 HTTPS）；</li>
<li>Nginx 做反向代理时不应该将其与应用放在同一台主机上，原因可以看这里：<a href="https://www.zhihu.com/question/19761434">Nginx 反向代理为什么可以提高网站性能？</a></li>
</ul>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://expressjs.com/zh-cn/advanced/best-practice-performance.html">生产环境最佳实践：性能和可靠性 - Express 官方文档</a></li>
<li><a href="https://www.zhihu.com/question/19761434">Nginx 反向代理为什么可以提高网站性能？</a></li>
</ul>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>译文 | 入门概念：CSS 选择器是如何工作的</title>
    <url>/2017/03/13/how-css-selectors-work/</url>
    <content><![CDATA[<blockquote>
<p>作者：<a href="https://twitter.com/chriscoyier">Chris Coyier</a><br>参考原文地址：<a href="https://css-tricks.com/how-css-selectors-work/">Beginner Concepts: How CSS Selectors Work</a>。</p>
</blockquote>
<p>你刚接触 CSS 吗？这篇文章就是为你准备的！也许理解 CSS 最关键的就是理解「选择器」。选择器可以让你定位到具体的 HTML 元素并且把样式应用于它们之上。不过现在让我们暂时忘掉「样式」，而只是专注于「选择」。</p>
<p>在接下来的例子中，CSS 将会存在于一个被命名为 <code>style.css</code> 的文件中，并且被叫做 <code>index.html</code> 的 HTML 文档所引用。HTML 与 CSS 是分离的，这样能将「设计」与「内容」分离，这也是 CSS 出彩的地方。</p>
<span id="more"></span>

<p>HTML 文件看起来会像是这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>We&#x27;re learning selectors!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;yay&quot;</span>&gt;</span>Yay<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 文件则只会包含选择器的代码区块，就像你接下来会看到的一样。</p>
<h2 id="ID-选择器（ID-Selector）"><a href="#ID-选择器（ID-Selector）" class="headerlink" title="ID 选择器（ID Selector）"></a>ID 选择器（ID Selector）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#happy-cake</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;happy-cake&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">id</span>=<span class="string">&quot;happy-cake&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sad-cake&quot;</span>&gt;</span>Wrong ID!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;happy-cake&quot;</span>&gt;</span>That&#x27;s not an ID!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>根据 <a href="https://css-tricks.com/specifics-on-css-specificity/">CSS 选择器优先级（CSS specificity）</a>，ID 选择器是优先级最高的选择器类型。这意味着它「打败」了其他的选择器类型和「以胜者姿态」而定义的样式。听起来很棒，但是那也是<a href="https://css-tricks.com/a-line-in-the-sand/">被诟病的地方</a>，因为在我们需要的时候，使用那些低优先级的选择器会更容易重载值。</p>
<h2 id="类选择器（Class-Selector）"><a href="#类选择器（Class-Selector）" class="headerlink" title="类选择器（Class Selector）"></a>类选择器（Class Selector）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.module</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&quot;country module iceland&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;.module&quot;</span>&gt;</span>The dot is for CSS, not HTML<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bigmodule&quot;</span>&gt;</span>Wrong class<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>类选择器是你的朋友。它们很可能是这里最有用和最全能的选择器。其一，是因为它们在所有浏览器中都得到了很好的支持；其二，你还可以在 HTML 元素中添加多个「类」（class）（只需要用一个空格分开）；其三，你可以用 JavaScript 来明确地的操作类。</p>
<h2 id="元素选择器（Tag-Selector）"><a href="#元素选择器（Tag-Selector）" class="headerlink" title="元素选择器（Tag Selector）"></a>元素选择器（Tag Selector）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hi, Mom<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Anywhere<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;h2&quot;</span>&gt;</span>Wrong tag, can&#x27;t trick it<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line">&lt;h2class=&quot;yolo&quot;&gt;Make sure that tag has a space after it!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当改变某个独一无二的 HTML 元素的属性时，元素选择器是最有用的，比如在 <code>&lt;ul&gt;</code> 上设置 <code>list-style</code> 或是在 <code>&lt;pre&gt;</code> 上设置 <code>tab-size</code>。同理，在<a href="https://css-tricks.com/poll-results-what-css-reset-do-you-use/">重新设定</a>某个元素的浏览器默认样式时也很有用。</p>
<p>但不要太过于依赖它们。通常来说，写一个类来定义样式可以作用于任何 HTML 元素，这会更有用。</p>
<h2 id="属性选择器（Attribute-Selector）"><a href="#属性选择器（Attribute-Selector）" class="headerlink" title="属性选择器（Attribute Selector）"></a>属性选择器（Attribute Selector）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[data-modal=<span class="string">&quot;open&quot;</span>]</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-modal</span>=<span class="string">&quot;open&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">&#x27;closed&#x27;</span> <span class="attr">data-modal</span>=<span class="string">&#x27;open&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-modal</span>=<span class="string">&quot;false&quot;</span>&gt;</span>Wrong value<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-modal</span>&gt;</span>No value<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-modal-open</span>&gt;</span>Wrong attribute<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可能会争论说<a href="https://css-tricks.com/attribute-selectors/">属性选择器</a>比类选择器更有用，因为它们有一样的优先级但是前者却可以是任何属性（不仅仅是 <code>class</code>），这个属性的值你还可以进行选择。</p>
<p>你说得没错，但是属性选择器 IE6 不支持。</p>
<h2 id="位置选择器（Positional-Selectors）"><a href="#位置选择器（Positional-Selectors）" class="headerlink" title="位置选择器（Positional Selectors）"></a>位置选择器（Positional Selectors）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>nope<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>yep, I&#x27;m #2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>nope<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了 <a href="https://css-tricks.com/how-nth-child-works/"><code>:nth-child</code></a>，还有几种不同的位置选择器。使用简单的表达式（比如 <code>3n</code>&#x3D;”every third”），你可以基于它们在 HTML 中的位置来选择元素。你可以<a href="https://css-tricks.com/examples/nth-child-tester/">在这里测试你的想法</a>或者<a href="https://css-tricks.com/useful-nth-child-recipies/">在这里了解更多的实例</a>。</p>
<h2 id="其他的伪选择器（Pseudo-Selectors）"><a href="#其他的伪选择器（Pseudo-Selectors）" class="headerlink" title="其他的伪选择器（Pseudo Selectors）"></a>其他的伪选择器（Pseudo Selectors）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:empty</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- WILL match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span> <span class="attr">data-blah</span>&gt;</span><span class="comment">&lt;!-- nothin&#x27; --&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Will NOT match --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>:empty</code> 是<a href="https://css-tricks.com/pseudo-class-selectors/">众多伪选择器</a>中的一个，你可以凭借冒号 <code>:</code> 来识别它们。它们通常代表着你不能仅仅通过元素和属性就能定位到的东西。</p>
<p>请注意，它们与用双冒号（<code>::</code>）来识别的<a href="http://css-tricks.com/pseudo-element-roundup/">伪元素（pseudo elements）</a>有一点不同。伪元素负责借助它们选择的内容来往页面添加东西。</p>
<h2 id="更多提升内容"><a href="#更多提升内容" class="headerlink" title="更多提升内容"></a>更多提升内容</h2><p>选择器可以被组合到一起使用。比如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.module</span><span class="selector-class">.news</span> &#123;  </span><br><span class="line">  <span class="comment">/* Selects elements with BOTH of those classes */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#site-footer</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="comment">/* Adds content after an element with that ID */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span><span class="selector-attr">[data-open]</span> &#123;</span><br><span class="line">  <span class="comment">/* Selects only section elements if they have this attribute */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也有像 <code>~</code>、<code>+</code> 和 <code>&gt;</code> 这样的<a href="https://css-tricks.com/child-and-sibling-selectors/">选择器组合运算子（selector combinators）</a>可以用来对选择器造成影响，就像这样：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.module</span> &gt; <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="comment">/* Select h2 elements that are direct children of an element with that class */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">h2</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="comment">/* Select p elements that are directly following an h2 element */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span> ~ <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="comment">/* Select li elements that are siblings (and following) another li element. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 CSS-Tricks，这里有<a href="https://css-tricks.com/almanac/">一个完整的索引</a>，覆盖了 CSS 中的所有的选择器及其属性。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Koa2 源码赏析</title>
    <url>/2017/04/09/koa2-src/</url>
    <content><![CDATA[<p>随着 Node 新版本开始支持 async&#x2F;await 异步控制写法，Koa 也相继发布了它的 2.0 版本。用 async&#x2F;await 写法的 Koa 来开发项目，Node 开发者再也没有任何理由不「拥抱变化」——从 Express 转到 Koa 上来。实际上，对于普通 Node 开发者——Express 框架的用户——而言，从 Express 转到 Koa 没有任何技术壁垒，当然前提是你至少得知道 ES2017 中 async&#x2F;await 是个什么东西。</p>
<img data-src="https://i.loli.net/2018/08/06/5b6731c4b534a.png" class="" title="Koa——next generation web framework for node.js" alt="图片显示错误">

<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有了 Express 的积累，以 <a href="https://github.com/tj">TJ</a> 为首的 Express 开发团队对于 Koa 的设计也更加的得心应手、游刃有余。从源代码来看，Koa 看起来甚至比 Express 更加简洁和灵活，然而在功能上却丝毫没有让步，甚至更胜一筹。一方面，这得益于 JavaScript 越来越方便好用的各种「语法糖」；另一方面，也在于 Koa 本身简洁强大的设计：它不再绑定任何特定的中间件，也去掉了其他任何多余的设计（连路由系统都抽象成了第三方中间件），而只是简单的提供了一个优雅管理各种中间件的约束系统，用户的所有挂载都是中间件。</p>
<p>TJ 大神的代码一向简洁强大，Koa 的源码也是如此。如果你<a href="https://github.com/koajs/koa">去 GitHub 上查看 Koa 的源码</a>，你同样会被其简洁所震撼，核心代码不过 4 个文件，平均每个文件代码行数也就四百来行，看似简简单单，却天才般的把 Express 线性的中间件控制流转变为「洋葱体」结构，从而解锁了更多的姿势和玩法。本文就直接深入 Koa 的源码（v2.2.0），来欣赏 Koa 的曼妙身姿。</p>
<h2 id="代码大体结构"><a href="#代码大体结构" class="headerlink" title="代码大体结构"></a>代码大体结构</h2><p>lib 目录下总共就四个文件：<code>application.js</code>、<code>context.js</code>、<code>request.js</code> 和 <code>response.js</code>。入口文件是 <code>application.js</code>，导出的是一个继承了 Node 内建模块 Events 的 Class，构造函数中进行了必要的参数初始化，并且把 <code>context</code>、<code>request</code> 和 <code>response</code> 属性指向了原型链指向其他三个文件导出对象的实例。</p>
<p>然后是类方法，主要的几个 public 的方法如下：</p>
<ul>
<li><code>listen</code>：一个简单的对 <code>http.createServer(this.callback()).listen(...)</code> 的封装。</li>
<li><code>callback</code>：在 <code>listen</code> 中有调用，返回一个用于 <code>http.createServer</code> 的回调函数 <code>handleRequest</code>，在这个函数中创建了主角 <code>ctx</code>，并做了一些原型链继承和 aliases。<strong>更重要的是</strong>，<a href="https://github.com/koajs/compose/blob/master/index.js">调用的 <code>koa-compose</code> 返回了一个 <code>fn</code> 函数，负责了整个中间件「洋葱体」流程的实现和控制</a>。在所有中间件执行完之后，做了一些返回之前的琐碎诸如设置必要的返回头等的工作。</li>
<li><code>use</code>：把中间件参数放入 <code>this.middleware</code> 数组，并返回 <code>this</code> 以便链式调用。</li>
</ul>
<p>结合 Koa 文档和 <code>application.js</code>，基本就可以对整个框架的处理流程有个整体的把握了。其中最主要的部分还是 <code>callback</code> 函数中的内容，看完之后对整个基于 Node HTTP 模块封装的中间件处理的流转过程都清楚了。</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>这里是对 <code>this.context</code> 的原型对象的实现。</p>
<p>没有太多值得一提的东西，基本是对上下文对象 <code>ctx</code> 提供几个必需的原型接口以及一个缺省的错误处理函数 <code>onerror</code>。有意思的是，利用 <code>delegates</code> 包，把对 app 的一些属性的访问直接对应的代理到 <code>response</code> 和 <code>request</code> 上，这也就是<a href="http://koajs.com/#request-aliases">文档上所说的 <code>Request aliases</code> 和 <code>Response aliases</code> 的具体原因</a>。</p>
<h2 id="Request-Response"><a href="#Request-Response" class="headerlink" title="Request &amp; Response"></a>Request &amp; Response</h2><p>这俩文件是对 <code>this.request</code> 和 <code>this.response</code> 的原型对象的实现。</p>
<p><code>this.request</code> 和 <code>this.response</code> 中都有大量属性的 getter 和 setter 方法，这些可用的属性在 Koa 文档中都已经列出，代码在这里对它们的读写操作进行了实现。这些属性基本是对 Node HTTP 包中 req 和 res 属性的封装。</p>
<h2 id="「洋葱体」带来了什么"><a href="#「洋葱体」带来了什么" class="headerlink" title="「洋葱体」带来了什么"></a>「洋葱体」带来了什么</h2><p>你固然还是可以像在 Express 中一样把 <code>next();</code> 都放在每个中间件的末尾来线性的传递控制权，但「回形针」式的控制流带来了更多的可能。一个最典型的的例子就是 <code>response-time</code> 中间件的实现。</p>
<p>在 GitHub 上用 <code>response-time</code> 关键字搜索，前两个 Repo 就分别是 Express 和 Koa 中对这个中间件的实现。</p>
<p>Express 中的实现其实是 hack 了被 Express 用到的 Node.js 内部 HTTP 模块的 <code>res.writeHead</code> 方法（实际实现细节在 <code>response-time</code> 中间件调用的 <code>on-headers</code> 包中），使得在这一层注入了一小段代码用于在数据返回前计算时间差并写入 Response Headers。这样虽然可以实现，但显然不够好。它 hack 了框架底层的一个内部方法，虽然也巧妙，但代码本身并不是在给它天生就安排好的合适的地方来实现的，可以视为晦涩的「奇技淫巧」，而且与 Express 的内部实现强耦合，指不定哪天 Express 改了 <code>res.writeHead</code> 调用时机，这个中间件的返回值可能就有所不同了（当然按实际情况来说 Express 此处应该也不会改了，而且 Express 的 <code>response-time</code> 最初也是 TJ 写的）。</p>
<p>Koa 的 <code>response-time</code> 实现自不必多说，官方文档上就有，来欣赏它的简洁优雅：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> <span class="keyword">function</span>(<span class="params">ctx, next</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="keyword">new</span> <span class="title class_">Date</span>() - start;</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&#x27;X-Response-Time&#x27;</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>总结来说，Koa 的「洋葱体」结构使得<strong>每个中间件能够在同一次请求的前后对称的部分提供相同的上下文环境</strong>，这样就让实现像 <code>response-time</code> 这样的中间件变得相当简单。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/26063036">编写可维护代码之“中间件模式”</a></li>
</ul>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title>印象青岛</title>
    <url>/2017/03/14/qingdao/</url>
    <content><![CDATA[<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b673241202ea.jpg"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b6732410961d.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b6732411fb6a.jpg"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b673241122ee.jpg"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b67324124390.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b673241310f1.jpg"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b67324137461.jpg"></div></div></div>

<span id="more"></span>

<br />

<p>图片已经过裁剪与压缩，原图在这里：<a href="https://maples7.tuchong.com/12595727/">https://maples7.tuchong.com/12595727/</a></p>
]]></content>
      <categories>
        <category>视觉动物</category>
      </categories>
      <tags>
        <tag>Sony DSC-RX100</tag>
        <tag>城市</tag>
        <tag>风光</tag>
      </tags>
  </entry>
  <entry>
    <title>程序与人生</title>
    <url>/2017/05/24/programming-and-life/</url>
    <content><![CDATA[<p>最近趁着离职的一点空隙，稍微能有些时间和心情来思考一些更有深度和更长远的问题，这篇文章的内容算是我近期开的小小脑洞之一。</p>
<p>越来越发现，前人总结的一些众所周知并经过时间验证过的关于写代码的道理，只要我们换个角度来类比和思考，同样可以适用于我们人生历程的一些方面。这篇文章就是我想到的一些例子，小标题都是写代码时所谓的一些「金科玉律」，而我会试图通过这些相通的「规律」，衍生出个人对人生某个方面的思考，可能小到微不足道的个人习惯，大到能够决定人生方向的人生观。</p>
<span id="more"></span>

<h2 id="做好垃圾回收"><a href="#做好垃圾回收" class="headerlink" title="做好垃圾回收"></a>做好垃圾回收</h2><p>任何使用 C&#x2F;C++ 写代码的程序员都会在编码时尤其注意一个问题，那就是及时进行垃圾回收。具体来说，由于 C&#x2F;C++ 本身不具有自动垃圾回收的机制，所以但凡程序向操作系统「借用」了一块内存来存放新生成的对象，都必须在对应对象的生命期结束之后的某个时刻主动的进行内存释放，即手动进行垃圾回收。如果没有进行合适的垃圾回收，则系统会陷入了我们常说的「内存泄漏」的问题——由于无用的内存得不到及时的释放，导致程序占用的内存越来越多，最后导致内存不足而整个系统无法正常运行。</p>
<p>一个合格的 C&#x2F;C++ 程序员会把主动进行垃圾回收的习惯带到生活中，小到随手关灯、随手关门、把用过的会议室恢复原样，中到把借来的东西物归原主，甚至大到整个人类对发展过程中对生态环境破坏的及时弥补，其内在其实都是自然的「垃圾回收」原则。</p>
<h2 id="永远不忘把错误默默吞掉"><a href="#永远不忘把错误默默吞掉" class="headerlink" title="永远不忘把错误默默吞掉"></a>永远不忘把错误默默吞掉</h2><p><em>“Errors should never pass silently”</em> 是<a href="https://en.wikipedia.org/wiki/Zen_of_Python">《The Zen of Python》</a>中重要的一条，它告诉我们永远不要忽视代码中的「异常」（Exception）。无论你是像目前大多数语言或框架所设计的把「异常」向上「抛」到一个足够高的层次然后统一记录日志并做处理然后程序继续运行，还是像 Erlang 那样崇尚 <em>let it crash</em> 的思想把所有被「异常」所「感染」到的轻量级 Process 全部挂掉，其相同的基点都是不能把异常默默的忽视掉。</p>
<p>其内在的逻辑在于，我们绝不能忽视系统中的任何一个错误，把问题暴露出来总是比隐藏问题要更好。任何一个不加处理和纠正的错误，对于有状态的系统而言，可能导致系统处于一个完全失常的状态，其行为得不到有效的控制；对于无状态的系统而言，则可能使得任何触发了这个错误的用户请求都产生错误的结果和返回，即便不直接把 Process 挂掉，也至少把错误捕捉到且记录日志并视问题严重程度适当进行告警，否则问题将永远得不到解决。</p>
<p>生活中其实也是如此。当我们遇到问题时，人的本能反应都是逃避的，但逃避永远解决不了我们遇到的问题。选择直面问题和困难是强者和自信者的逻辑和选择，人生也只有在不断的打怪升级中进阶成为更好的自己。具体来说，学习时遇到难点要想办法去弄懂原理，人际交往中遇到误会要及时沟通，工作时遇到阻碍要直面解决等等。</p>
<h2 id="分工明确，关注点分离"><a href="#分工明确，关注点分离" class="headerlink" title="分工明确，关注点分离"></a>分工明确，关注点分离</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">SoC（Separation of Concerns）</a>是面向对象程序设计的核心概念之一，它强调把业务逻辑的代码与解决特定领域问题的代码分离，这样才能使得代码具有「高内聚，低耦合，分层明确」的特点，也就是使得日后由于需求变动带来的维护修改能够以尽可能小的影响面来进行。其实 Erlang 的 actor 并发模型设计对此也有所体现，整个系统任务被拆分成一个个不同的小任务，被大量的轻量级 Work Process 来执行，而 Process 之间唯一的交互方式是通过 messages（这就是好比各个子系统通过 API 来进行黑盒交互），这样的并发模型就完全避免了传统的共享内存式并发的 data race、死锁等固有问题。</p>
<p>人类社会整个就是一个分工明确的动态系统，不同人一定会有不同的专长和兴趣，在走向社会之后也一定会或主动或被动的走到合适自己的岗位上去。而整个人类社会系统是不断动态发展的，正是由于明确的分工机制，客观世界的某个具体的变化不必需要人类全体都进行调整来适应，这样人类社会总体上才得以能够勉力跟上客观世界变化的速度。其实道理很简单，就拿最近影响面极广的 WannaCry 勒索病毒事件来说，即便微软早在两三月前就已经推送了补丁修复漏洞，但由于需要调整的用户数量太大（即便假设所有用户对系统更新都持开放态度），所以肯定还是会有大量来不及进行调整的用户中招。更明确的说，个体数量越多，则所有个体都从当前状态调整到另一个确定状态所遇到的阻力就越大。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实如果有心，还可以发现很多沉淀下来的技术「准则」都可以有更哲学更生活化的解读和理解，也欢迎留言提供你的「新发现」。</p>
<p>程序与人生，不仅仅是写程序的人生，更是透着程序思想哲思的人生。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title>如何系统地学习一门编程语言？</title>
    <url>/2017/07/13/comprehensively-learn-a-new-programming-lauguage/</url>
    <content><![CDATA[<p>「学习一门新的编程语言」是每个程序员都必然会面对的一个课题（注：本文特指工程实践中常用的高级编程语言）。自从高一开始编程到现在，我也接触了不少的编程语言，有的语言已经能在工作中得心应手的使用；有的语言用的不多，但大概了解其设计，也能在官方文档的帮助下简单使用；还有的则之前很了解，但很长时间没有使用过了。</p>
<p>换一份新的工作是最有机会让程序员接触到新的东西的，最近我就应工作需求开始接触一门新的编程语言，学习过程中难免会和已经熟悉的编程语言进行对比，然后发现其实编程语言的学习完全是有「套路」可循的，这篇博客试图总结一下这种「套路」。</p>
<span id="more"></span>

<p>总的来说，编程语言各种各样的特性共同决定了这门语言，这样的特性可能大到并发模型的设计，小到某个具体的语法特性。学习一门编程语言的过程就是不断了解这些语言特性并进行实践应用以及工程化使用的过程。系统性地把语言的主要特性明确清楚，可以快速地建立对一门语言的基本认识，并能做到胸有成竹地深入和细化。</p>
<p>下面就一一说明学习一门新的编程语言至少需要明确的语言特性有哪些，供参考。</p>
<h3 id="编译型-or-解释型"><a href="#编译型-or-解释型" class="headerlink" title="编译型 or 解释型"></a>编译型 or 解释型</h3><p>如今一门语言是编译型语言还是解释型语言似乎对工程开发的影响越来越小（而且大有相互靠拢之势，界限也变得越来越不清晰），这或多或少得益于各种编辑器和 IDE 对于中间过程的自动化处理。不过，明确一门编程语言是编译型还是解释型依然是基础且非常有必要的，这对于理解一些程序的深层行为逻辑会很有帮助。</p>
<p>其实对于语言设计者来说，编译型和解释型从根本上是语言开发自由度和性能优化能力之间的博弈。</p>
<h3 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h3><p>基本地，需要了解该语言都原生支持哪些数据类型，而其中哪些是简单／基础类型，哪些又是复杂／复合类型，各个类型之间又有哪些区别等等。</p>
<p>更抽象来看，类型系统又可以从两个维度来定义：</p>
<ul>
<li>强类型 or 弱类型：核心的区别在于语言<strong>是否偏向于容忍隐式的类型转换</strong>。一个常见的错误理解是「C&#x2F;C++ 是强类型语言」，实际上，在 C&#x2F;C++ 中隐式类型转换很常见，它们是弱类型语言。与之相对的，Python 则是强类型语言。</li>
<li>动态类型 or 静态类型：核心区别在于<strong>是否在编译时就能明确每一个变量的类型</strong>。对于静态类型来说，如果编译时存在类型错误，是无法编译通过的，而对于动态类型来说，由于程序运行时才能明确类型，所以类型错误通常不会导致编译出错（错误会在运行时暴露出来）。Python 就是动态类型，而 C&#x2F;C++ 则是静态类型。</li>
</ul>
<h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><p>如今的高级语言基本都会有成熟的模块系统，好的模块系统对于构建大型工程项目来说必不可少，它可以大大提高程序的可复用能力和模块化能力。</p>
<p>了解一门编程语言的模块系统大概至少需要了解这些细节：</p>
<ul>
<li>依赖的路径是如何解析的？</li>
<li>如何引用自定义模块（文件）？</li>
<li>如何引用第三方的模块或包？</li>
</ul>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>与模块系统相关的一个很影响实际开发的问题是「变量的作用域（scope）是怎样的」。常见的可以自己问的问题是：</p>
<ul>
<li>什么情况下是全局作用域？</li>
<li>什么时候又会是函数作用域？</li>
<li>块作用域又是怎样的？</li>
</ul>
<p>不过，不同的语言对于作用域的定义和分类可能不同，需要具体情况具体了解。</p>
<p>另外，明确语言是「动态作用域」还是「静态（词法）作用域」也非常重要：与动态类型和静态类型的区别类似，静态作用域是在<strong>书写代码</strong>或者说定义时确定的，而动态作用域是在<strong>运行时</strong>确定的。静态作用域关注函数在<strong>何处声明</strong>，而动态作用域关注函数从<strong>何处调用</strong>，其作用域链是基于运行时的调用栈的。可以看看<a href="https://www.zhihu.com/question/20032419/answer/112564460">这个例子</a>做进一步的区分。</p>
<h3 id="支持的编程范式与特色"><a href="#支持的编程范式与特色" class="headerlink" title="支持的编程范式与特色"></a>支持的编程范式与特色</h3><p>编程语言支持哪样的编程范式对于工程项目也非常重要，这也基本和语言设计上的一些别具一格不那么常见的特色相关。比如函数式编程中的「函数是一等公民」、面向对象中的「封装、继承和多态」对应到编程语言上应该如何具体实现、面向并行的语言又是如何实现并发的等等。</p>
<p>了解了这些特色你才能更清楚这门语言在工程中更擅长做哪样的事情，更适合哪些项目。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>基础的你需要了解基本的语法规则和特性，比如分支、循环、函数等等。更深入一些的时候则可以了解一下语言的架构设计、那些语言特性为什么会这样设计以及它们都是如何被实现的。了解实现不一定非得去看源码，搞清楚语言大体上的实现过程还是比较简单的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，把前文的部分<a href="https://www.processon.com/chart_image/595f2e79e4b0a77c5aeb50d7.png">总结成一张思维导图</a>，希望能够让开始学习新编程语言的过程更清晰快速。</p>
<img data-src="https://i.loli.net/2018/08/06/5b6731fe12be8.png" />
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>程序员</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业一周年 | 山大印象</title>
    <url>/2017/05/07/grad-anniversary/</url>
    <content><![CDATA[<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b6730d2d2f42.jpg"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b6730d352fa4.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b6730d370941.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b6730d33957c.jpg"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b6730d363eec.jpg"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2018/08/06/5b6730d371069.jpg"></div></div></div>

<span id="more"></span>

<br />

<p>图片已经过裁剪与压缩，原图在这里：<a href="https://maples7.tuchong.com/13114728/">https://maples7.tuchong.com/13114728/</a></p>
]]></content>
      <categories>
        <category>视觉动物</category>
      </categories>
      <tags>
        <tag>Sony DSC-RX100</tag>
        <tag>山东大学</tag>
      </tags>
  </entry>
  <entry>
    <title>了不起的 Erlang</title>
    <url>/2017/06/10/awesome-erlang/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
<p><em>Shared mutable state is the root of all evil</em><br><em>共享的可变状态是万恶之源</em></p>
<p><strong>Pete Hunt</strong>      </p>

</blockquote>

<p>大概是从去年年底开始，我开始断断续续地了解 Erlang 这门语言。之所以会想要去学习它，是因为它跟我已经比较熟悉的任何一门语言都有着截然不同的设计理念，而且我了解得越深，就越为其设计思想所折服。</p>
<p>虽然这门语言的年纪早已不算年轻，而且似乎从未「大众流行」过，但在如今 CPU 多核化和云计算的时代背景下，Erlang 却焕发出了不一样的生机。</p>
<span id="more"></span>

<p>Erlang 在构建高可用服务上有其独特的优势，这与 Web 服务的要求不谋而合，其设计理念值得每一名 Web 后端开发工程师去了解。</p>
<p>在介绍 Erlang 的几个核心概念之前，需要先说明的是，本文所指的 Erlang 不仅仅指这门语言本身，而是指整个构建于 Erlang 虚拟机之上的技术体系，这就至少包括了 Erlang 语言、Elixir 语言及围绕它们所展开的技术模型的设计。</p>
<p>语言并不那么重要，重要的是蕴含在语言之中的设计理念和设计思想。</p>
<h2 id="不可变状态"><a href="#不可变状态" class="headerlink" title="不可变状态"></a>不可变状态</h2><p>Erlang 是一种一次性赋值（single-assignment variable）的动态类型函数式编程语言。单次赋值意味着每个变量只能被赋值一次，如果试图在变量被赋值后改变它的值，程序会出错。</p>
<p>如果你初次接触单次赋值这个概念，可能会感到很难理解，但这并不是 Erlang 的原创。函数式编程的重要特点之一就是「不可变状态」（immutable state），Erlang 正符合这个特点。</p>
<p>实际上，在 Erlang 里，变量获得值是一次成功模式匹配操作的结果。如果你有着 C-like 编程语言的背景，你一定知道 <code>=</code> 表示的是一个赋值语句，而且大有各种入门书籍告诉你务必要与数学中的 <code>=</code> 符号区分开来，并很可能会举出 <code>i = i + 1</code> 这样在 C-like 语言中很常见，但在数学中明显不存在的式子（除非是在反证法中）。而在 Erlang 里，<code>=</code> 是一次模式匹配操作，<code>Lhs = Rhs</code> 的真正意思是：计算右侧（Rhs）的值，然后将结果与左侧（Lhs）的模式相匹配。这更多的像是<strong>回归了数学中 <code>=</code> 符号的本意</strong>。实际上，这也并不奇怪，函数式编程这种编程范型就是为了将电脑运算视为数学上的函数计算，同时还要避免使用程序本身的状态和易变的对象。</p>
<p>那为什么「不可变状态」会让编程变得更美好呢？</p>
<p>一个表面上明显的好处是让调试程序变得更简单。引起程序出错的常见原因就是变量得到了意料之外的值，为了防止意料之外的状态进入内部，我们可能不得不在 API 入口处进行参数校验，这意味着我们不得不写出大块的「防御式编程」的代码（这与后文要讲到的 “Let it crash” 特性一脉相承）。在 C-like 的语言里，变量可以被多次修改，因此每一个修改了变量值的地方都有可能是错误产生的地方，而在 Erlang 里，检查这样的错误只需要 check 一处即可。</p>
<p>另一个更深层次的好处是，「不可变状态」是使得程序运行不会产生副作用的保证之一，而<strong>没有副作用意味着可以让程序并行</strong>，这与后文的 Actor 并发模型又是一脉相承的。</p>
<h2 id="Actor-并发模型"><a href="#Actor-并发模型" class="headerlink" title="Actor 并发模型"></a>Actor 并发模型</h2><p>并发模型有很多种，大多数人最熟悉的还是 Java 所采用的基于锁和线程的并发模型，但也有其他的如 Golang 采用的 CSP 模型和 Erlang 的 Actor 模型，如果你对并发模型感兴趣，可以参阅<a href="https://book.douban.com/subject/26337939/">《七周七并发模型》</a>这本书。</p>
<p>如果是传统编程语言来为多核 CPU 编程，就不可避免的需要程序员去对付共享内存的问题。进而为了不破坏共享内存，自然而然地又产生了「锁」的概念，即在必要的时候给这些内存加锁来解决共享内存的问题，而且访问这些共享内存的程序在操作共享内存时还万万不能崩溃，否则很可能产生难以追踪且无法预料的错误（可以与后文的 “Let it crash” 特性对比）。这就跟《人类简史》中所说的「农业社会是人类构建错误社会形态的开始」的概念类似，我们很可能从一开始就构建了不正确的模型，从而只能滚雪球式的将错就错、一错到底。而在 Erlang 里，没有可变状态，没有共享内存，也没有锁，这使得要让程序并行变得很简单。</p>
<p>Erlang 的基本并发单元是进程（Process），它们是一些独立的小型虚拟机。但这与操作系统的进程并不相同，Erlang 的进程是是隶属于编程语言而不是操作系统的。一方面，这意味着 Erlang 是跨平台的，而且它在任何操作系统上都会具有相同的逻辑行为，使得编写可移植的代码完全不是问题；另一方面，这些进程是 Erlang 虚拟机自身实现的，所以它们非常的轻量，创建和销毁都十分快速，占用的资源也非常小，这意味着大量的进程可以并存。</p>
<p>当然，Erlang 的进程是不共享任何内存的，它们相互之间完全独立，而唯一的交互方式是消息（CSP 模型也是如此）。</p>
<p>到此为止，我想题记中的那句「共享的可变状态是万恶之源」就不难理解了。</p>
<h2 id="Let-it-crash"><a href="#Let-it-crash" class="headerlink" title="Let it crash"></a>Let it crash</h2><p>在一般的传统语言里，我们总是被教导着要写「防御性代码」。那可能意味你代码中任何层次抽象出的每一个接口都应当检查传入的参数、可能意味着代码中需要大量的与业务逻辑交织在一起的错误检查代码。这是可以理解的，因为在基于锁和线程的并发模型中，编写多进程代码极其困难，多数程序都只有一个进程，所以如果这个进程随随便便就会崩溃，用专业的话说那就是程序的「鲁棒性」太差了。</p>
<p>而在 Erlang 里对于错误的处理方式与在传统顺序编程的处理方式完全不同。</p>
<p>在 Erlang 里，由于我们有大量的轻量级进程可供支配，所以任何的单进程的故障都不会那么重要。一般情况下，在 Erlang 里我们只需要编写极少量的防御性代码（注意，这里有个过犹不及的误解，在编程时我们不能把 <em>Let it crash</em> 当成一个可以被滥用的特性，也就是不要明知道某个地方可能 crash 却不予理睬），而可以把重点放在纠正性代码上。</p>
<p>在 Erlang 里，系统中的 Process 会划分为两个角色：一部分负责解决业务问题，另一部分则负责在错误发生时纠正错误。负责解决业务问题的部分会尽可能少的使用防御性代码，同时也会假设传入函数的所有参数都是正确的。而纠正错误的部分不会与解决业务的部分耦合在一起，所以这也意味着它们在大部分情况下是<strong>可以被复用</strong>的。</p>
<p>抽象来说，传统的错误处理方式与 Erlang 的错误处理理念实际上是对于问题发生时解决问题的两种不同思路。传统的方式强调尽可能的避免错误发生的可能，但有过编程经验的人基本都知道，要想避免所有错误发生的可能，这是不可能的。而 Erlang 处理错误的角度则不同，它是在错误已经发生后，不管这个错误是怎样的产生的（当然事后还是要具体分析原因的），或者是什么类型的错误，我们都把 A 进程发生的错误交由与之相关的 B 进程来处理，来试图纠正这个错误，使得整个系统恢复到一个我们已知的可控的状态。同时 A 进程直接 crash 掉就好。Erlang 把错误处理的注意力放在的错误发生后的清理工作上。这一点，其实与 Node.js 集群部署时的理念有类似之处，进程分为主进程和工作进程，但 Erlang 在这一点上做得更为彻底，而且在语言层面上就是这样设计的。</p>
<p><em>Let it crash</em> 所带来的好处其实有很多，除了前面已经说到的不用写大量与业务代码交织在一起的防御性代码和在错误发生时可以不管原因统一处理之外，他还能使得发生的错误不至于被恶化造成不可控的更严重的后果，因为发生错误的 Process 已经被 crash 了。它也使得错误能够立即被上述的 B 进程处理，而且错误不会继续运行导致调试也变得困难。更深入地，它还使得我们在设计系统时可以有意识地把业务部分和错误恢复部分当成两个独立的问题来思考，这一点是非常符合 <a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">SoC（Separation of Concerns）</a> 的要求的（我在上一篇博文<a href="http://maples7.com/2017/05/24/programming-and-life/#%E5%88%86%E5%B7%A5%E6%98%8E%E7%A1%AE%EF%BC%8C%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB">《程序与人生》</a>中也有提到这一点），即特定问题由特定专业分工明确的不同代码来解决。</p>
<h2 id="GitHub-语言颜色"><a href="#GitHub-语言颜色" class="headerlink" title="GitHub 语言颜色"></a>GitHub 语言颜色</h2><p>最后，说一个 tricky 的理由，在 GitHub 上代表 Erlang 和 Elixir 的颜色是紫色（Elixir 的颜色更深一点），这个已经暗示了这门技术的尊贵之处了。</p>
<p>哈哈，开个玩笑。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>希望这篇文章能真正引发你对于 Erlang 这门设计优秀的语言的兴趣与关注，并同时推荐你看<a href="https://book.douban.com/subject/25892728/">《Erlang程序设计（第2版）》</a> 这本书，它是由 Erlang 的设计和发明者、「Erlang 之父」Joe Armstrong 亲笔撰写的，所以在语言的诸多设计理念上都有非常清晰的讲解。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
        <tag>函数式编程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>被分化的树叶</title>
    <url>/2017/07/15/diversified-leaves/</url>
    <content><![CDATA[<p>窗外是早晨浓重的雾。那的确只是雾，而不是在这座城市常见的霾。</p>
<p>窗子属于道路边一幢十多层高的居民楼，楼的西边儿有一棵不知名的树。树长得很高，树顶已经没过了两旁的建筑。虽然高，但看起来并不显得十分茂盛。树枝均匀的分布在树干上，让树整体上显得很有层次，像二十多岁少女的身姿。</p>
<p>透过洒落在晨雾里的朦朦胧胧的阳光，还是可以勉强从树下看到树上叶子的形状。椭圆形的树叶，面积并不大，长度只及人类中指的二分之一左右。叶片边缘有细小的锯齿，但在这么大的雾里肯定是分辨不出的了。或许是因为阳光的缘故，树南侧的叶子明显比北侧要茂密一些。</p>
<span id="more"></span>

<p>树叶们早已经被分化了。</p>
<p>那是很多年以前，这棵树还只是南方某森林里不知名的小树苗，树叶也不多，但它们在各个方向的长势却基本一致。然而，从它被种到这座北方城市的这一隅开始，树叶们的分化就命中注定般的开始了。自然环境基本决定了每一片叶子未来的大小和形状，无一幸免，无一例外。</p>
<p>太阳越升越高，雾也开始渐渐散去。</p>
<p>树的正西侧中上部位有一片很普通的叶子，大小在这棵树的所有树叶中居中，可是身材已经完全走了样。尽管它很努力的想要保持自己沿中茎两侧的部分对称且均匀，甚至曾经不惜费尽心思借住风的力量让自己的右半边多接触些阳光，然而还是可以明显看出它的左半边比右半边要大一些，而且中茎也已经被左边压弯了，呈现出指向北边的弧度。这片叶子很不喜欢自己失衡的身材，它觉得很失落，也很苦恼。</p>
<p>从树所在的地方再往西边走十几米，是一个十字路口。这个路口是这座城市繁华的缩影，每天从这经过的人和车成千上万，附近的地铁站里也无时无刻不挤满了人。那片身材走样了的叶子每天除了绞尽脑汁的想着如何让自己的右半边的大小能追上自己的左半边之外，就是从这些在它跟前经过的形形色色的人身上找些乐子了。它认为其他树叶肯定也跟它一样，只是都不好意思说。</p>
<p>这么多年过去了，叶子早已经阅人无数了。它看过各种不同年纪的人、各种不同长相的人、各种不同打扮的人、各种不同身材的人、各种不同职业的人、各种不同心情的人、使用各种不同交通工具的人，甚至是在各种不同天气下的各种各样的人。叶子觉得自己已经不能更了解人类了。</p>
<p>然而在这个平凡的大雾的早晨，叶子感觉自己还是在人类身上发掘出了不一样的东西。</p>
<p>以往的叶子总是把它有限的注意力都放在经过它前面的它感兴趣的某一个人类个体上。虽然它的注意力很有限，但它总是能把个体观察得格外细致。经过它长年累月不断打磨的关于人类的经验，它现在已经能从一个人经过它跟前的短短几秒到十几秒钟内，判断出这个人的职业和大致的社会地位。这种判断几乎是瞬间做出的，叶子知道它现在都已经不必经过叶脑思考了。</p>
<p>这个关于人类的新发现正是发生在叶子一如既往百无聊赖地观察人类的时候。这片因身材而犹豫的叶子大概是心情过于郁闷，想找点事情转移一下自己关于自身身材的注意力，于是尝试着强迫自己重新带上自己的脑子去观察人类，很快，它产生了新的思考。</p>
<p>今天的叶子萌芽出了一种更宏观的思维，它开始思考它所观察到的人类样本总体，于是它很顺理成章地就发现了人类个体之间巨大的差异性。它以前只是能把某个人类个体的特征描述完整，从而形成对这个个体的画像，但今天经过它自己的思考，它发现原来人与人之间是那么的不同，这种差异之巨大应该是它们树叶所完全不能理解也无法想象的。</p>
<p>它当然知道树叶们都已经是各不相同的了，即便它和它的兄弟姐妹们都生长在同一颗树上，也已经产生了很大的不同，而且他还知道世界上还有其他树的存在（这是它对侧的兄弟告诉它的，那个兄弟说它对面就有另外一棵树，树上也长满了叶子）。有的叶子色泽光鲜、叶片饱满、茎脉挺拔，有的则显得相对孱弱，甚至还有的叶片都已经有部分残缺了。但从人类之间的差异性上看，它突然觉得它们树叶之间的差异根本算不上什么，因为树叶之间的差异再怎么大也不至于连一丁点儿相似的地方也找不出吧，然而从人类身上它却可以轻松地从记忆中找到两个没有半点特征一样的人。</p>
<p>这样想着，它觉得它自己左半边和右半边之间的差异好像也不那么可恨了。它不知道这是不是它为了自我合理化所找的借口。</p>
<p>太阳好像已经快到树的正上方了，大雾也基本已经散去。</p>
<p>突然，一阵儿微风吹过，这片爱思考的叶子条件反射般地借着风的力量努力扭转着自己的身姿，想尽量让自己相对瘦小的右半边能多接触到一些正午的阳光。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>意识流</tag>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>完全理解回调函数</title>
    <url>/2017/10/17/understand-callback/</url>
    <content><![CDATA[<p>什么是回调函数？</p>
<p>在任何一个函数是「一等公民」的编程语言里，这都不会成为一个问题。简单说，回调函数就是传递给其他代码的函数实体或引用，但其内涵远没有这么简单。</p>
<p>回调函数本质上提供了一种与常规的上层调用下层代码相反的模式，使得底层代码也有机会反调高层的代码，这大大提升了代码的能力，也同时给工程化项目带来了新的问题和挑战。</p>
<p>回调函数也是事件驱动式编程的基础，使得程序不必像传统的流程驱动式编程那样亦步亦趋的向下进行，而是可以被动性的由外来事件来触发进行，这几乎是所有图形化编程最基础和标准的实现方式。</p>
<span id="more"></span>

<p>一个典型的回调函数的例子就是在各个语言中都很常见的排序接口（比如 C++ STL 中 sort 函数），它们几乎都允许用户自己提供一个定制化的「比较函数」，这个比较函数就是典型的回调函数，它将会在排序接口的内部被执行。正是由于这样的回调函数的存在，使得排序接口不再仅仅局限于自然排序，大大提高了代码和接口的重用性。</p>
<p>回调函数分为两种，一种是同步回调函数，另一种是异步回调函数。上述排序接口的回调函数就是同步回调函数，而在 Node.js 中常见的回调函数是异步回调函数。同步回调和异步回调都可以使得调用者（caller）不再简单依赖于被调用者（callee），使得二者在代码空间分布上解耦，而异步回调函数更是在运行时从时间上将二者解耦。</p>
<p>回调函数背后其实隐藏着「控制反转（IoC，Inversion of Control ）」的编程哲学，或者说回调函数是实现 IoC 的最常见的手段。IoC 的核心思想是 “Don’t call me, I’ll call you”，也被叫作「好莱坞原则」，据说是好莱坞经纪人的口头禅。控制反转其实也很常见，一般的库（library）中有回调函数的地方就有控制反转，这种控制反转可能还是局部的，而 Web 开发中几乎肯定会用的框架（framework）则是把控制反转作用到了全局，它使得基于上的更高层开发者不用像命题作文一样从零开始创作，而是把它变成了一道填空题，你只需要在约定好的地方按照具体的业务需求填入相应的内容即可，整个程序的运转流程被牢牢地把控在框架手中。</p>
<p>这样的框架重用度非常高，经过不断地迭代，越通用的东西会越来越沉淀到底层，服务于更广泛的上层代码，而多亏了回调函数的存在，使得上层开发者也能将自己独特的业务需求植入其中。</p>
<p>从事件驱动式编程的角度来说，回调函数也是实现 OCP（Open Close Principle，开闭原则）的手段之一。「开闭」指的是「对扩展开放，对修改封闭」，它要求代码在尽量少修改的情况下还有足够好的扩展性。举例来说，如果需要实现一个通用的消息消费者，如何做到在添加新的消息类型时却不必修改主函数呢？答案可以是让每种消息类型传递自己特有的回调函数，消费者的主体不变，在合适的地方调用随同消息一起传递过来的回调函数即可。</p>
<p>回调函数也不是全然没有问题。</p>
<p>Node.js 天然的异步特性设计使得大多数接口都是异步的，自然也充满了各种各样的异步回调函数。在 Node.js 里，回调函数最大的问题不仅仅是代码书写上产生了 callback hell，更本质的问题是回调函数的调用得不到有效的控制。因为外部异步接口不都像框架一样是基本可信任的，所以你并不能保证别人会如何对待你传入的回调函数。有趣的是，异步流程控制协议 Promise 再一次利用控制反转解决了回调函数调用的「信任」问题。Promise 把本来由异步接口控制的回调函数调用权收归自己所有，所有的异步调用都是通过 Promise 这个「中介」来完成，而回调函数的管理和调用也由 Promise 来一手掌握。</p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul>
<li><a href="https://book.douban.com/subject/4031906/">《冒号课堂》</a></li>
</ul>
<h4 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h4><ul>
<li><a href="http://maples7.com/2016/08/24/understand-sync-async-and-blocking-non-blocking/">完全理解同步&#x2F;异步与阻塞&#x2F;非阻塞</a></li>
</ul>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>「完全理解」系列</tag>
        <tag>回调函数</tag>
        <tag>控制反转</tag>
      </tags>
  </entry>
  <entry>
    <title>今晚月色真美</title>
    <url>/2017/12/21/love/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=5099468&auto=0&height=66"></iframe>

<p>这个世界上最复杂、最难以捉摸的事情是什么？</p>
<p>有人说，永远不要在晚上做任何一个决定，因为那是人一天中最不理性的时候。<br>我并不赞同。<br>如果所有的事情都由理性思维来主导，那这个世界上不会有音乐和诗歌，<a href="https://www.youtube.com/watch?v=L9jiPQAuTBw">约翰·列侬、爱因斯坦、乔布斯、黑泽明也不会被人们传颂和铭记</a>。<br>夜深人静，是一个人能与自己对话的时候，也是最能看清自己心意的时候。</p>
<span id="more"></span>

<p>有一种感觉，我遗失了很久，最近又开始出现了。<br>也可能并不是我遗失了她。她一直在那儿，但我以为她已经不存在了。<br>这是一种什么样的感觉？<br>她会让人开始做奇怪的事情。<br>她会让头脑里产生更多的臆想和猜测。<br>她会让你的心时而悬着、时而放下。</p>
<p>人的一生中存在命中注定吗？<br>存在一个对其他人而言「正确」的人吗？<br>右边是被保护的位置吗？<br>人与人都是如何相遇的？<br>人的意识是怎样产生的？<br>地球为什么是圆的？<br>…………<br>噢，不，这些问题都太俗气了……</p>
<p>人为什么活着？<br>只能也只有唯一一个答案——好奇心，对尚未知世界的好奇心。<br>世界上唯一不变的事情就是永远在变，是好奇心让你想知道世界下一秒会变成什么样子。<br>嗯，这是我上一秒钟的答案。<br>可是事情似乎已经超出了「好奇心」可以解释的范畴。<br>真的超出了吗？</p>
<p>云朵本来是没有形状的，有人赋予了它们形状。<br>流星本来是没有寓意的，有人相信它们有寓意。<br>世界依然是概率的。<br>今晚的月色是美的。</p>
<p>我，好像是你的。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>感情</tag>
      </tags>
  </entry>
  <entry>
    <title>独立书店的生存困境</title>
    <url>/2017/08/23/arduous-independent-bookstores/</url>
    <content><![CDATA[<p>独立书店，<a href="https://www.wikipedia.org/">维基百科</a>给的描述是<a href="https://zh.wikipedia.org/wiki/%E7%8B%AC%E7%AB%8B%E4%B9%A6%E5%BA%97">「主要以当地人拥有、经营的书店」、「可以是连锁书店的相反词」</a>，这个描述多半还给「独立书店」这个词涂抹上了一点纸质书年代的理想主义色彩。在电商平台、互联网经济大行其道的今天，甭说是「当地人经营」的书店了，即便是那些可以给不同地域的人留下共同回忆、实力还算雄厚的半独立半连锁书店，其生存状态同样不容乐观。又或者说，作为一家「书」店，单看其书籍的销售量，基本已经可以用「垂死挣扎」来形容了。本文就着眼于这些宽泛定义的独立书店的生存困境。当然，新华书店至少是不在这个讨论的范围之内了。</p>
<span id="more"></span>

<p>讲到中国内地的书店，目光自然首先要聚焦到文化中心——北京。</p>
<p>在被戏称为「宇宙中心」的海淀区五道口，高校环伺，不少别具一格的独立书店藏匿其中，这之中最有名的要数目前位于<a href="http://www.tsinghua.edu.cn/">清华</a>南门附近的<a href="http://www.allsagesbooks.com/GUANYU/JIANJIE.HTM">万圣书园</a>。如果你第一次来这个书店，很可能会感到失望——「名声在外的万圣书园原来就是这个破败的样子？」。这也侧面反映出了大环境下独立书店的生存不易。北京的房价自不必多说，更何况是在五道口，2012 年的搬迁直接就让万圣书园的面积缩水了 300 多平米。目前，万圣书园凭借着创办人<a href="https://zh.wikipedia.org/wiki/%E5%88%98%E8%8B%8F%E9%87%8C">刘苏里</a>在文化圈的影响力，依然吸引着众多爱书之人慕名前来，而且这里还时不时会举办一些新书发布会、读书会等活动，客流量还算可观，依傍其旁的醒客咖啡也势必把客单价提高了不少。万圣书园最大的优势就在于其书籍收录之广泛全面，这从店面内直接码放到天花板的书架就可以看出。如果你想找别的书店找不到的书，如果你想找某个品类下一系列相关的书，<del>如果你还想逗一逗书店里的万圣猫，</del>来万圣书园看看吧。</p>
<p>与万圣书园隔街相望的是<a href="https://baike.baidu.com/item/%E8%B1%86%E7%93%A3%E4%B9%A6%E5%BA%97">豆瓣书店</a>。这个书店的店面就更小了，总共也就约五十平米。它最大的特色就是专营旧书，这也可能是它至今还能在著名的万圣书园对面存活下来的原因。旧书并不是指二手书，而是指那些出版年代久远，可能即将被出版社销毁的库存书。但可别因为这样就小看了这些书的质量，能进入豆瓣书店的书都是店长去北京的各大出版社收罗的。因此，你总是能在豆瓣书店找到很多奇特又便宜的旧书，它们可能出版了 5-20 年甚至更长的时间，但你还是很有可能在它们中发现你感兴趣的东西。豆瓣书店每个月还会设计不一样的书签放在门口，供顾客随意取用收藏。值得一提的是，豆瓣书店跟<a href="https://www.douban.com/">豆瓣网</a>没有任何关系，纯粹只是起名的巧合而已<del>，不然店面就不会这么小了（甚至有热心的豆瓣网友呼吁豆瓣网收购豆瓣书店）</del>。</p>
<p>另一个在<a href="http://www.pku.edu.cn/">北大</a>师生心中拥有崇高地位的书店是<a href="http://www.jiemian.com/article/1426822.html">野草书店</a>。本来它已经在北大校园内呆了 14 年了，但因为今年初夏的店面招标失败，被迫搬离了北大，来到了万圣书园附近的一个地下超市的旁边。野草书店可能是这三个书店里网络营销做得最好的。书店经理赵亮用几个手机几个微信号在网上维护着一两万个野草书店的忠实客户，微博上也会时常更新最新到货的新书（可网购邮寄），再配合令人难以想象的折扣力度，野草书店在线上线下应该都还经营得不错。听北大的朋友说，他们以前经常拿着老师开的书单来野草书店购书。</p>
<p>位于成府路上的这三个独立书店可以说是北京众多独立书店的代表，它们各有各的特色，能够在艰难环境中存活下来的原因更是各不相同。</p>
<p>跳出北京，南方的一些半独立书店就和北京这几个书店的经营策略不完全相同<del>，至少它们的店面都有着现代化的精致装修和室内设计</del>。</p>
<p>拿 2015 年年底在苏州开业的<a href="https://www.esliteliving.com/store/store.aspx?a=CN&l=gb&storeno=201511180004">诚品书店</a>来说，它已经被打造成集潮流生活、风格美学、创意设计于一体，照顾现代人品质生活方方面面的一个联合体。这里不仅仅做到了藏书丰富（尤其是一些外文书和台版书），是爱书之人的首选，同时也吸引了一群对生活品质有要求的人。和诚品有着类似经营策略的还有<a href="https://zh.wikipedia.org/wiki/%E6%96%B9%E6%89%80">方所</a>，目前总共只有四家，分别位于广州、成都、重庆和青岛。方所甚至比诚品有着更高的「艺术」和「审美」追求，基本都开在奢侈品林立的中心商务区。</p>
<p>另外一些规模相对小一些的半独立书店，像<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E8%A5%BF%E5%BC%97%E4%B9%A6%E5%BA%97">西西弗书店</a>、广州北京路上的<a href="https://baike.baidu.com/item/%E8%81%94%E5%90%88%E4%B9%A6%E5%BA%97">联合书店</a>，虽然还没有达到像苏州诚品这样多位一体的状态，但靠着经常举办的特色活动，也吸引着一批对特定领域感兴趣的人群的光顾，再加上店内的饮品店和一些其他的配套服务，应该也都还有尚可观的经营状态。</p>
<p>综合来看，虽然本文所列出的书店有的似乎还活得不错，但整个实体书店行业一定是一年不如一年了。高昂的地价成本，加上纸质书相对于电子书的固有成本，以及电商时代人们购书习惯的逐渐变化，使得这些书店不得不树立自己的特色、塑造自己别具一格的品牌形象，来吸引那些有特定需求的人群。好在，这个时间节点上，有不少人还是偏爱纸质书阅读的。</p>
<p>很多爱书之人都有这样的一个梦想，那就是退休之后开一家有个性的书店。随着时间的推移和时代的发展，这个梦想可能会变得越来越遥不可及。对于现有的这些独立书店来说，如果不迅速找准自己的特色和定位，扬长补短，那它们的命运都值得让人担忧。</p>
<p>或许，在独立书店这个领域，光有一点点理想主义情怀，还远远不够。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>独立书店</tag>
      </tags>
  </entry>
  <entry>
    <title>完全理解并发</title>
    <url>/2018/10/21/understand-concurrency/</url>
    <content><![CDATA[<p>越是往后端深入到 Web 开发和分布式系统，就越会觉得把「并发」理解清楚是多么重要，而每天的日常工作中很多时候都需要处理与并发有关的话题，大到整个系统架构层面的并发考量，小到某一段代码的并发控制。</p>
<p>本来不想把这篇文章加入到<a href="http://maples7.com/tags/%E3%80%8C%E5%AE%8C%E5%85%A8%E7%90%86%E8%A7%A3%E3%80%8D%E7%B3%BB%E5%88%97/">「完全理解」系列</a>，因为觉得「并发」涉及到的东西实在是很多，而我想凭借一篇博客企图「完全理解」那是不现实的。但虽然不能做到「完全理解」，但我还是会尝试尽力提纲挈领的把「并发」相关的话题都理清楚，把脉络勾勒出来，让它尽可能对得起「完全」吧。<del>毕竟，如果以后我有了一些更深的理解，我还可以继续迭代这篇文章。</del></p>
<span id="more"></span>

<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>在开始正式的话题之前，我们先来厘清两个概念——「并发」与「并行」。</p>
<p>Erlang 之父 Joe Armstrong 曾经用一张非常简单易懂的图解释了「并发」与「并行」的区别：</p>
<p><img data-src="https://i.loli.net/2018/08/06/5b67309e4d019.jpg" alt="Joe Armstrong 解释「并发」与「并行」"></p>
<p>「并发」是同学们排成两队，然而却只有一个咖啡机在工作，所以两个队列排在前面的同学交替使用咖啡机；「并行」则是两台咖啡机分别服务两个独立的同学队列，它们同时进行，互不干扰。</p>
<p>这样的例子简单易懂，但依然还需要更进一步说明的是，「并发」与「并行」其实并不是同一个维度上非黑即白的两个对立的概念。「并发」更多的强调的是有没有这样的能力或特征，它是从事物的性质和对外表现上来说的，它不在乎你内部是如何实现「并发」的，相对而言是在更高层次上的概括，而「并行」则规定了它们在物理上一定是同时进行的，相对而言更严格。</p>
<p>具体从编程的角度来说，「并行」甚至可以是实现「并发」的一种手段，比如用下文所要讲的「多线程」或「多进程」的方式来赋能某一段程序的「并发」能力：为了使程序具备「并发」的能力，采用「多线程」或「多进程」在应用层面上可以「并行」运行的具体实现手段来为其赋能。</p>
<h2 id="计算机操作系统发展史"><a href="#计算机操作系统发展史" class="headerlink" title="计算机操作系统发展史"></a>计算机操作系统发展史</h2><p>要追根溯源的来理解「并发」，我们首先应该了解一下计算机操作系统的发展历史。因为回顾整个计算机操作系统的发展历史，我们就会发现，几乎所有的关键历史节点，都是因为它使得计算机系统拥有了更强的并发处理能力而变得重要的。</p>
<p>在计算机诞生之初，是没有操作系统这种东西存在的，当时人们只能先把打孔纸带通过输入机将程序传入计算机，再启动运行。在程序执行完毕之后，打印机把计算结果输出，在现场监督程序执行的程序员再取走纸带。在这个时期，同一个计算机系统在同一时间只能处理唯一确定的一件事情。</p>
<p>后来人们发明了批处理系统。批处理系统相当于计算机上的一个任务监督程序，在它的控制和调度下，计算机能够自动的、成批的处理一个或多个用户的任务。在批处理系统的帮助下，各个任务之间可以自动衔接，减少了需要人工建立任务和手工操作的时间，提高了计算机的利用效率。</p>
<p>再后来，随着 CPU 性能的不断提升，出现了分时系统和实时系统。分时系统是把 CPU 的运行时间分成很短的时间片，按时间片轮流把 CPU 分配给各联机任务使用。若某个任务在分配给它的时间片内不能完成其计算，则该任务暂时中断，把 CPU 让给另一任务使用，等待下一轮调度时再继续其运行。由于计算机速度很快，各个任务之间轮转得也很快，给每个用户的感觉是他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。为了解决分时系统不能及时响应用户指令的情况，又出现了能够在严格的时间范围内完成事件处理、及时响应随机外部事件的实时系统。</p>
<p>IBM 于 1964 年伴随着大型机 System&#x2F;360 推出了通用操作系统 OS&#x2F;360，这个通用的操作系统使得不同型号的计算机设备也可以在同样的操作系统控制下使用同样的外部设备（如打印机）和更上层的软件，并且这些设备之间可以相互连接，共同工作。通用操作系统使得不同型号的计算机设备之间能够真正组成网络来处理复杂的任务。<del>软件工程领域的著作<a href="https://book.douban.com/subject/2230248/">《人月神话》</a>也是诞生于 IBM 的这个项目。</del></p>
<p>再往后就是我们相对更加熟悉的 Unix&#x2F;Linux&#x2F;Windows&#x2F;OS X 这些现代操作系统诞生、迭代、版本更替的历史，目前这些操作系统的并发能力已经远远超出了当时的 OS&#x2F;360，而现代计算机网络的加持更是使得理论上的计算机并发处理能力几乎已经没有了上限。</p>
<p>从整个计算机操作系统的历史我们可以清晰的看到历史上的计算机科学家们是如何一步一步来提升计算机处理任务的效率的。从一开始需要手工的开启、监督、结束单一任务，到使用批处理系统来自动化的监督任务流水线，再到使用分时系统来让 CPU 在多个任务之间不停的轮转，然后用后文要详述的多 CPU 使用多进程和多线程的方式来进一步提升多任务的执行效率，最后我们使用通用计算机系统来组成庞大的计算集群来处理复杂的各种各样需要随机响应的任务，并发能力一次比一次有了质的提升。</p>
<p>如果说<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B">「摩尔定律」</a>使得 CPU 的性能可以指数级的增长来从单机速度上提升任务完成的效率，那么不断的提升并发能力则是更高屋建瓴的考虑如何不间断不浪费的来「压榨」CPU 的高性能，这种思考问题的维度比一门心思的考虑提升单 CPU 的速度更具有现实意义，对于解决现有问题来说是更加高明的选择。尤其是在「摩尔定律」行将失效的今天，采用分布式的方式提高整个系统的并发处理能力几乎成了唯一的选择。</p>
<h2 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h2><p>让我们先回到单机时代，来了解目前主流的并发模型——多进程与多线程。现代操作系统早已进入多 CPU 时代，自然会支持多进程和多线程。「进程」就是操作系统中一个具有独立功能的程序，操作系统管理所有进程的执行并且以进程为单位分配存储空间。一个进程还可以拥有多个并发的执行流程，这些并发的执行流程是可以获得 CPU 调度和分派的基本执行单元，也就是线程。</p>
<p>进程是计算机资源的拥有者，创建、切换和销毁都有较大的时空开销，而一个进程内的所有线程共享这个进程的资源，更轻量级，对其的相关操作也开销更小。需要注意的是，对于单核 CPU 系统而言，并行其实是不存在的，任何时刻 CPU 其实只能被一个线程所获取，线程之间共享了 CPU 的执行时间。由于切换的速度很快，对外表现为并发执行的样子。</p>
<p>多进程和多线程是如今高级编程语言中实现并发的常规模型，比如 C++、Java、Python。同时为了解决程序中多个进程和线程对资源的抢占问题，还引入了「锁」的概念。在这个并发模型中，需要开发人员利用「锁」来处理资源抢占的问题，也就是不让某一个资源同时被多于一个进程（线程）所处理而带来不可预期的后果。</p>
<p>既然有多进程和多线程，那么「锁」自然也有「进程锁」和「线程锁」。我们知道两个进程其实是相互独立的，各自拥有操作系统分配的独立资源，而「进程锁」是为了防止两个进程对他们所占用的资源以外的共享资源同时访问，一般可以使用操作系统级别的信号量来实现。相对应的，「线程锁」则是保证同一段代码在同一时间只有一个线程在执行，一般各语言本身或类库会提供实现方式。</p>
<h2 id="分布式并发锁"><a href="#分布式并发锁" class="headerlink" title="分布式并发锁"></a>分布式并发锁</h2><p>「分布式锁」跟「进程锁」和「线程锁」很像，不过它更多的是使用在计算集群的场景中。在本质上，进程锁、线程锁和分布式锁的作用都是一样的，只是作用的颗粒度不一样。线程锁作用于单一进程的范围，进程锁作用于单一操作系统的范围，而分布式锁则可以作用于网络结构中。在分布式集群当中，我们使用分布式锁来保证不同线程对代码和资源是独占的。</p>
<p>如何实现一个完美的分布式锁呢？我们先来分析一下实现一个好的分布式锁应该满足什么需求：首先这个加锁操作应该是原子性的，否则这个锁是有可能被「击穿」的；其次锁一般还需要有过期时间，使得某一次执行异常没有移除锁的情况下也能自然过期然后重试。</p>
<p>以大多数人都熟悉的 Redis 为例，我们可以使用 Redis 的 set 指令，把 key 作为锁的标志。尤其注意的是，这个操作原子性包含了查看锁存不存在、加锁和设置过期时间三步操作，它们合在一起应该具有原子性（至少前两步）。也就是说，如果我们需要先使用 get 指令查看锁存不存在再决定是否加锁，这个锁已经不是一把好「锁」了。好在 <a href="https://redis.io/commands/set">Redis 2.6.12 以上的 set 指令</a> 支持了同时加参数设置过期时间和判断 key 是否存在，比如使用 <code>SET lock_key lock EX 5000 NX</code>，NX 保证了锁不存在时才上锁，而 Redis 指令本身具有原子性，这样就实现了一把看起来还不错的锁。在任务执行完毕后我们还需要用 del 指令主动把锁删掉以释放资源。</p>
<p>上述例子只是一个简单的场景，这个锁其实还并不是完美的。思考这样的问题：如果某一次操作线程 A 执行的特别慢，超过了过期时间，这个时候锁已经自动过期失效了，这样就有可能两个线程同时在执行了。如何避免这样的问题这里不再详述，感兴趣的同学可以参考末尾 References 里面的内容。总之，实现一把完美的分布式锁可能并没有想象中那么简单。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>对于高级编程语言而言，多进程和多线程的并发模型更多的还是与操作系统底层对于并发的实现是保持一致的。也就是说，在它们的抽象层级上，实现并发的方式基本只是复刻了操作系统底层的并发模型。而 JavaScript 却不一样。</p>
<p>JavaScript 在诞生时就被定位为在网页前端执行的脚本，为了保证线程安全，而且主线程也不会被 I&#x2F;O 等待所阻塞而失去响应，JavaScript 在设计阶段就采用了「异步事件模型」。这个模型并不是 JavaScript 独有的，它只是借用了这个古老的模型来解决它自身的问题。</p>
<p>在实际情况中，异步事件模型也是采用多线程的方式来实施的。但是对于开发人员而言，你永远只需要跟主线程打交道，而所有的这些交互都是所谓「异步」的，也就是说，你调用的任何一个 API 都在执行成功后主动告知你执行结果，这样你就可以不必被任何 I&#x2F;O 所堵塞（详细的关于异步、同步、阻塞和非阻塞的辨析可以看这里：<a href="http://maples7.com/2016/08/24/understand-sync-async-and-blocking-non-blocking/">《完全理解同步&#x2F;异步与阻塞&#x2F;非阻塞》</a>）。既然不会被阻塞，那么你可以以很快的速度调用很多个你需要调用的 I&#x2F;O，这些 API 在自己执行完毕后会主动返回结果，你可以拿着结果来继续做后续的事情，而其他时刻你完全是「自由」的。</p>
<p>在这个并发模型中，你不再需要处理各种「锁」的问题，因为真正和你交互的只有主线程。可是作为开发者，你可能需要考虑如何处理代码中的各种异步流程。因为在异步的世界里，代码不再是简单的按照书写顺序来顺序执行的，如何在工程中清晰合理的组织这些流程是在这个并发模型下需要考虑的问题。</p>
<h2 id="各种各样的并发模型"><a href="#各种各样的并发模型" class="headerlink" title="各种各样的并发模型"></a>各种各样的并发模型</h2><p>这个世界上除了多进程&#x2F;多线程的并发模型和异步事件并发模型，还有很多其他的并发模型，比如 Erlang 的 Actor 并发模型和 Golang 的 CSP 并发模型。在 Erlang 的并发世界里，有很多比内核线程还要轻量级的对象，它们之间通过各种 Message 来进行数据共享。这些对象非常轻，可以同时成千上万的被创建出来实现并发，而对象之间都通过发消息来进行数据交换，根本不需要「锁」。</p>
<p>在一个没有「锁」的世界里，并发的效率是可以大大的提升的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每一个并发模型都有其存在的意义和价值，不过在具体的业务场景下，采用不同的并发模型的好坏却是客观的。</p>
<p>真理是存在的，可以被不断逼近却永远无法被任何事物所完美诠释。在技术的领域里，没有永恒的真理，但是真理永远值得被追求。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://book.douban.com/subject/26337939/">《七周七并发模型》</a></li>
<li><a href="https://github.com/jackfrued/Python-100-Days">Python-100-Days</a></li>
<li><a href="https://www.itcodemonkey.com/article/3934.html">漫画：什么是分布式锁？</a></li>
</ul>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>「完全理解」系列</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>长按是好的交互方式吗？</title>
    <url>/2018/12/19/long-press-sucks/</url>
    <content><![CDATA[<p>长按是好的交互方式吗？</p>
<p>这个问题虽然微小但其实困扰了我本人很久。每当我拿起索尼头戴式耳机，忍受着右手以一种不那么舒服的姿势，心里充满不确定性和不安全感地用自己的大拇指紧紧按住电源键几秒钟试图开机或关机时，我都会反复的问自己：长按是一种好的交互方式吗？</p>
<p>智能手机时代，最开始接触到「长按」这种交互方式，大概始于智能手机的电源键。记忆里，在 iOS 系统中，「长按电源键」一开始是唤出关机界面「滑动已关机」的交互方式，而在新款 iPhone 搭配的 iOS 中，「长按电源键」是唤醒 Siri 的一种方式。</p>
<span id="more"></span>

<p>除了平时最长接触到的手机，「长按」交互在各种音乐相关的电子设备上也常见，比如各种便携式音箱和头戴式耳机<del>（也不知道是音箱「抄」了耳机，还是耳机「抄」了音箱）</del>。在我的索尼 SRS-X11 小音箱上，「短按电源键」是开关，「长按电源键直到听到哔声」会进入蓝牙配对模式。而在索尼 WH-CH500 头戴式耳机上，「长按电源键约 2 秒」是开关耳机，「长按电源键约 7 秒」会让耳机进入蓝牙配对模式，这几乎是目前我所有电子设备中让我最想吐槽的交互方式。</p>
<p>不管是 iPhone 还是索尼的这两款音乐电子设备，都是大众电子消费品。对于我个人而言，长按的交互方式在 iPhone 和 SRS-X11 上的设计是合格的，在 WH-CH500 上的设计则完全不合格，这几乎是初级产品经理或交互设计师都不应该犯的设计错误。</p>
<p>作为一名软件开发工程师，我并不知道「长按」在交互设计上是否有硬件技术或工程上的考量，这里仅从用户体验的角度来妄自品评一下。</p>
<p>首先，「长按」交互本身是一种怎样的体验？</p>
<p>第一，「长」不是一个可以量化的形容词。我并不知道我需要按多久才算「长」，每个人对于「长」的理解是不一样的，用户由此在心中产生的不确定性疑惑和不安全感最终会转化成对产品的不信任，使得用户体验大打折扣。更不用说「长按 2 秒是 A 操作而长按 7 秒是 B 操作」这种失败设计了：我要是不小心长按了 3.5 秒会怎么样？多长时间是 7 秒呢？我需要用秒表数吗？现在我已经按几秒了？</p>
<p>第二，「长」这个字首先就说明了这是一个需要用户<strong>持续</strong>用力的<strong>过程</strong>，可以说非常不友好。在这个快节奏的社会，人们都在追求<a href="http://maples7.com/2016/08/24/understand-sync-async-and-blocking-non-blocking/">「异步非阻塞」式的交互方式</a>：所谓「异步」，我希望我调用了任务之后可以在它完成后主动通知我；所谓「非阻塞」，在这个任务执行的过程中我希望我自己是自由的，可以去做任何我想做的事情，我作为独立个体是完全解放的。虽然「长按」交互本身是一个时间上并不算长的交互，但它几乎带给我几秒钟的「同步阻塞」的体验，这意味着我的 CPU —— 大脑 —— 甚至需要一直关注在我的长按操作上，并且要不断的 check 我的操作是否成功了。这简直「反现代人类」。</p>
<p>第三，「长按」的重试成本很高。「长按」本身就是一个耗时操作，假设在我的一阵不安的惊恐长按操作之后，产品并没有实现我预期的效果，我首先可能会怀疑 —— 是它还在「反应中」吗？操作本身的延时性会让人怀疑是不是这个操作产生的结果也是耗时的，这意味着我需要等。如果稍等片刻之后大概率确信是刚才的操作失败，我就需要不断的重试，这是一个接一个「同步阻塞」的耗时操作。</p>
<p>对于 C 端产品而言，好的交互应该是自然而然的，在你进行过操作之后你不需要意识到你做过了什么，也不需要怀疑自己，产品就已经给了你想要的东西。而「长按」的交互方式违背了这一点。</p>
<p>那「长按」交互的设计初衷是什么呢？我想本质上是为了使得操作本身不那么容易被触发。所以接下来，我们再结合具体产品的使用场景来琢磨一下这个交互方式。</p>
<p>在 iPhone 上，无论是「开关机」操作还是「唤醒 Siri」的操作，都不算是常用操作，而且由于电源键的位置正好是单手拿起握住时食指所在的位置，削弱了「长按」操作本身的「存在感」；在 SRS-X11 上，「长按」仅用于蓝牙配对，这本身也是一个很低频的操作；而在 WH-CH500 上，「长按」居然被用在了耳机开关这种高频操作上，在有时不确定设备是否是开启状态而又不想把它从头上摘下来看指示灯的状态的时候，我甚至需要先长按试试耳机是开机状态还是关机状态，如果不幸把它按关机了我还需要再长按一次来开启它。更不必说「长按不同时间产品会响应不同的操作结果」了，这几乎是一个类似于用多进制计算机取代二进制计算机的失败设计，加剧了系统的不稳定性和用户体验的不确定性。似乎几乎所有的索尼头戴式耳机都是采用的「长按电源键进行开关」的交互设计，我非常希望他们能仔细考虑一下这一点。在我看来，即便是拨动式的开关设计也比长按来开关耳机的交互体验要好。</p>
<p>综上所述，从具体产品的使用场景上来说，「长按」其实类似于软件开发中日志等级的 WARNING 级别，不是日常信息且需要一些用户的注意力，如果用户需要使用到这个操作，那希望他是有一定的意识清楚自己在做什么的。按这个类比，日常的点按、滑动等无意识操作算是 INFO 级别的日志；而非紧急情况下不应该使用的操作，比如 iOS 里的「SOS 紧急呼叫」、楼道里需要砸破玻璃才能按下的消防按钮等，应该归类到 ERROR 级别。</p>
<p>希望以后的产品设计师在选择使用「长按」作为交互方式时都能走点心，而不仅仅是按照所谓的「传统如此」。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>交互设计</tag>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title>2017 年书单</title>
    <url>/2017/12/31/2017-booklist/</url>
    <content><![CDATA[<p>今年太「荒废」了。无论是工作还是生活，已经发生的事情之丰富复杂相比去年完全有过之而无不及，自己心态上的改变也是不少。这种内省式的变化会直接导致个人情绪的变化。用一个烂俗的比喻来说，如果去年的心情像一汪平静的湖水，那今年则可以用海啸来形容<del>（夸张到油腻了）</del>。</p>
<p>我不是一个喜欢制定目标的人，因为无论事情是否达到了你的目标，这个设定都会让你对于自己所做的事情产生反向的反馈：完成了会开始沾沾自喜、放松警惕，没完成则会开始怀疑人生、消极懈怠。当然，这可能只是一个现实的悲观主义者的惯性思维，不足以为参考。</p>
<p>即便如此，年初也制定了一些小目标，明确了一下「即将过去的这一年」的大致方向。写博客的目标是超额完成了，导致我后几个月的博客更新都放缓了（应证了我上一段的描述），可是看书的目标远远没有达到。这意味着今年是个「输出」大于「输入」的一年。</p>
<span id="more"></span>

<p>开篇不多说，今年的书单如下：</p>
<ol>
<li><p><a href="https://book.douban.com/subject/27013716/">沉默的大多数</a>：★★★★★<br>每一句话的笔触都轻，但合起来的力道却很重。三观正得惊人，王小波手执着民族的警钟。    </p>
</li>
<li><p><a href="https://book.douban.com/subject/26729776/">雪人</a>：★★★★☆<br>其实不能算典型的推理小说吧，不过读起来非常爽，文字画面感极强。虽然反转设计的痕迹很重，但非常有效的加强了故事的戏剧张力，自然就在一堆老掉牙的传统推理小说中脱颖而出了。    </p>
</li>
<li><p><a href="https://book.douban.com/subject/26835090/">软技能：代码之外的生存指南</a>：★★★★<br>我是听了译者在某个播客节目的介绍才了解到这本书的，而这本书的内容完全超出了我的预期。<br>首先，这本书的内容不是鸡汤，而是从作者的亲身体验给程序员打造的全方位工作、生活、学习、健身等等各个方面的实用建议。更重要的是这些建议中体现出的作者的技术价值观，我个人也非常认同。<br>目前市面上这类书不多，能跟上时代而不流于形式和灌鸡汤的就更少了。而且译者翻译的中译本很用心，强烈推荐。    </p>
</li>
<li><p><a href="https://book.douban.com/subject/25910698/">迷人的假象</a>：★★★★<br>一本现代大众心理学读物。<br>这个社会很多看似神秘的现象或许都可以从心理学的角度找到科学的解释，甚至可以加以利用。<br>而客观世界的大多数情况下，随机、偶然、无意义才是背后最大的真相，这样的真相又乏味又动人。    </p>
</li>
<li><p><a href="https://book.douban.com/subject/26739566/">途客圈创业记：不疯魔，不成活</a>：★★★★<br>对创业的描写可以说非常真实了，很多事情即便是我这种才进创业公司几个月的人都有些体会，或许大部分人心里都有一个创业梦吧。<br>作者及其团队包括复盘在内一些方法很值得学习，他写过的公众号文章我之前也基本是一篇不落的都看过，非常好。<br>创业维艰，一切都值得好好珍惜。    </p>
</li>
<li><p><a href="http://survivor.ruanyifeng.com/">未来世界的幸存者</a>：★★★☆<br>阮一峰老师还未出版的新书。<br>虽然不是所有的推论过程都十分赞同，但内容还是有一定的启发性，阮一峰老师能够看到事物之间的联系。      </p>
</li>
<li><p><a href="https://book.douban.com/subject/25892728/">Erlang 程序设计（第二版）</a>：★★★★★<br>其实并没有太深入扣代码细节的东西，但惊艳到我的还是 Erlang 实现并发的「与众不同」的设计思路，值得每一个后端程序员了解：<a href="http://maples7.com/2017/06/10/awesome-erlang/">《了不起的 Erlang》</a>。    </p>
</li>
<li><p><a href="https://book.douban.com/subject/27059884/">碟形世界：猫和少年魔笛手</a>：★★★☆<br>固然是好的童话故事，也明显可以看出作者就是在暗讽成人世界的一些事情（我愈发开始对这种用童话故事讨好成年世界的做法的动机变得敏感和怀疑，或许是受近年某些国产作品的影响，而且大多时候这些暗讽的内容已经被各种作品说了太多遍了，也没什么意思了），但腰封上宣传的「比《哈利·波特》和《魔戒》加起来还好看的」，仅就这一本来说，哪里来的自信？    </p>
</li>
<li><p><a href="https://book.douban.com/subject/11941213/">Learn Python the Hard Way(3rd Edition)</a>：★★★<br>一本非常适合新手入门的书，但我开始越来越不赞同用所谓的 “hard way” 的方式去学习新知，我觉得那只是对自己放弃更进一步去探索的借口和让自己心安的理由。知识是没有边界的，尽管放开了去学就好了，何必用 “hard way” 这种外在方式上的、形而下的枷锁来束缚自己呢？<br>Anyway, 今年大部分的工作时间是在用 Python 的，但对这门语言的自信程度还远不如 Node.js，甚至我并不确定它是否真的能让我达到对 Node.js 那样的感觉。依据我有限的经验，Python 在工程化上的实践成熟度比 Node.js 还是差了不少。</p>
</li>
</ol>
<p>人是复杂的，与人相关的所有事情都复杂，人的复杂之处体现在人性上；但「人群」却是简单的，因为你永远只需要往最坏的方向去想就好了。</p>
<p>我为什么在最后还莫名其妙的抛出这样的观点？你可以说世界是一直在向前发展的，也可以鸡贼的说世界是「螺旋式上升」的，但在大众认知领域，世界的发展其实是循环的。这大概是我所看到的 2017 年的最大的特征。</p>
<p>大众认知的底线无疑是在提高，但讨论的实质内容却并没有什么变化。大众热衷于讨论的不是知识，而是观点，而且是些早已经被无数前辈所表达的观点，绝大部分人只是在简单的跟随和重复。知识在信息洪流中的传播天生必然会败给观点，越来越多的人会选择「美味的糖果」而不是「苦口的良药」，依然是人性使然。大众永远在追逐社会热点，而社会热点的发生近乎「随机」。</p>
<p>不过说到这里，<a href="http://maples7.com/2016/11/27/traditional-edu-and-programming/">再一次</a>为了避免误会，还是得区分一下上文所说的「知识」与「观点」。知识是客观的、量化的、难以简单表达的，而观点则完全相反。只有知识才能产生创造，而观点并不能，甚至可能会扼杀创造。</p>
<p>所以，新的一年的一个大的方向就是——更多的学习知识，不要热衷于讨论观点。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 MySQL 的热数据与冷数据分离设计与实现</title>
    <url>/2018/12/25/hot-cold-data-based-on-mysql/</url>
    <content><![CDATA[<p>作为<a href="https://www.seniverse.com/">一家提供商业气象数据服务的创业公司</a>，我们一直都有一项「欠交的作业」没有完成，那就是合理的数据规划和数据治理规范。对于早期的初创公司而言，可能很难从一开始就能构想到需要对数据存储进行合理的规划并制定长期规范，大多都是简单使用单实例的数据库，直到随着业务增长数据量累积到一个不得不严肃考虑这个问题的地步。</p>
<h2 id="数据库发展简介"><a href="#数据库发展简介" class="headerlink" title="数据库发展简介"></a>数据库发展简介</h2><p>数据量的增长其实一直是随着互联网的发展呈现爆发式增长的，因为各种各样的数据都在不断的被原样或者是经过少量的更改和增补后拷贝到互联网的各个角落。为了适应互联网数据的海量增长，在后端和架构意义上而言，数据库的发展也大致经历了「单库单表 -&gt; 主从读写分离 -&gt; 分表分库 -&gt; NoSQL -&gt; NewSQL」这样的过程。</p>
<span id="more"></span>

<p>一开始，我们把数据都堆在一个数据表里；后来为了提高性能、增加数据扩展的能力，采用了「主从读写分离」和「分表分库」的方式，前者只需要在主从实例之间做数据同步而不会对既有业务有较大的影响，后者则需要用一套切合业务逻辑的方式合理的制定分表分库的策略；再后来出现的 NoSQL，打破了传统关系型数据库固有的一些限制，它们有不同的类型，有的是为了解决高性能读写的需求，有的则是为了解决海量数据存储的需求，还有的需要数据结构本身具备可扩展性；NoSQL 的不同类型在不同的侧重点解决了不同的问题，而如今出现的 NewSQL 则倾向于把数据库看作是一个黑匣子服务，你还是可以遵照传统的数据库协议的使用方式（比如传统 MySQL 的使用方式）来使用它，但数据存储服务本身既可以同时具备较高的读写性能又可以轻易的实现横向扩展。NewSQL 并不是一个全新的东西，我们可以把它看作是之前积累的数据库技术结合分布式技术的集大成解决方案，它使得使用数据服务的人几乎不需要再考虑性能和扩展问题，而尽量在数据服务内部实现高可用、高性能、可扩展。</p>
<h2 id="「热数据」和「冷数据」"><a href="#「热数据」和「冷数据」" class="headerlink" title="「热数据」和「冷数据」"></a>「热数据」和「冷数据」</h2><p>在简单了解了数据库发展历程之后，再介绍一下我们目前在数据存储上遇到的问题和一些业务背景。</p>
<p>作为气象大数据服务商，随着我们积累的数据量和数据种类越来越多，我们发现我们已经迫切需要一个在全局层面统一的数据路径规划和规范。很多时候，我们从数据源获取到的数据，既需要马上分发给线上用户，也需要被内部项目使用，如果只是简单的按需实现，那数据流转会非常混乱。基于这种考虑，我们引入了「热数据」（「在线数据」）和「冷数据」（「离线数据」）的概念：</p>
<ul>
<li><p>「热数据」指的是需要即时对用户进行分发的数据，即从数据源抓取之后经过数据清洗，需要即时存储到可以快速分发的存储介质（如 Redis）供 API 或直接面向用户的系统使用。「热数据」线需要重点保障服务质量和稳定性，为了保证数据的时效性，在数据处理上也是优先级高的数据。「热数据」可能是临时或短期存储的，后来的数据可能会覆盖已有的数据。</p>
</li>
<li><p>「冷数据」指的是不需要即时分发给用户的数据，这些数据甚至可能永远都不会原样分发给用户的，但它们需要经过长期的积累，使我们可以从中得出基于此的更高 level 的分析。「冷数据」典型的使用场景是供内部数据评估系统做数据准确度的评估分析，同时也可以给算法团队建模使用。设立这个数据线的原则是不影响「热数据」的服务质量，尤其是时效性和稳定性，同时也满足一些非线上项目的数据使用需求。</p>
</li>
</ul>
<p><img data-src="https://i.loli.net/2018/12/25/5c213783d5c3e.png" alt="热数据线和冷数据线设计"></p>
<p>这其实也不是什么新鲜的概念，很多做数据服务的公司都有类似的设计，我们只是根据我们的业务特点借用了这样的概念，不过它们的含义可能与你在其他地方看到的类似概念的含义有所不同。</p>
<p>结合我们具体的业务场景来说，「热数据」线其实已经一直在有效运转了，即我们从数据源获取到数据然后尽快存储到高性能存储介质中，再通过 HTTP 协议分发出去，这些数据都是即时更新的最新的数据。而其中有一些类型的数据，我们还需要在可视化项目中查看历史变化情况，并能进行简单的聚合和计算，这意味着数据需要积累一段时间，那我们也需要一些可以持久化存储的介质。</p>
<p>拿天气实况来举例，我们在采集完数据之后，随即就存储最新的一份数据到 Redis，而出于数据积累的角度考虑，我们同时也把新数据写入 MySQL。这是之前我们的做法，然而随着数据量的极速扩大，问题很快就会出在 MySQL 上。对于「亿」级别行数往上的 MySQL 单表，操作会变得越来越困难，而大范围的抽数或者插入数据的操作都可能使得整个 MySQL 无法提供服务，这对于线上业务而言是不可接受的。</p>
<h2 id="离线数据中心的实现"><a href="#离线数据中心的实现" class="headerlink" title="离线数据中心的实现"></a>离线数据中心的实现</h2><p>在提出了「冷数据」的概念之后，我们意识到那些久远的历史数据其实需要存放到「冷数据」的数据中心池子里，而线上 MySQL 只需要保留最近一段时间的数据即可。另外，为了不改变现有项目使用数据的方式，降低数据库使用者的门槛，不管是对于线上数据库还是「离线数据」的数据中心，我们都需要兼容 MySQL 单表的使用协议。</p>
<p>很快我们就开始考虑 NewSQL 的方案，<a href="https://github.com/pingcap/tidb">TiDB</a> 很自然地进入了我们的视野，这是一个既可以兼容现有数据使用方式，又可以实现数据横向扩展的完美方案，但无奈搭建一个最小版本的 TiDB 数据集群的成本，相比于目前我们把它作为一个「离线数据」存储中心的角色而言，还是有一些偏高，而我们的存量服务也基本都是基于阿里云的，所以最终我们选择了阿里云推出不久的云数据库 <a href="https://www.aliyun.com/product/polardb">PolarDB</a>。其间我们还研究了很多其他数据库方案，比如 <a href="https://www.aliyun.com/product/drds">DRDS</a>、<a href="https://oceanbase.alipay.com/">OceanBase</a>、<a href="https://cloud.google.com/spanner/">Google Cloud Spanner</a>、<a href="https://aws.amazon.com/cn/rds/aurora/">Amazon Aurora</a> 等。</p>
<h2 id="数据同步和数据过期"><a href="#数据同步和数据过期" class="headerlink" title="数据同步和数据过期"></a>数据同步和数据过期</h2><p>有了离线数据存储中心之后，我们开始考虑如何把「热数据」转化为「冷数据」，同时也使得线上数据库可以自动过期超出时间窗口的历史数据。另外，由于内部可视化项目也希望看到实时的实况数据，所以离线数据最好也能很快获得最新的实况数据。</p>
<p>既然是两个 MySQL（集群）之间的实时数据转移，很自然的就想到了我们可以做类似主从节点之间通过 binlog 的数据同步机制，这个同步可以做到秒级延迟，在实时性上是完全可以接受的。不过这不能是简单的数据同步，因为离线数据是不能同步线上数据的过期操作的。更具体的，我们可以概括成：MySQL 从节点同步主节点所有数据增添和数据修改的操作，而对于数据的删除操作不做同步。</p>
<p>在调研之后，我们发现 TiDB 提供的同步工具 <a href="https://pingcap.com/docs-cn/v3.0/reference/tools/syncer/">Syncer</a> 可以实现这一点，我们只需要在配置注明过滤掉 DELETE 的 DML 语句即可，示例如下：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[[skip-dmls]]</span></span><br><span class="line"><span class="attr">db-name</span> = <span class="string">&quot;weather_data&quot;</span></span><br><span class="line"><span class="attr">tbl-name</span> = <span class="string">&quot;weather_now_history&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;delete&quot;</span></span><br></pre></td></tr></table></figure>

<p>而数据过期方案则可以直接借助 MySQL 本身的 EVENT 和 PROCEDURE 机制完成。首先我们可以创建一个删除数据的 PROCEDURE：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DEFINER<span class="operator">=</span>`weather`@`<span class="operator">%</span>` <span class="keyword">PROCEDURE</span> `weather_data`.`del_old_data`(<span class="keyword">IN</span> `date_inter` <span class="type">int</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">from</span> weather_data.weather_now_history <span class="keyword">where</span> datetime <span class="operator">&lt;</span> date_sub(curdate(), <span class="type">interval</span> date_inter <span class="keyword">day</span>);</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>这个 PROCEDURE 功能是删除 <code>weather_now_history</code> 表中 <code>date_inter</code> 天之前的数据。然后我们再创建一个 EVENT：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EVENT del_old_data</span><br><span class="line"><span class="keyword">ON</span> SCHEDULE <span class="keyword">EVERY</span> <span class="number">1</span> <span class="keyword">DAY</span></span><br><span class="line">STARTS <span class="string">&#x27;2018-12-25 10:08:35.000&#x27;</span></span><br><span class="line"><span class="keyword">ON</span> COMPLETION PRESERVE</span><br><span class="line">ENABLE</span><br><span class="line">DO <span class="keyword">call</span> del_old_data(<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<p>这个 EVENT 则会每天调用一次名为 <code>del_old_data</code> 的 PROCEDURE，并同时把 <code>date_inter</code> 赋值为 <code>30</code>。这意味数据库每天会删一次数据，使得线上数据库一直只保留最近 30 天的数据，而全量的数据是在数据写入时就实时同步到了离线数据中心，可谓完美。</p>
<h2 id="持续改进"><a href="#持续改进" class="headerlink" title="持续改进"></a>持续改进</h2><blockquote>
<p>All problems in computer science can be solved by another level of indirection.<br>—— David Wheeler</p>
</blockquote>
<p>上述的具体业务场景更多的还是 case by case 的解决了「热数据」和「冷数据」的分离和转化问题，这意味着方案并不具有普适性，以后我们遇到其他的数据库或者不同的数据使用场景可能就不再适用。另外，很多时候，「热数据」和「冷数据」的划分并不是那么明晰的，对于「冷数据」的需求有可能转变为「热数据」需求，我们需要可以灵活切换的机制，做到数据源只抓取一次（「热数据」和「冷数据」不要分别抓取），而抓取到的数据可以任意自由的流淌到「热数据」或「冷数据」线使用，这意味着我们在数据抓取和数据存储之间应该再做一层隔离。</p>
<p>要实现数据抓取和数据存储之间的隔离，我们可以采用「发布&#x2F;订阅模式」：简单说，数据抓取服务在获取数据之后将数据发布到消息队列，后面的存储服务任意订阅这个消息队列再做存储，这样数据源只需要抓取一次，我们可以把它作为热数据使用，也可以作为冷数据使用，甚至可以即作为热数据又作为冷数据使用，切换起来也十分简单。这是后续系统架构可以改进的一个地方。</p>
<p>另外，离线数据中心仅仅使用 PolarDB 对于我们可能产生的数据量级而言也是远远不够的，我们还需要更低成本的数据存储方案来存储时间更久远、平时几乎不大会访问的一些需要被「归档」的数据，这个时候，一些基于列存储的 NoSQL 数据库可能可以派上用场。</p>
<p>数据治理需要一个长期持续的过程，我们还在结合自身的业务场景不断的摸索当中。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/36112488">TiDB 在饿了么归档环境的应用</a></li>
</ul>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>热数据</tag>
        <tag>冷数据</tag>
        <tag>在线数据</tag>
        <tag>离线数据</tag>
      </tags>
  </entry>
  <entry>
    <title>东北的冬</title>
    <url>/2019/02/05/winter-of-north-east/</url>
    <content><![CDATA[<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2019/02/05/5c5981f5ee873.jpg"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2019/02/05/5c598233d3831.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2019/02/05/5c59825ebeeef.jpg"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2019/02/05/5c5982bbbc951.jpg"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2019/02/05/5c5982e2aac4d.jpg"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://i.loli.net/2019/02/05/5c59830583ea1.jpg"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2019/02/05/5c59829a17feb.jpg"></div><div class="group-picture-column"><img data-src="https://i.loli.net/2019/02/05/5c5983059de98.jpg"></div></div></div>

<span id="more"></span>

<br />

<p>图片已经过裁剪与压缩。</p>
]]></content>
      <categories>
        <category>视觉动物</category>
      </categories>
      <tags>
        <tag>Sony DSC-RX100</tag>
        <tag>东北</tag>
        <tag>雪</tag>
        <tag>林海</tag>
      </tags>
  </entry>
  <entry>
    <title>心知天气数据 API 产品的高并发实践</title>
    <url>/2019/05/09/high-concurrent-validity-4-api-in-seniverse/</url>
    <content><![CDATA[<p><a href="https://www.seniverse.com/">心知天气</a>作为国内领先的商业气象服务提供商，天气数据 API 产品从公司创立以来就一直扮演着很重要的角色。2009 年 API 产品初次上线，历经十年，我们不断用心迭代，已经为数百家企业客户提供了超过 540 亿次稳定可靠的数据服务。在心知天气<a href="https://www.seniverse.com/">官网首页</a>一直跳动的调用量数字就实时展示了整个天气 API 产品的服务状态。目前，心知天气数据 API 的 QPS 在高峰时期已经达到数千的量级，如何承载这样海量的并发请求，使客户能稳定及时的获取到所需数据自然也是心知技术团队一路以来不断探索的主题。</p>
<img data-src="/uploads/seniverse-index.gif" class="" title="心知天气 API 服务实时访问量" alt="图片显示错误">

<span id="more"></span>

<h2 id="访问量特点"><a href="#访问量特点" class="headerlink" title="访问量特点"></a>访问量特点</h2><p>天气数据的基本属性和客户本身的业务需求决定了客户来如何调用我们的数据接口。对于部分使用我们数据进行数据展示的 2C 业务的客户而言，访问量潮汐跟人的行为规律有着明显的相关性，这大致表现为白天比晚上并发量更高；而对于部分使用天气数据做数据分析和研究或者其他需要批量请求天气数据的客户而言，他们大多会选择在整点时刻来批量请求不同的数据，所以整点时刻往往会有突发的高峰访问量。</p>
<p><img data-src="https://i.loli.net/2019/04/18/5cb885ced4a0b.png" alt="API 数据服务访问量特点"></p>
<p>在叠加了不同客户需求的总体 API 服务的访问量，可以看出以下几个特点：</p>
<ul>
<li>以「天」为单位周期性明显</li>
<li>每天零点时刻并发量会激增</li>
<li>整点和半点时刻存在高并发小周期</li>
</ul>
<p>只有了解了我们客户的需求特点，才能设计出更合适的技术架构来应对随之而来的挑战。</p>
<h2 id="石器时代"><a href="#石器时代" class="headerlink" title="石器时代"></a>石器时代</h2><p>在创业初期，「云计算」的理念开始兴起，创始团队在斟酌优劣之后，选择将整个系统构建于云服务提供商<a href="https://www.aliyun.com/">阿里云</a>之上，如此一来心知天气团队也不必自己再手工搭建和管理需要的硬件资源，这对于创业公司而言是一个不错的选择。和大多数早期创业公司一样，囿于资源和技术积累，最早我们也是将 API 服务实例直接部署在<a href="https://cn.aliyun.com/product/ecs">阿里云 ECS</a> 之上，对外通过<a href="https://www.aliyun.com/product/slb">负载均衡 SLB</a> 提供统一的 API 入口。</p>
<p>随着心知天气数据服务体验的不断完善，客户数量也不断增多，API 服务所需要承载的流量也持续上涨。由于我们已经构建了上述这样的基础架构体系，在并发量最高的时期，我们需要手工维护高达 40 台左右的 ECS。而每个 ECS 上有自己独立但不完全一致的运行环境，不管是应对访问量突变还是部署新的版本，都无法做到比较快速的响应和执行。</p>
<p>在这个阶段，我们产品的 API 数据和逻辑都还比较简单，所有关于用户信息处理、位置服务和数据处理的逻辑都揉杂在一个单体服务中，最终部署时也是一个一个独立的单体式架构通过 SLB 共同对外提供服务。</p>
<h2 id="青铜时代"><a href="#青铜时代" class="headerlink" title="青铜时代"></a>青铜时代</h2><p>随着心知天气数据种类的不断增多，数据处理和 API 服务的逻辑也变得各不相同，比如城市级数据和公里级网格数据就有着完全不一样的处理和取数逻辑。在这种情况下，基于程序的可维护性考虑，我们很快决定根据数据处理逻辑的不同将数据服务拆分为几个不同的微服务，各自对外提供不同的天气数据 API。而为了复用取数之前的权限校验、访问量和各种日志统计的逻辑，我们开始引入网关系统。</p>
<p>API 网关最重要的是性能和稳定性要足够好，所有的 API 请求都需要经过网关。在通过网关的校验之后，数据服务负责获取需要的天气数据，其结果再通过网关返回给外部用户。如此一来，不同的几个数据服务退化成无状态的纯数据服务，即每个数据服务节点不再考虑任何与用户相关的逻辑，只是简单的根据请求条件将所有处理好的数据从存储系统中取出后返回，网关作为唯一的请求入口来统一处理所有的权限校验和访问量、日志的各种统计。</p>
<p>基于<a href="https://konghq.com/">开源的网关系统 Kong</a>，我们使用 Lua 进行了大量的二次定制开发，从而形成了心知天气自己的一套网关体系。这套系统不仅满足网关基本的路由逻辑，还能更好的处理和我们自身业务深度耦合的用户权限校验、访问量统计以及以用户为核心的日志记录。Kong 天生也是支持集群的，所以在理论上我们可以无限横向扩展网关的处理能力。</p>
<p>在这样的架构之下，心知天气的 API 服务很好的遵循了<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99">「单一职责」的原则</a>，使得我们的代码维护和版本更新都能以更快速且代价更小的方式进行。但另一方面，我们还是需要手工维护大量的 ECS 集群，甚至由于天气数据服务的多样化，手工维护多个不同种类服务的集群将面对更繁重的挑战。不过，由于我们将服务进行了更好的拆分和分层，变成了一个个更小的微服务，使得我们能把它们进行更好的分布式部署，进而可以横向扩展来提高整个服务集群处理并发请求的能力。这一阶段既是我们成功向微服务架构的转变阶段，也可以看作是我们迈向更现代的后端架构的过渡阶段。</p>
<h2 id="黄金时代"><a href="#黄金时代" class="headerlink" title="黄金时代"></a>黄金时代</h2><p><a href="https://pivotal.io/cloud-native">Cloud-Native</a> 的概念是 2015 年被首次提出的，随后就获得了技术社区的大量关注。顺着之前架构演进的思路，我们很快开始用 Cloud-Native 的理念来武装整个后端系统架构。在去年，我们正式开始用 <a href="https://www.docker.com/">Docker</a> 和 <a href="https://kubernetes.io/">Kubernetes</a> 来改造和管理我们所有对外的线上服务，这些架构设计同时也与阿里云提供的云服务深度结合。</p>
<p>从网关到数据服务，目前我们都已经完成了容器化的改造，并且所有服务都使用 Kubernetes 来编排和管理，这意味着我们真正统一了各个服务的运行时环境，从而可以快速复制出新的服务节点。借助 Kubernetes，我们现在可以做到容器级别的自动伸缩，在并发量高的时候服务节点能够自动横向扩展以提高整个集群的并发处理能力，进而可以给用户提供更加优质稳定的天气数据 API 服务。</p>
<p>不仅如此，基于 Cloud-Native 的理念，我们还统一了各个服务的 <a href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88">CI（持续集成）</a> 流程，优化了 <a href="https://zh.wikipedia.org/wiki/DevOps">DevOps</a> 的体验，做到所有服务的标准化和归一化 —— 从此以往，万物皆容器。这对于今后产品的持续高效迭代和改进，也是有重大意义的。</p>
<p><img data-src="https://i.loli.net/2019/05/09/5cd3d76bb42c6.png" alt="心知天气数据 API 产品的高可用之路"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>心知数据 API 产品历经十年，其后端架构也逐渐从传统的企业应用的开发模式转变为现代的 Cloud-Native 应用的开发模式，不仅极大的解放了团队的产品开发效率，而且能对外提供更加优质稳定的数据服务。心知天气从创立之初就带着鲜明的互联网风格，我们崇尚极客文化，技术团队也将继续带着勇于探索和敢于挑战的极客精神，用更好的技术与更优质的产品，为我们的客户提供更具价值的产品。</p>
<p><strong>【本文由多人协作完成，版权归<a href="https://www.seniverse.com/">心知天气</a>所有，转载需联系<a href="mailto:&#x68;&#x69;&#64;&#x73;&#x65;&#110;&#x69;&#118;&#x65;&#114;&#115;&#x65;&#x2e;&#99;&#x6f;&#x6d;&#x3f;&#115;&#117;&#x62;&#x6a;&#101;&#99;&#116;&#61;&#x6587;&#31456;&#x8f6c;&#36733;&#25480;&#26435;&#30003;&#x8bf7;">心知天气</a>获取授权】</strong></p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>系统架构</tag>
      </tags>
  </entry>
  <entry>
    <title>把 Airflow 搬进 Kubernetes</title>
    <url>/2019/12/03/develop-etl-via-airflow-on-k8s/</url>
    <content><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>稳定高效的进行数据处理几乎是如今每一家互联网公司都要面临的课题，尤其是对于<a href="https://www.seniverse.com/">专注于气象数据研究的我司</a>而言，做数据分析和 <a href="https://zh.wikipedia.org/wiki/ETL">ETL</a> 的工作是整个公司业务很重要的一部分。在脱离了原始的「刀耕火种」的时代之后，我们内部一直在使用 <a href="https://airflow.apache.org/">Airflow</a> 作为数据处理流程的框架来管理日常的数据流任务。其实我们也调研了很多其他的方案，最后还是选定了看起来相对比较可靠也比较符合我们业务需求的开源项目 Airflow 来做这个事情，虽然在使用的过程中确实也遇到了不少坑。当时这个项目还在 <a href="https://zh.wikipedia.org/wiki/Apache_Incubator">Apache Incubator</a>，目前已经顺利毕业了。</p>
<p>简单介绍一下 Airflow，一般由 WebServer（一套完整的 UI 界面用于随时查看任务的执行状态并可以手动执行一些操作）、Scheduler（用来做任务的调度和管理）、Worker（真正执行任务的部分，可能有很多个）组成。这是一个常见的分布式架构，你只需要把任务流的 <a href="https://airflow.apache.org/concepts.html#dags">DAG</a> 用 Python 代码写好，然后配置好触发条件就可以让它长期运行下去。在实际生产环境中，我们大量使用了 <a href="https://airflow.apache.org/howto/executor/use-celery.html">Celery Executor</a> 来把任务动态分布到多个 Worker 上执行。</p>
<span id="more"></span>

<p>如果数据处理任务长期不变，这样的系统已经可以满足我们的需求了。但实际上随着越来越多的数据任务被添加到整个系统，任务负载变得越来越重，很多时候固定数量的 Worker 已经不能及时的处理完被 scheduled 的任务，造成任务队列堆积，一段时间后如果一直不能改善负载情况甚至会拖垮整个系统。这种情况下，只能手动增加更多的 Worker 来分担任务处理工作。然后不同类型的数据处理越多，Worker 所需要安装的依赖也越多，每手工增加一个 Worker 的成本也越来越高。甚至对于气象数据的处理而言，有很多非常古老的数据处理工具（很多还是 Fortran 写的），经常出现依赖相互冲突的情况（版本冲突，编译通不过等等）。如何隔离各个任务之间的运行环境，以及如何根据负载需求动态的伸缩 Worker 的数量日益成为了这个系统的一个痛点。</p>
<p>动态伸缩，环境隔离，自然让人联想到 <a href="https://www.docker.com/">Docker</a> 和 <a href="https://kubernetes.io/zh/">Kubernetes</a> 这样的技术。好在 Airflow 1.10 版本引入了 <a href="https://airflow.apache.org/kubernetes.html">Kubernetes Executor 和 Kubernetes Operator</a> 允许为每一个任务创建新的 Pod 来处理，而执行完之后新创建的 Pod 会被清理掉，并且每一个任务都可以指定不同的 Docker image 来处理，这样看起来就可以完全解决我们前面的问题。</p>
<p>目前这部分功能似乎还很不稳定，官方文档和讨论都还不多，这篇博客也是为了记录下我们的踩坑过程。</p>
<h2 id="在-Kubernetes-上搭建-Airflow"><a href="#在-Kubernetes-上搭建-Airflow" class="headerlink" title="在 Kubernetes 上搭建 Airflow"></a>在 Kubernetes 上搭建 Airflow</h2><p>我们使用 <a href="https://helm.sh/">Helm</a> 来管理在 Kubernetes 上个各个应用以及它们的依赖，目前官方也已经给出了 <a href="https://github.com/helm/charts/tree/master/stable/airflow">stable&#x2F;airflow 的 Chart</a>，我们可以直接使用或部分参考。下面我们介绍一下从零开始的搭建过程。</p>
<ol>
<li><p>安装 Kubernetes</p>
<p>本地安装的可以选择 <a href="https://kubernetes.io/docs/tasks/tools/install-minikube/">Minikube</a>，主要它解决了跨平台的问题。我在 macOS 上使用的是 <a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac">Docker Desktop for Mac</a> 里<a href="https://www.docker.com/blog/docker-mac-kubernetes/">自带的 Kubernetes 集群</a>，如果你安装遇到了问题可以看看<a href="https://github.com/gotok8s/k8s-docker-desktop-for-mac">这里</a>是不是解决了你的问题，或者自行 Google 也可。</p>
</li>
<li><p>安装 Helm</p>
<p>Helm 3 已经是正式的稳定版本，可惜我们线上还在使用 Helm 2，而 Helm 2 的版本不兼容是没法使用的。为了跟线上保持一致，我本地也是安装的 Helm 2，所以后面都是以 Helm 2 的操作来执行的，第一次进行的朋友可以直接用 Helm 3。当然安装过程也<a href="https://github.com/helm/helm/issues/4730">很可能出现问题</a>，可以自行 Google 解决。</p>
</li>
<li><p>在 Kubernetes 上用 Helm 安装 Airflow Chart</p>
<p>直接根据<a href="https://github.com/helm/charts/tree/master/stable/airflow">官方的 Airflow Chart</a>步骤执行 <code>helm install --namespace &quot;airflow&quot; --name &quot;airflow&quot; stable/airflow</code> 即可在 Kubernetes 上安装一个标准的 Airflow 集群，之后可以查看各个 Pod 的状态是不是已经 ready（一切正常的情况下会在 <code>airflow</code> 的 Namespace 下安装 airflow-web、airflow-scheduler、airflow-postgresql、airflow-flower、airflow-redis）。还可以根据 NOTES 的提示在浏览器中查看 Airflow 的 UI 界面是不是也启动良好：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">NOTES:</span><br><span class="line">Congratulations. You have just deployed Apache Airflow</span><br><span class="line">   export POD_NAME=$(kubectl get pods --namespace airflow -l &quot;component=web,app=airflow&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)</span><br><span class="line">   echo http://127.0.0.1:8080</span><br><span class="line">   kubectl port-forward --namespace airflow $POD_NAME 8080:8080</span><br><span class="line"></span><br><span class="line"> Open Airflow in your web browser</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据自身业务情况自定义一些配置</p>
<p>之后可以根据 Helm 的 官方 Airflow Chart 提供的配置方式进行一些自定义配置，比如把默认的 Airflow 镜像 <code>puckel/docker-airflow</code> 替换成自己根据自身业务需求构建的（比如已经安装了实现业务需求所有必要底层依赖的 Airflow 镜像，或者对于 Kubernetes Executor and operator 必需的 <code>apache-airflow[kubernetes]</code>，这样就不用每次部署更新都安装这些依赖了）、更改 <code>executor</code> 的类型（我们改为 <code>Kubernetes</code>）等等。官方的 Chart 目录下也提供了<a href="https://github.com/helm/charts/blob/master/stable/airflow/examples/minikube-values.yaml">一个例子</a>可供参考。</p>
<p>值得额外注意的是我们如何做数据的持久化。这既包括 DAGs、日志 logs，也包括 Airflow 的运行态数据 —— 存储在 Postgres 或 MySQL 中的数据 —— 如何持久化。官方的 README 对此<a href="https://github.com/helm/charts/tree/master/stable/airflow#dags-deployment">已经有介绍</a>，同样如果有额外的自定义配置直接写到我们自己的 <code>values</code> YAML 文件中即可。<a href="https://github.com/apache/airflow/blob/1.10.6/airflow/config_templates/default_airflow.cfg"><code>airflow.cfg</code></a> 中 <code>[kubernetes]</code> 对应的每一项配置也应该过一遍并做相应的修改，尤其是关于 <code>namespace</code> 和 <code>dags_in_image</code> 的部分。对我司而言，我们自己的 Kubernetes 集群运行在阿里云上，直接使用一个外挂的 NAS 作为 DAGs 和 logs 的共享存储即可（通过 <code>extraVolumeMounts</code> 和 <code>extraVolumes</code> 挂载和声明，也要注意跟 <code>dags.path</code> 路径保持一致），以后我们自己开发的 DAGs 可以直接通过 CI&#x2F;CD 更新到 NAS 上相应的目录。数据库采用一个已经存在的外部 Postgres。</p>
<p>假设我们将自定义的 <code>values</code> 配置写成 <code>minikube-values.yaml</code> 的本地 YAML 文件，就可以用 <code>helm install --namespace &quot;airflow&quot; --name &quot;airflow&quot; stable/airflow -f minikube-values.yaml</code> 启动一个经过自定义修改后的 Airflow 集群（可以先把之前启动的集群通过 <code>helm delete --purge &quot;airflow&quot;</code> 清除）。</p>
</li>
</ol>
<p>因为业务需求和基础设施现状的不同，中间可能有不同的架构选择，但总体上经过这几步之后，一个采用 <code>KubernetesExecutor</code> 并运行在 Kubernetes 上的 Airflow 集群就基本搭建好了。</p>
<h2 id="开发-DAGs"><a href="#开发-DAGs" class="headerlink" title="开发 DAGs"></a>开发 DAGs</h2><p>参考 Airflow 官方文档中 Kubernetes Operator 的例子可以开发适用于自身业务需求的 DAG。之后就可以访问 Airflow WebServer 来开启相应的 DAG 任务，并观察集群中 Task 的运行行为是否与预期的一致，并逐步迭代。</p>
<h2 id="悄悄告诉你，真相其实是这样……"><a href="#悄悄告诉你，真相其实是这样……" class="headerlink" title="悄悄告诉你，真相其实是这样……"></a>悄悄告诉你，真相其实是这样……</h2><p>实际上，在经过我的一番折腾之后，最终我们线上使用的版本并没有使用官方的 Helm Chart，而是完全基于我们自己 build 的 Airflow 镜像，从头搭建了我们自己的 Helm Release Chart，这样整个系统拥有最高的可定制度（有些问题不在代码层面定制根本没法绕过去，下文有详述），同时也剔除了很多 Helm 官方 Chart 里有但我们不需要的东西。跟官方的 Chart 相比，我们主要做了这些更改：</p>
<ul>
<li><p>没有使用 Airflow 官方的 Kubernetes Executor，而是自己继承 <code>LocalExecutor</code> 类定制我们自己的 <code>KubeExecutor</code>，实际做的事情也很简单，就是实际在执行任务的时候不直接像 <code>LocalExecutor</code> 那样在本地执行命令，而用 <code>kubectl</code> 把任务指定在某一个 Worker Pod 或使用了 <code>KubernetesPodOperator</code> 启动的临时 Pod 里运行。这样做主要考虑的是官方的 <code>KubernetesPodOperator</code> 为了一些通用性功能从而进行了较为复杂的流程设计，我们团队自身完全可以结合在阿里云里 Kubernetes 集群的具体特点改造 <code>LocalExecutor</code>，这样不仅在运行时可以节省更多的机器资源，而且对于我们最核心的需求 —— 稳定的生产数据 —— 来说是更有利的，毕竟在运行时动态操作 Kubernetes 集群资源的流程变得简单了很多。</p>
</li>
<li><p>阿里云还有一个很大的坑是在它上面构建的官方 Kubernetes 集群产品不提供阿里云的 CA 根证书校验，而 <a href="https://kubernetes.io/docs/tasks/administer-cluster/access-cluster-api/#directly-accessing-the-rest-api-1">Kubernetes 官方明确指明了需要校验 CA bundle</a>，导致我们无法通过 API 与 Kubernetes Server 进行交互，进而在使用 <code>KubernetesPodOperator</code> 时会因为证书校验失败而无法创建 Pod。而 <code>KubernetesPodOperator</code> 也并没有提供参数让我们将 <code>verify_ssl</code> 设置为 False。所以最终我们也没有直接用官方的 <code>KubernetesPodOperator</code>，而是自己改了一个类似的把 <code>verify_ssl</code> 设置为 False 的 Operator 的版本来使用。同时这里也呼吁一下阿里云能按照技术社区标准来提供自己的技术服务与产品（我们提了工单 argue 这个事情，最终客服给我提供了根证书并叮嘱不要扩散，并不清楚阿里云不能对外公开根证书是基于什么样的考量；在其他项目中我们使用了客服提供的根证书来进行校验是没有问题的）。</p>
</li>
<li><p>去掉了不必要的通用型适配的各种选择，完全按自身需求合理定制。</p>
</li>
</ul>
<p>虽然我们做了定制，需要考虑的一些核心问题是没有变的，它们是：如何共享 DAG 的 Python 代码、如何做日志和数据库数据的持久化、是否使用 <a href="https://airflow.apache.org/docs/stable/concepts.html?highlight=xcom#xcoms">XComs</a> 来做 Task 之间的消息通信（同时在集群环境下如何实现这一点）、如何注入依赖（官方 Helm Chart 的 <code>requirements.txt</code> 方式）等等。由于这个尝试和定制的过程着实复杂和不那么让人愉快，甚至需要阅读一些 Airflow 的源码和各个云服务组件的接口参数设计，所以一篇博客无法一一详尽，我自己也不想写那些我们是如何绕过由于各方面的设计缺陷或开源产品不稳定导致的问题的技术细节，它们可能时刻会变，也没有技术深度，更多的是枯燥的云服务运维细节，所以不会在这里赘述太多而分散更大层面的宏观框架上的注意力。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在我们实际使用的过程中其实还遇到了很多 Airflow 的坑，作为一个 Apache 基金会的开源项目，它确实弥补了 ETL 场景下工具和框架的缺失，也提供了非常丰富的功能，不过尽管目前版本号已经到了 1.10.6，但还是有很多明显可感知的 BUG 存在，实际的使用感受是能用但总存在一些小问题，偶尔对任务的调度和管理还可能会失灵，不那么可靠，不算是一个高质量的开源项目，所以在使用时加上适当的重试机制是很有必要的。不过目前社区里在这部分并没有更好的替代品，Airflow 已经是我们考查过的最契合管理 ETL 流程的框架了。如果有新的开源项目能弥补这方面的空缺我们会很乐意去尝试，我们自己团队也在考虑是否在更长期的计划中开发一套自己的 ETL 流程框架。</p>
<p>几周不断折腾尝试的搭建、使用和实际开发的过程下来，其实涉及了很多开发<a href="https://pivotal.io/cloud-native">云原生服务</a>常用的 DevOps 工具和组件，比如 Helm、Kubernetes 和 Docker，能得心应手的使用这些工具需要一段时间的学习实践来积累知识和经验。要想在 Kubernetes 环境下玩转 Airflow，了解这些周边支撑的工具也是不可或缺极其重要的一部分。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Airflow</tag>
        <tag>Kubernetes</tag>
        <tag>Helm</tag>
        <tag>DevOps</tag>
        <tag>Cloud-Native</tag>
      </tags>
  </entry>
  <entry>
    <title>2019 年书单</title>
    <url>/2019/12/31/2019-booklist/</url>
    <content><![CDATA[<p>2019 年对很多人来说似乎是艰难的一年，在这个世界愈发趋于动荡和不信任的大背景下，越来越多的疑惑、迷茫和不确定性从上至下笼罩在每一个人可以感知到的日常生活中。或许只是一种周期，或许就是一种趋势，各种事物的分化与混乱变得越来越明显。如果从热力学第二定律的角度来看，维持事物不走向无序是需要额外付出很多努力的，那说明人类社会目前做的共同有效努力还不够；如果从唯物论的发展观来看，事物总是螺旋式向上发展的，周期中同时也蕴含着一些不可逆的改变。把 2019 年放在历史的长河中，我不知道它处在世界发展周期的哪个部分，但很可能不是在「好」（大部分人认为的世俗意义上的「好」）的那一半。这可能是前些年某些事件的发生导致了现在的局面，同时也可能是未来很长一段时间不同局面的开始。</p>
<p>我所感知到的 2019 年，不算好，但好过 2018 年，因为在 2019 年明显可以看到一些好的发展的希望。事情多不一定会让人感觉到累，但感受不到希望是一定会让人想要逃离的。不过，希望仅仅是一种未来往好的方向发展的可能，当变化越来越快的时候，希望也是越来越脆弱的，希望远不是必然。</p>
<span id="more"></span>

<p>忽视我以上开场想当然的臆测和主观感受，这依然是一篇书单。</p>
<ol>
<li><p><a href="https://book.douban.com/subject/27006467/">浮生六记</a>：★★★★</p>
<p>博客有一个分类是「浮生散记」，是出自沈复的《浮生六记》。</p>
<p>沈复一生困苦却用白描的方式把自己的故事一一记述下来，文采自然、平淡、真切，从中也可以看出他一介浪荡文人性格上的懦弱无能。</p>
<p>喜于与芸娘的几年四处游历、相濡以沫、互相扶持，悲在芸娘一生操劳、心思忧虑、英年早逝。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26997048/">撒哈拉故事</a>：★★★★</p>
<p>仅仅用一个略带嘲讽和贬义的「文青」来形容三毛或三毛的粉丝们是不公平的。三毛写的就是平凡的生活和真实的自我，在世界各地的每个人都有这样的生活，只是不是每个人都能够成为三毛，不是每个人都能写出这样的文字。热爱生活本身，已是足够。</p>
</li>
<li><p><a href="https://book.douban.com/subject/30455321/">流浪地球</a>：★★★</p>
<p>在看电影之前先看了原著，一个短篇基本把宇宙设定和故事框架搭建了出来，但这么点文字不足以支撑整个故事宏大的背景设定，所以人物、情节和要表达的背后的东西都很符号化。不过，也许正是短小且符号化的文学作品利于被 100 分钟左右的影视化表达所改编，如果是<a href="https://book.douban.com/subject/6518605/">《三体》</a>这样的长篇，要改编成一部（系列）成功的电影，难度会大上很多。</p>
</li>
<li><p><a href="https://book.douban.com/subject/6709783/">浪潮之巅</a>：★★★★☆</p>
<p>任何计算机和互联网从业者都应该读的一本书，前后几次再版的内容变化甚至都可以看出近几年行业的变迁与发展（之快）。</p>
<p>关于 Stanford 和硅谷之间的关系的章节尤其赞同，可以说国内所谓的高等教育还没找到门在哪里。</p>
<p>从整个行业历史长河的远景角度下来看，企业宿命论的观点是有道理的，创始人的特质基本上决定公司在世事变迁之中能走到多远。</p>
</li>
<li><p><a href="https://elixirschool.com/zh-hans/">Elixir School</a>：★★★☆</p>
<p>适合入门，但感觉比 Elixir 官网的 start guide 对知识的系统性和章节前后编排的组织合理性要差一些，优点是更偏项目实践，涵盖的面更广。</p>
<p>中文翻译有一些问题，给这个项目提了一些翻译方面的 PR。</p>
</li>
<li><p><a href="https://elixir-lang.org/getting-started/introduction.html">Elixir: Getting started guid + Mix and OTP guide + Meta-programming guide</a>：★★★★☆</p>
<p>官方文档绝对是入门 Elixir 的首选材料，内容编排和话题讲解都恰到好处又直击要害，完全值得多读几遍。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26910174/">上海堡垒</a>：★★★★</p>
<p>中学生科幻文学，前面多半部分是移动互联网时代之前的「高三」风格（比「中二」强一点），之后部分的行文流畅真切了许多，结尾还不错。在外星人入侵的弘大灾难背景下的朴素稚嫩而又执拗的少年情愫，科幻设定不硬，人物描绘质朴，倒是带来些许恍若隔世的违和感，跟江南在《此间的少年》中营造出的猎奇轻狂的趣味感一脉相承而又截然不同。</p>
<p>在同名电影上映之前先看一看原著，又是一部比《三体》更适合影视化表达的作品。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25816940/">富爸爸穷爸爸</a>：★★★★</p>
<p>认清资产和负债的确至关重要，这能让大多数普通人避开「中产阶级陷阱」。拿到当下现实而言，纯粹从财务的角度，那些签下 30 年贷款协议买房的人买下的绝不是资产而是负债。</p>
<p>每个人从大学毕业开始最原始的资产就是自己的工作能力和时间，上班本质上是出卖自己的时间和工作能力来获取货币资产。而财务自由的过程实际上是不断用新的资产形式来置换出卖劳动的过程，最终目标也就是即便不受雇工作也可以靠其他资产产生的收入来负担所有的支出，接下来就只需要不断的滚雪球就可以越来越富有。</p>
<p>一本经典的资产管理入门书，跟之前看过的<a href="https://book.douban.com/subject/26835090/">《软技能：代码之外的生存指南》</a>关于投资的内容遥相呼应、相得益彰。道理其实简单，但能做到的人永远寥寥。</p>
</li>
<li><p><a href="https://book.douban.com/subject/27204860/">指数基金投资指南</a>：★★★★</p>
<p>简直是手把手带领小白入门指数基金定投，有简单的理论也有实践操作，事无巨细，甚至包括了一些记账习惯、健康消费、投资心理等相关的内容，实用性强，内容也很诚恳，很适合零基础开始投资理财的读者。</p>
</li>
<li><p><a href="https://book.douban.com/subject/10471333/">叫魂</a>：★★★★</p>
<p>从小到大就不喜欢看历史书，觉得历史很枯燥，这大概是义务教育阶段历史教材上笼统的描述和专断的结论所熏陶出来的厌恶感。</p>
<p>但这本研究型作品却打破了历史的枯燥形象，看名字会以为内容是些鬼怪之谈，实际上这是一本非常严谨的学术著作。从乾隆年间的一场历史事件深度细腻的剖析了当时社会的状态和事件里各个社会群体及角色的举动和反应，最有意思的部分还是对舞台中央的君臣之间微妙关系的分析以及这背后所展现的官僚君主制的探讨。</p>
<p>作者作为外国学者，更是提供了一些在国内不常见的看待这段历史的视角，以及跟当时西方体制的一些对比分析，写得颇为生动精巧。一本上世纪写就的学术著作，如今看却也一点也不觉得过时。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25897187/">Elixir in Action</a>：★★★★☆</p>
<p>相信绝大部分人的第一门编程语言都不是 Elixir，那这本书就非常适合作为 Elixir 入门的读物。它没有陷于形式和细节，而是非常清晰的把 Elixir 核心和关键的部分由浅入深地勾勒了出来。行文逻辑和章节编排也非常合理，读起来流畅自然，体验非常舒适。简直是 Elixir 必知必会十三章。</p>
</li>
</ol>
<p>今年看的书并不多，但有两个我觉得比较有意思、有意义且也许会对我自己影响深远的事情值得写在这里。</p>
<p>其中一件是我终于汇总和总结了学习 Computer Science 的资源和路径，可以<a href="https://github.com/Maples7/cs-roadmap">在我的 GitHub 上找到这个仓库</a>。学习本身是一件非常私人且定制化程度很高的事情，就像<a href="https://en.wikipedia.org/wiki/No_Silver_Bullet">软件工程里没有「银弹」</a>一样，我从不觉得有适合每个人的最好的学习路径，但我把我觉得最好最合适的一些课程和书籍等资源列了出来。系统的总结出来这件事情本身在大学期间我就应该做了，这些年虽然没有在纸面上写下来，但也一直尽可能遵循这样的路径来系统的学习计算机科学的课程。不过没有纲领就容易丧失节奏，现在做这件事算是补交一下四五年前的作业，同时我自己今后也会更明确的按照这个列表来一步一个脚印的深入学习下去。这可是一个以「年」为单位来审计的大工程，我自己觉得很有意义。</p>
<p>另外一件其实我在<a href="http://maples7.com/2018/12/31/2018-booklist/">去年的书单总结中</a>提到了，但并没有明确说是什么事情。可今年的书单已经暴露了它是什么，那就是开始比较系统性地学习和实践个人理财和投资。大概是不到两年前的一个非常偶然的机会我开始接触并尝试投资这个事情，我才发现其实很多人（包括以前的我自己）都对个人理财和投资存在着大量的误解，这绝对是值得每一个年轻人深入研究的一个领域，而且越早越好，因为它几乎跟编程一样会以非常潜移默化的方式从根源上影响你今后的思维方式。我当然不会在这篇博客来详细说明这是为什么（或许以后会写一写），但我会在这篇年终书单来提四个现在的我认为的最重要的投资思维。投资思维并不仅仅只能用于投资，在很大程度上，它们可以用于个人参与社会生活的方方面面。在可以预见的今后一段时间内，这四个词都会成为我微信个性签名的一部分，以此来时刻提醒自己：</p>
<ul>
<li><p>价值：价值思维强调你需要深入事情的本质，这是最基础且根本的。研究一只股票，首先要看的就是它背后的企业在目前的基础上未来能产生的盈利价值。泛化来说，我们应该永远都回归事物的本源，用最根本最核心的内在逻辑来看待、思考和决策一切和我们相关的事情。能看到核心价值并不是一件简单的事情，但这必须是我们一直追求和崇尚的。放到一家公司来说，追求核心价值要求他们能持续将资源投入到能真正解决社会问题的事情上去，回归商业的本质，而尽可能不被一时的创业潮流和资本热度所左右。这个最根本的事情大多是公司为什么而创业的原因，也是一家公司存在的根本价值。在越是困难的时期，回归到真正的价值追求会显得愈发重要，因为在退潮时你才更容易看清之前水面下的到底都是些什么东西。</p>
</li>
<li><p>概率：概率思维是很多人严重缺失但又非常重要的一种思维方式，它能够告诉你没有什么事情是必然的，也没有什么事情是一定不会发生的。所有未来的事情在还没有发生的时候都是概率的，这些事情一起构建成为了「薛定谔的未来」。用这个思维来投资，它能帮助你在任何时刻准确的控制你的仓位情况，包括哪些投资标的和怎样的分配比例，同时也让你对任何未来可能的情况有所心理上的预计并做出计划和准备，在任何事情发生后都不会因为一时脑热、害怕或恐惧而做出错误的决策。错误的代价往往被低估，在投资的世界里尤其明显，不出错基本就已经可以在可量化的游戏里打败大多数人了，如何保证自己不出错是需要每个人思考的基本的问题。世界永远是概率的，这是目前唯一可以确定的事情。</p>
</li>
<li><p>长期：长期思维可以让投资者避免因短视而带来错误。人类往往容易放大眼前发生的事情带来的影响，而低估长期趋势在未来产生的作用。把孤立的事情放到一个长期变化的过程中去看，也更容易看到事情的本质。这也会成为你做出正确投资决策的基础：浮亏时，你能知道什么时候需要继续坚持，而什么时候要懂得及时止损；浮盈时，你能尽可能最大化自己的最终收益。人的一生对每个人而言也是一个长期的过程，不必因为一时的得失而或喜或悲，保持平常心对个人保持一个良好的日常状态非常关键，这也是我之前一直揣摩且追求的「个人 2016 年状态」。</p>
</li>
<li><p>非线性：非线性思维能让你避免用简单机械的方式来思考。不要觉得事情都是在简单线性发展的，不要认为努力就一定要成功且会成功，不要用静态陈旧的观念来看待和衡量周围的事物。这跟我在去年的书单总结中说到的「顿悟」的习得方式有共通之处。不要因为事情的突然失败、成功或发生而感到惊讶，有太多个人无法决定的偶然因素在相互交织产生影响，现实生活中真正复杂的系统一定是非线性的，这几乎同时暗示了物理世界「永远不存在绝对完美的事物」的残酷真相。</p>
</li>
</ul>
<p>理论终归只是理论，实践中很难做到完美，但完美依然值得追求。或许未来我的博客也会增加一个「滚雪球」的分类来记录一些我个人的投资感悟。</p>
<p>最后，站在这个看似艰难的 2019 年的尾巴上：愿世界依旧值得被好奇，愿自己依然能常怀热爱。我们一起来迎接人类下一个云谲波诡而又风景迤逦的十年的开始。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 年书单</title>
    <url>/2018/12/31/2018-booklist/</url>
    <content><![CDATA[<p>今年的个人状态要比去年好多了，好在心态的逐渐平和。毫无疑问，今年要比去年忙很多，工作和生活都是如此，不过事情也开始越来越聚焦，大概是一种越来越明白自己在做什么以及为什么要这样做的状态。</p>
<p>回到「书单」的正题。在<a href="http://maples7.com/2016/12/31/2016-booklist/">之前的年终书单总结</a>中，我说过一般用 iPad 看电子书，今年引入了一个新设备 —— <a href="https://www.amazon.com/All-new-Kindle-Paperwhite-Waterproof-Storage/dp/B07CXG6C9W">Kindle PaperWhite 4</a>（官方名称是 “All-new Kindle Paperwhite”），这是目前为止最轻的一款 Kindle。之前我一直不理解用 Kindle 看电子书比用 iPad 看电子书好在哪里 —— 忍受着上世纪电子设备的响应速度，使用着非常有限的功能，就为了墨水屏？不用不知道，在真正使用了 Kindle 之后我发现，所有的「轻薄」、「有限的功能」、「电子墨水屏」等特性，都是为了让你在阅读时更加专注 —— 避免打扰、减少疲劳感。从中我体悟到一个道理，任何细微而又专注于目标的优势都不应该被忽视，它可能是一个产品制胜的关键。Kindle 所有的设计都是为了「阅读」这一场景而设计，尽管 iPad 有着丰富得多的功能，但对于体验敏感的用户来说，在「阅读」这件事情上还是会为了用户体验而买一个 Kindle。细小而专注的优势，很重要，不仅仅适用于电子设备产品，也适用于每一件事、每一个人本身。</p>
<span id="more"></span>

<p>废话先不多说，还是按老规矩先列今年看过的书的书单。</p>
<ol>
<li><p><a href="https://www.zhihu.com/pub/book/19550356">设计之美</a>：★★★☆<br>前言写得是真好，整本书写得最好的部分也是前言。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26320659/">万物生长</a>：★★★★<br>冯唐的文字远比<a href="https://zh.wikipedia.org/wiki/%E7%8E%8B%E5%B0%8F%E6%B3%A2">王小波</a>的瑰丽绚烂，像被一个习惯了炒食堂大锅菜的师傅炒出的菜，加足了各种重口的佐料，分明就是他自己前不久写的那篇在朋友圈疯转的文章所说的「油腻」。<br>被称为「某某第二」的人永远不能成为「某某」，也永远达不到世俗意义上「某某」的高度，这一点，几乎是一条铁律。号称「王小波第二」的冯唐永远也成不了王小波，是因为他的文字看不到王小波能看到的东西，技巧十足，却没有让人想去细细揣摩的深意。<br>然而这个世界上没有谁需要去成为谁，冯唐不必易老，照样会让世界变得更丰富。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26943161/">未来简史：从智人到智神</a>：★★★★<br>第一部分基本是在重复<a href="https://book.douban.com/subject/26953606/">《人类简史》</a>的观点；第二部分写得比较有意思，把人文主义主导世界的现实情况剖析得鞭辟入里；第三部阐述了数据宗教的概念，基本也没有什么新东西。<br>预言未来当然比叙述历史要难很多，没有《人类简史》那么脉络清晰且具有说服力，不过书中的很多观点都是值得了解的。</p>
</li>
<li><p><a href="https://book.douban.com/subject/27085265/">北京，北京</a>：★★<br>「年轻人没了幻想，一不小心就俗了」；<br>作家要是没了追求，文字一不小心就俗透了。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25881855/">大教堂与集市</a>：★★★★☆<br>可以和<a href="https://book.douban.com/subject/26358448/">《人月神话》</a>一起看。<br><a href="https://en.wikipedia.org/wiki/Fred_Brooks">Brooks</a> 证明了「人月」在软件工程领域的非线性叠加性，而 <a href="https://en.wikipedia.org/wiki/Eric_S._Raymond">Eric S.Raymond</a> 则告诉我们「开源」大概是破局的唯一方式。<br>这部二十多年前写就的作品在如今看来也毫不过时，甚至书中的一些预言都一一应验。开源运动绝对是上世纪末以来黑客们最伟大的宗教活动。</p>
</li>
<li><p><a href="https://book.douban.com/subject/27070488/">围城</a>：★★★★★<br>钱钟书太厉害了，把人物形象简直刻画得惟妙惟肖，个个都像是生活中栩栩如生的样子。<br>一个围城，围住了中国人的人情、世俗、琐碎与人生的苍凉。<br><a href="https://zh.wikipedia.org/wiki/%E9%9F%A9%E5%AF%92">韩寒</a>的所谓<a href="https://book.douban.com/subject/24697636/">《三重门》</a>不及《围城》的 0.01%。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26663519/">MacTalk 跨越边界</a>：★★★☆<br>比前作的干货更少，也看得出对于书本身的内容而言所体现出的作者的野心更少，基本都是些日常感悟和书评。大概已经无需再考虑要证明什么，可以放开手脚写想写的东西。<br>在我所接触到的所有技术人的自媒体当中，不管技术如何，<a href="http://macshuo.com/?page_id=2">池建强</a>和<a href="https://www.zhihu.com/people/tchen/">陈天</a>算是文字写得流畅优美、可读性非常强的两位了。<br>作为枕边读物还行。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26997376/">我是猫</a>：★★★☆<br>简直就是夏目漱石的自嘲式自传。这本书在浮躁的时候是不能读的，只有在悠闲的时候静下心来慢慢跟随「猫」的视野，才能感受到作为一个旁观者的乐趣。跟《围城》的写作手法和主旨其实有一些类似，但可读性并没有那么高，独特的视角也是本书的特色之一吧。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26984868/">神奇动物在哪里（原创电影剧本）</a>：★★★★<br>看完电影再看剧本画面简直扑面而来，第一部无论是剧本还是电影都很不错啊，好奇<a href="https://movie.douban.com/subject/26147417/">第二部</a>的剧本到底是怎么样的，至少从电影的观赏程度上肯定不如第一部，当然也有可能第二部的定位就是为了挖大坑。<br>不过呢，出版的剧本其实并不是为了拍电影工作的原始剧本，而是根据已上映电影内容的再编辑，这样看估计出版的剧本也不会很好了。<a href="https://www.jkrowling.com/">罗姨</a>的确是应该找个专业剧作家一起合作啊。</p>
</li>
</ol>
<p>今年看完的书差不多就是这样了，另外我是那种齐头并进看多本书的类型，每天看心情选择一本想看的书，投入也开心。而书单只会列出在当年看完的书，那些可能看了一半的书不好评价故不在此列，有些书甚至可能会持续一两年还没看完，但最终基本还是会有所了结。以后我也会慢慢把所有在看的书都转移到 Kindle 上去。</p>
<p>2018 年年初其实制定了一个非常高难度的计划，实现了其中最核心的部分，我个人觉得是幸运且满足的。2018 年似乎也是一个大环境非常不好的一年，「经济衰退」、「资本寒冬」在 2018 年的冬季被各种媒体频频提起，这似乎让 2019 更加让我期待，因为那意味着更加强烈的变化。变化和起落才是世界的真相，而太多人对自我、对世界有太大的误解，对人性和环境有太高的期待，太执拗于自我而丧失了格局。这也是今年我自我感觉更成熟的地方之一，经历得更多也越来越包容，接受各种各样的不同、缺憾、丰富和可能性，但同时也有了更坚定的自我意识。</p>
<p>另一个今年值得一提的收获是开始探索了一个全新的领域并乐在其中，这也是一个很可能对人生有很大影响的领域。我一直推崇「顿悟」式的习得方式，因为大部分事后复盘看起来比较重要的「获得」其实都非常偶然，可遇不可求，不管这背后的原因是来自于你长期的努力和平时的积累、目前所到达的境界和眼界还是纯粹的运气，就在那一刻，不多不少，不紧不慢，你突然有所发现，打开了新世界的大门。这背后个人努力对最终结果起到了多大的作用，并不好说。「偶然」也是世界的一种真相和常态，很多人对此也有很大的误解。作为人类我们唯一能做的，只能是尽可能多的去了解一些不一样的东西，以求能更贴近真相一些。</p>
<p>2019 年，我希望我可以更纯粹、更极致、更理想主义，坚定自我，从心所欲，也用更开放的胸怀和包容的态度待人接物，年度书单还将一直继续下去。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>「必然」有多必然？</title>
    <url>/2020/05/19/how-certain-is-certain/</url>
    <content><![CDATA[<p>最近在看美剧《高堡奇人》（<em>The Man in the High Castle</em>）第四季，也是最终季。整个剧是基于 Philip K. Dick 的同名长篇小说改编的，也是这部作品创造了一种「架空历史」的新的科幻作品类型，剧情大致是基于纳粹德国和日本天皇打赢了二战，共同统治了世界之后的人类历史发展。值得一说的是，这部小说是 1962 年写的。作为 2020 的人类，我们早已习惯了第二次世界大战同盟国胜利之后的历史，但这部小说带给了我们这样一种思考，这种已经发生的历史是一种冥冥之中的「必然」吗？</p>
<p>当然，历史是经不起假设的，这个宇宙到底存不存在平行时空人类目前也不甚清楚。在这里，我并不是想讨论历史，也不是想讨论科幻，而是想讨论某个事件发生的必然性到底有多「必然」的问题。并不像大多数人以为的那样，人类的潜意识其实非常习惯于从某个结果来抽象总结出事情发生的原因，习惯于找出其中存在的一系列因果关系的逻辑链条而忽视次要因素，从而把事情化繁为简存储在自己的经验模型库之中。人性使然，已经获得成功的人也会不自觉的从自身的成功中总结经验并加以传授，告诉人们你们这样做也可以像我一样成功，这不禁也让人怀疑，成功学有必然性吗？</p>
<span id="more"></span>

<p>最近我还从<a href="https://zh.wikipedia.org/wiki/%E6%A2%81%E6%96%87%E9%81%93">梁文道</a>的播客<a href="https://shop.vistopia.com.cn/detail?id=4z4Ew">《八分》</a>的<a href="https://shop.vistopia.com.cn/article?article_id=vG_Cc">第 203 期节目</a>中听到这样一个故事（道长的这期节目本来是在探讨人性中善良的部分的问题），长篇小说<a href="https://zh.wikipedia.org/wiki/%E8%9D%87%E7%8E%8B">《蝇王》</a>讲了一群小孩被困荒岛在没有成人引导的情况下如何建立起一个脆弱的、充斥着野蛮与暴力的文明体系的故事，基本是社会达尔文主义的荒岛实验版本，充分揭露了人性中的恶。小说是虚构的，然而<a href="https://zh.wikipedia.org/wiki/%E7%91%AA%E6%A0%BC%E9%BA%97%E7%89%B9%C2%B7%E7%B1%B3%E5%BE%B7">人类学家 Margaret Mead</a>在《Humankind: A Hopeful History》中却写了一个真实的有类似情境却完全不同结局的故事：六个偶然迷失在无人岛上的小孩通过合作、民主、和平的方式生存下来活了十五个月的故事。Margaret Mead 企图用这个真实的故事说明人类本性中除了有自私的天性以外同时也有一种互助友爱的天性。但以此就可以推翻虚构的小说《蝇王》所描写的那个故事的可能性吗？人类是一种相当复杂的动物，我们既能看到《蝇王》小说中的恶，也可能看到如童话般的善，真实的人类社群更是一个庞大的复杂系统。</p>
<p>所以已经发生的「必然」到底多必然？</p>
<p>有无数的历史教材告诉我们历史中某些重大事件的发生是某种趋势的必然结果，彷佛世界的发展有一张无形的手在推动着前进，我们也无数次听到「即便现在某个人&#x2F;某件事不出现&#x2F;发生，这样的历史时刻&#x2F;趋势&#x2F;潮流之下也会诞生另一个某某人&#x2F;发生同样的某某事」这样类似的说法，彷佛条件到了该来的一定会来。人类自古以来就希望拥有预测未来的能力，玩狼人杀拿到预言家的身份都会精神几分，从进化心理学的角度，这本质上源于人类对不确定性的恐惧。每个人都希望生活在稳定安全的环境之中，如果能有效预测未来，则可以为即将发生的事情做好万全的准备从而获得对自己有利的条件。</p>
<p>不言自明，预测肯定是基于当下的现实来产生的，是基于此时此刻这一秒的全部已经发生的现实，来预测未来某个时刻将要发生的现实。首先，没有人可以同时了解到此时此刻的全部现实，即便我们假设现在可以采集到所有的现实数据，那接下来发生的事情就可以预测了吗？仔细思考，你会发现这里存在一个悖论，即未来被预测这件事情会不会影响对未来的预测。按理说，预测未来这件事同样也是当下的现实，应该也会对未来事件的发生产生影响。所以准确预测未来还可行吗？不得而知，我无法给出任何可信的答案或思考。回到现实，既然准确的未来还无法预测，那预测出事件的大致走向&#x2F;趋势&#x2F;潮流是不是可行呢？</p>
<p>各个行业中都有一些传奇励志的成功故事，互联网创投圈中更是如此，都说互联网是个年轻人的行业，有众多年轻的互联网新贵因为把握住了行业发展的潮流和趋势年纪轻轻就已经实现了很多人追求的所谓财务自由。那么，他们真的是因为提前看到了趋势和机会才成功的吗？当然，不排除真的有人有意识且主动地看到了趋势和机会，但肯定也有不少人主要是凭借运气做成了某件事情（在其他条件相同的情况下，这包括主观能动性的程度）。更进一步的问题是，能看到趋势和机会是因为什么？这其中又有多少偶然和运气呢？</p>
<p>当然，同样地，我们也不能陷入到一种虚无主义和怀疑论的情绪当中去。人类世界是一个混沌的复杂系统，事情之间环环交织，它们一起构成了一个已经发生的当下的「偶然」，一部分相互交织的「偶然」子集又相互作用和相互影响，为下一个「偶然」的发生提供作用和条件，而我们的主观能动性，同样也是其中的一部分「偶然」，同样对事件的发生产生影响。由于股票市场是不可预测的（这基本也反映了现实世界的不可预测性），很多价值投资者都崇尚用「概率」和「非线性」的思维方式来思考问题，从而通过更合理地布置仓位和设计操作策略来实现最终的盈利。我们在实际生活在也可以学习这种思维模型来应对不可预知的未来世界，首先要充分认识到世界的不可预测性并基于真实世界没有简单的因果关系的前提，不要用简单机械线性的思维和视角来分析问题，这样可以减少一些偶然被你感知到的噪音对你的影响，从而总是能依据自己的理性判断对不同概率下的可能的未来做出符合可能性的准备，进而做出一个当下最优的决策。</p>
<p>2020 年是一个太不平凡的一年，突如其来席卷全球的新冠疫情、本身已经变得脆弱的世界政治经济局势等等，人类似乎又站在了一个暴风雨的前夜，你能预测世界接下来的走势吗？</p>
<p>我想我是得看一些关于复杂系统理论的书了。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>必然</tag>
        <tag>哲学</tag>
        <tag>复杂系统</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 年书单</title>
    <url>/2020/12/31/2020-booklist/</url>
    <content><![CDATA[<p>2020 年，是一个太魔幻的一年（什么？你不知道为什么会这么说？好吧，如果你来自未来，本文末尾有一期推荐的播客可以听一下），甚至很有可能还是「魔幻元年」。那句话怎么说的来着：今年是过去十年最差的一年，却可能是未来十年最好的一年。当然，认真地讲，我并不完全赞同。不过要是说世界的节奏和变化速度越来越快，我是要默然颔首的。</p>
<p>其实这一篇本质上有标题党的嫌疑，因为今年看的书实在太少太少，当然后面我也会解释今年看书少的<del>借口</del>原因。不过，看过<a href="http://maples7.com/tags/%E4%B9%A6%E5%8D%95/">我前几年「书单」</a>的你肯定也知道了，我的书单系列只是用「书单」作为切入口，以此为契机来定期来聊聊我对这个世界的看法而已。虽然我也有要时常更新我的博客的想法，但事实就是总有一些手头上新奇的、或者我认为更重要的事情占据着我的时间，以致于目前这里几乎成了一个年更博客，这确实很不应该。但好在我依然还有年更「书单」这个保留节目。</p>
<p>Anyway，这依然首先还是一个「书单」，所以我们还是会从正题开始。</p>
<span id="more"></span>

<ol>
<li><p><a href="https://book.douban.com/subject/34838232/">新婚之夜</a>：★★★★☆</p>
<p> 不得不说，我很喜欢这几个中短篇故事，我觉得这才是真正给现代人看的文学作品。作者把细腻的情绪和世界的真实都潜藏在故事情节里，「给残酷的内核外面涂一层奶油」，以至于我会觉得在北京这样的城市路上遇到的每一个人背后都可能有一段类似书里描绘的故事。推理和悬疑的要素也大大增强了故事的可读性。</p>
<p> 第二篇《模特》也看过 2019 年扩展的中篇电子版，故事叙述方式和人物刻画都比出版的这一版明显更好。</p>
<p> 很喜欢作者讲故事的风格，如果长期坚持写作，应该很有潜力能写出更优秀的作品。</p>
</li>
<li><p><a href="https://book.douban.com/subject/5354957/">扶桑</a>：★★★★</p>
<p> 整个故事的结构和完整性都还不错，也比较有新意。从叙事人的视角来讲这个故事我觉得是个加分项，给了这个故事更多的现实寓意和文化内涵。整个读下来，前面部分会感觉略微零碎而不够畅快，但后面慢慢把拼图拼起来之后会觉得这确实还是一个好故事。</p>
</li>
<li><p><a href="https://docs.python.org/3/tutorial/index.html">The Python Tutorial</a>：★★★★☆</p>
<p> 自从大学期间看完《Dive into Django》和《Learn Python the Hard Way》之后，中间间隔了很长一段时间没有再使用 Python，几乎已经忘得差不多了。尽管在近两三年的工作中又有几个 Python 数据处理相关的项目，但总感觉自己在 Python 方面的理解还不够系统，所以打算再系统的学习学习，同时也看看一些新特性。任何编程语言的官方文档总不会太差，如此大众的 Python 自然也不让人失望，任何想入门的人都可以且应当从这篇文档开始作为学习的内容之一。</p>
<p> BTW，大体上我不赞同 learn something the hard way 的学习方式。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26752026/">聪明的投资者</a>：★★★★</p>
<p> 堪称价投宝典，虽然很多具体的事例都已经过时，但投资的大道却永远不过时（主要是第 1、8、20 章），同时这个版本的点评章节也很好的弥补了这方面的不足。投资的确是个体认知能力和认知水平的直接变现行为。</p>
</li>
<li><p><a href="https://book.douban.com/subject/27614523/">刷新：重新发现商业与未来</a>：★★★☆</p>
<p> 入职微软之前看完了这本书，写得很朴实。从个人经历来说，并没有过分强调自己的努力和付出，也准确表达了顺应趋势在对的时间出现对的地方的重要，同时家庭经历的曲折带给了他更多对于同理心的思考；从公司的层面来说，坦诚微软在当时需要一次文化变革，重新刷新自己，目前看来确实正在扭转颓势；最后谈了谈对未来技术的认识，跨国企业应当是有全球视野和使命感的。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25910559/">剑指Offer：名企面试官精讲典型编程题</a>：★★★★</p>
<p> 根据我面试别人和被面试的经验来看，这本书包含了一个合格程序员应该掌握的容易被总结和教材化的基础知识和技巧，针对很多公司已经套路化的面试流程而言的确是有效的。但它依然只是《骗分导论》一般试图突击走捷径的存在，不能作为修炼编程内功和计算机科学素养的考纲。仅对于找工作来说，是必要不充分条件。</p>
</li>
<li><p><a href="https://msl.overdrivechina.cn/media/5690793">Learn .Net Core: .NET Core Tutorial</a>：★★★</p>
<p> 一本非常短小的小册子，适合有其他语言编程经验的人熟悉 .NET 世界的 basics and fundamentals，以图一两天快速建立一个整全观。基本没有什么更深入的细节。</p>
</li>
</ol>
<p>没了。</p>
<p>如前面提到的，今年看书时间不多的<del>借口</del>原因大概来自于这样几个方面：</p>
<ol>
<li><p>换工作和城市，入职微软中国（苏州）。</p>
<p>从更新简历开始，到投递面试、确认 Offer、从北京离职，最后跨城市搬家、入职、新员工培训、自学一些相关的技术等等，这其中每一个步骤都需要耗费大量的时间和精力。而且微软是我目前为止遇到的入职流程最漫长的公司，毕竟其中的背景调查就耗费了三周到一个月的时间，处处显示着跨国大公司的规范与严谨。如果以后有机会，我也可以在博客或其他社交平台上分享更多在微软的经历。</p>
<p>舍弃旧的环境和已经熟知的工作流程、技术规格和项目，从零开始投入到一个全新的体系里，有太多的新东西需要学习，这不仅仅包括作为开发者所必须掌握的技术相关的知识（在微软 C# &#x2F; .NET 对于大多数开发者都是必须的，而在此之前我接触得并不多），还有一些事关企业文化、规范、工作流程和团队协作上的软技能的准备。而在像微软这样一个历史悠久的跨国企业里，项目和用户规模都十分庞大（意味着对项目稳定性要求格外高而无法快速变化），项目历史也十分悠久（十几二十年的代码，legacy code 不少），对于这些已经世界级的产品，想要短时间内掌握清楚基本不现实。我的 manager 就曾告诉我，新入职员工基本都需要经过一年到一年半的时间才能对项目上手，这本身就是一个不小的挑战。</p>
<p>所以更多的时间还是放在了跟工作内容相关的知识的学习上，这不是几本书就可以简单概括的。</p>
</li>
<li><p>东航「周末随心飞」。</p>
<p>一场突如其来的传染性肺炎疫情让所有人都猝不及防，航空公司们为了自救而推出了「随心飞」这样的产品，首先从东航的「周末随心飞」开始。在今年这样的情形下，对于航空公司来说这确实是一招不错的棋，而对于大部分产品购买者来说其实也并不亏。所以借着这样的契机，同时得益于微软讲究 work-life balance 的工作节奏和假期福利，今年我也着实好好<del>在国内到处蹦跶了一下</del>领略了一把祖国的大好河山。最值得一提的当属十一假期前后去了西北一线，包括银川、兰州、青海大环线的南半边、可可西里，确实看到了极其壮阔瑰丽的大漠景观。除此之外，还去了潮汕、长沙（两次）、西安、三亚、济南，也是一年难得的经历。</p>
<p>为了不辜负路上的美景，今年还购入了无人机和微单来作为拍摄器材，<a href="https://maples7.tuchong.com/">拍了不少照片</a>。我想，要彻底消化完我这个重燃的新兴趣点也是需要不少时间的投入的。</p>
<p>所谓「要么读书，要么旅行，身体和灵魂必须有一个在路上」，至少今年身体还在路上。曾经为了让自己能多出门走动、不要太宅，也制定过「希望自己周末一半的时间能出门」这样的年度计划，至少今年应该是实现了这个前几年的想法。</p>
</li>
<li><p>上完了<a href="https://cs50.harvard.edu/">著名的 MOOC Harvard CS50x</a>。</p>
<p> 这门课其实我在大学时期就上过一部分。虽然只是哈佛的一个计算机相关的通识基础课，但由于制作的实在太好，内容又相当丰富，我不忍心这么好的课程自己没有全部看完，于是在今年又从头到尾全部过了一遍。尽管对于我这个从业者来说没有什么新鲜的「干货」，但它却是我上过的体验最好的 MOOC。除了哈佛的明星教授 David Malan 精彩的授课讲解，也有制作得非常有层次的课后作业，最后的大作业甚至是独立开发一个完整的应用，这是少有的让我觉得参与起来非常有意思的一门课。实际上，这门课已经成为了一个独立的品牌，有一系列相关的网站、后续课程和工具集供你在 CS50 的海洋里遨游。所以也建议开发者或者对计算机知识感兴趣的人去听听这门课。</p>
<p> <a href="http://maples7.com/2019/12/31/2019-booklist/">去年的「书单」</a>我就提到了<a href="https://github.com/Maples7/cs-roadmap">我整理的学习 Computer Science 的资源和路径列表</a>，这门课目前就是我列在 Fundamentals 类目下第一位的课程。所以上完这门课也是我遵循去年立下的深入系统有节奏的学习世界顶尖的计算机相关课程的计划之一。这其实也比简单看完几本书需要花费更多的时间和精力。</p>
</li>
<li><p>外部环境、事件的影响，包括新冠疫情。</p>
<p> 说 2020 年是不可能脱离新冠疫情这个大的背景调查来谈的，它已经成为了 2020 年的标签和底色。疫情在今年或多或少的影响了地球上的每一个人，外部环境的剧变需要每一个个体有更加坚定的自我才能在自己的道路上继续走下去。我以前就写过，环境对人的影响往往被低估，相信今年的情况提升了很多人对于环境影响的认知。它或许不能完全左右你的方向，但绝对可以让你的每个动作都充分扭曲变形。这历历在目的一年，相信身处其中的每个人都深有体会，无须多言。</p>
</li>
</ol>
<p>其实从个人角度来说，今年对于我自己算是不错的一年，因为它足够丰富，这主要来源于在微软工作我会有更多时间投入到各种各样不同的我想要投入的事情上去，比如写一些自己想写的代码，比如对新技术的学习、投资领域的深入、其他兴趣爱好的培养等等。往年的「书单」或多或少我都会夹杂着一些「湿货」，以阐述我的世界观的某个部分，但今年这篇我想就保留这样简单平实的记述风格。已经是太不容易的一年了，就给我自己和看到这篇的你留个气口吧。</p>
<p>另外感谢 12 月有 31 号，让我还有充分的时间来完成这篇「书单」。最后，强烈推荐看到这里的你静下来听一听声动活泼旗下的这期播客：<a href="https://mp.weixin.qq.com/s/IBp5eQ8kggFyi6Egq4VnIQ">《请收下这枚记录2020的声音时光胶囊》</a>。</p>
<p>「历史就算会反复，但一定会向前走的」，2020 年是需要很多感性力量的一年，现在我们又来到了一个新的时间节点，故事还将继续，只愿世界和平。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>在望京，没有方向</title>
    <url>/2021/12/08/no-direction-in-wangjing/</url>
    <content><![CDATA[<p>北京的初雪天很冷，却总能给人一种充满希望的感觉。雪一下，北京成了北平，茫茫的白色也成了一系列盛大节日的暗示。会来事儿的商家会早早在店面上添上一抹红，本来素朴的街道氛围一下就上来了。不管你白天因为工作上的什么事情而烦恼，在天刚黑的下班路上，都是一段最佳的放空自己的时间。宽阔的街道上一如继往的车水马龙，迎面的车道闪过一道道晃眼的白光，正向车道的红尾灯连成一片红色光带。是很堵，但人们都失去了一些平凡日子里的暴躁。当然，这很可能是前面路口交警的功劳。</p>
<p>北京远不是一座浪漫的城市，现实的引力会牢牢的吸住每一个人，不让大家离地面太远。不仅不浪漫，甚至还很土气（「土」并不天然意味着「不能高档」和「不能高级」），然而这种「不浪漫」也正是这座城市吸引人的特点之一。生活会奖励真实，这里的每一个人都受其馈赠。望京当然也逃不过这引力。</p>
<span id="more"></span>

<p>没有二环内胡同大院的庄严古朴，没有三里屯的时尚摩登，也没有中关村的高知气息，望京在这样的北京城的东北角里，显得很普通。硬要说有什么不同，那大抵就是望京的路了。不同于北京大多数地方笔直朝向的道路，望京的路成了这些「笔直」的弯曲黏合部。沿着望京的路慢慢走，不知不觉你就偏离了原本的方向。这当然算不上什么望京「有名」的特色，但你也难忽略这件事的存在。</p>
<p>普通的望京却没有普通的人，这样说其实不对，每一个在北京浮沉的人都是不普通的，跟望京没啥关系，望京依然还是那样普通。在路上的每一个人，都有可能有一段引人入胜的故事。这是一个爱听故事的人的天堂，要是你还有酒，那或许可以换到很多色彩斑斓的故事，或者不需要酒，那你得成为一个健谈的的士司机。但是，在某种程度上，这里的每个人又都是普通的。无论你曾经经历过什么，在这样一座偌大的城市里，你都能找到跟你有类似经历的人，没有人是完全独一无二的。</p>
<p>望京可以算是目前北京城人口密集区的最外围的一个据点了，再往外走，选一个秋高气爽的日子，你就可以在北京郊区的农家小院里度过一个惬意的周末。当然，前提是你没有在望京迷失出城的方向。</p>
<p>在望京，不仅没有方向，也没有音乐。当然，开出城区之后是有音乐的，但一回来望京就没有了。你可以在这里听到各种各样的旋律，但这里没有音乐。没有音乐人就很难拥有灵魂。</p>
<p>也许望京有一种神秘的神奇磁场，每一个进入这片场区的人都在不知不觉中丧失了对自我、对生活的敏锐感知力。每个来这里的人都带着天然的对生活的期待，目标明确，反而慢慢地在一天又一天的循规蹈矩中迷失。中关村或许承载着人们更强烈得多的期待，但那里的人们在一天天的忙碌背后也会关注生活，或许是周围的校园气息对这种蓬勃的欲望起到了中和的作用，反而让其不仅有朝气活力的气质又能有随时静下心来的感知。</p>
<p>望京大抵是少了点什么东西。</p>
<p>在望京，务必带好你的罗盘再出发。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>创业</tag>
        <tag>北京</tag>
        <tag>望京</tag>
      </tags>
  </entry>
  <entry>
    <title>创业的准则</title>
    <url>/2021/11/19/principles-4-startups/</url>
    <content><![CDATA[<p>对于普通的立志于在互联网行业有所作为的大学毕业生而言，选择去大公司还是去创业公司工作一直是一个没有标准答案的问题，不同的人适合不同的道路。而另一个更艰难的道路就是自主创业。我毕业这几年，正好集齐了在创业公司、国内中型民营公司和跨国大公司的工作经验。总的来说，在创业公司的工作是其中目前为止最长也非常可圈可点的难忘经历。这篇文章根据我在创业公司的经验和自己平时对于市场的思考总结而成，是我认为创业应当遵循的创业的准则，不一定正确也不是一个系统完整的阐述，个人观点，仅供参考。</p>
<span id="more"></span>

<ol>
<li><p>找最优秀的人一起工作。</p>
<p> 这里的「优秀」不一定得是具体业务上已经最厉害的人，但一定是有潜力成为最厉害的人的人。优秀的人能给公司带来的长期价值是难以用一朝一夕来衡量的。除了完全能胜任本职工作的基本能力以外，优秀的人不仅能对整个团队的建设产生积极的影响，更重要的是，他们往往能跳出传统的思维和各种条条框框的限制来看待具体的问题，提出创造性的解决方案，给整个团队创作难以估量的价值，而这些价值很可能成为决定创业公司走向和存亡的关键核心优势。</p>
<p> 当然，有潜力的人是需要时间和空间来培养的，而创业公司相比于中大型公司往往更容易营造这样肥沃的土壤。优秀的人能持续学习，跟随公司一起成长，互相成就，达成共赢。创业公司在人才方面存在越多这样的良性循环，就越能走得更长远。</p>
</li>
<li><p>宁可不做，做就要用对的方法做对的事情，不要用错误的方法做事。</p>
<p> 明星技术创业公司 TiDB 的 CTO 黄东旭有一个观点我很赞同：Make it right before making it fast。朝着正确的方向做事永远是所有具体决策的大前提。创业公司本身所拥有资源是很有限的，只能用有限的资源发挥更大的效能才能跑赢更大型的公司。这一点其实对创业公司的领导者提出了很高的要求，这要求他们能够有足够的预见性和前瞻性，能够充分吸收外部市场上各种各样的信息做出正确的决策。</p>
<p> 有的人可能会认为「快」比「正确」更重要，我并不这样认为，或者说，这中间需要一个平衡和取舍。有一种常见的说法是创业公司能够快速试错从而能比大公司更灵活的「转身」。这一点在已经做出错误决策的情况下是正确的，所以正确表述应该是「创业公司能够比大公司更快速的扭转错误的方向」。可是我们为什么不追求从一开始就尽量不做出错误的决策呢？用俗话说就是，不要用战术上的勤奋掩盖战略上的懒惰。创业公司领导者需要花更多的时间思考公司的战略和方向而不是整天呆在公司扣一些细枝末节（当然，并不是细枝末节不重要，而是战略方向要更重要得多）。一定要记住一个大前提，创业公司所拥有的资源是非常有限的，所以试错的机会成本其实比大公司要高得多。大公司完全可以拆出数十倍于创业公司的资源来试错不同的决策方向和选择，而创业公司失败一次就足以让团队元气大伤。优秀的团队成员可能可以给公司的效率带来很大的提升，但错误的决策方向落地执行下去不仅是对客观资源的一种浪费，也是对人才的一种伤害。</p>
<p> 所以「正确」比「快」更重要，宁可不做，做就要做对的事情，并且用对的方法来做这件事。</p>
</li>
<li><p>在没有划时代的技术优势时，产品的成功是所有细小正确决定优势的累积。</p>
<p> <a href="https://www.thoughtworks.com/radar">Thoughtworks 有一个广为流传的技术雷达的观点</a>，但真正能划时代的技术其实是极其稀少的，而每一个关键技术的突破，都可以带来一波技术红利的浪潮，持续数年。现如今，上一波移动互联网的浪潮早已远去，下一个能来带技术爆炸的计算平台到底是啥还未可知，可能是实现完全无人驾驶技术的新能源汽车，也可能是 Facebook 刚提出的所谓「元宇宙」虚拟网络空间，总之还没有确定性的答案，而过早涉足这些技术的创业公司大概率也会成为时代的炮灰。然而在已经成熟的技术领域里挣扎似乎又早已没有可以创新的空间。</p>
<p> 我上一段在创业公司的工作经历所做的产品就是在很传统的领域，很难打破传统行业的桎梏做出颠覆式的创新。所以产品想要在公开市场上取得成功几乎只能取决于所有细小正确决定优势的累积。就好比你在 2021 年的今天做一个手机 App，你已经很难找到无人想到的新的创意来填补市场上的空白，存量竞争的时代只能靠产品上累积的细节和局部的优势来来取得竞争优势。这些优势可能是更少的 bug、更好看好用的 UI&#x2F;UX、更人性化的布局和设计、抑或是能支撑产品决策的更成熟深刻的理论基础。关注细节、关注每一个微小的决定，在这种技术周期的浪潮下是重要的。</p>
</li>
<li><p>用产品和技术而不是营销手段说服用户。</p>
<p> 在产品没有打磨好之前，不要使用任何刻意的营销手段。这样做只会提前消耗掉未来可能成为优质长期用户的市场耐心。真正的好产品，靠自然流量和口碑传播也终能被市场认可，但在市场快速变化的今天，在产品打磨好之后，使用营销手段可以加速从 1 到 N 的过程，快速占领市场份额，建立自己在这方面的护城河。</p>
</li>
<li><p>建立制度，然后让更多的人自己做决定。</p>
<p> 有团队的地方就需要有制度，制度是团队文化的具体化，文化通常可能带有创始人强烈的个人色彩。但不管怎样，因为人的差异性，制度是需要的，而在制度建立之后，具体的与每个团队成员相关的决定让成员们自己做选择（尤其是小团队的时候，吸纳优秀的人进团队，再充分信任每一个团队成员）。只有这样，才能真正在团队范围内做到文化与行为的一致性。比如，现在很多互联网公司都会实行弹性工作制，如果这真的是创始人所认同的工作制，那么我们可以建立弹性工作的制度，同时要求每天基础的工作时长，那么具体每天的工作时间段则交给团队成员自由选择；如果创始人并不真的认同这样的制度，即便口头上声明你们是弹性工作制，长期下来的言行不统一也会让团队成员逐渐丧失对这个团队的信任，相互之间变得不再坦诚；而如果创始人认为就应该是白天固定时间段的工作制更符合团队工作效率的要求，那么制度就是固定工作时间制，而不要声明的与实际的有出入。修补制度上的漏洞，直到让大多数人尤其是创始人达到一个舒服的状态，而把具体事项的决定权交给充分被信任的每个人。</p>
<p> 本质上，这其实是约束与放任的平衡哲学，建立制度就是建立约束，而让每个人做与自己相关的决定就是给予成员选择的自由。这样充分打磨下来的团队才能稳定持续走得长久。</p>
<p> 文化上尽量开放包容，奖惩的原则要事先声明并遵照执行，合作靠透明的制度而不是依赖于默契（短暂的依赖于具体个体之间的默契不是可以长远依靠的事情）。</p>
</li>
<li><p>不放过任何一个细小的直觉上能感知到的问题。</p>
<p> 在一片迷雾中行走，很多时候都是依靠直觉的。而创始人往往拥有对团队、对产品方向最敏锐的直觉。当有某方面敏锐的感知时，不要犹豫，不要怀疑，立马去验证自己的直觉。这种直觉的感知往往是有所苗头的，而越早行动越能避免更多更大的问题的产生。</p>
</li>
<li><p>流程优化永远比赶进度更重要。</p>
<p> 对流程上的优化<strong>永远</strong>（记住是「永远」）比赶进度更重要。只要发现了流程上影响效率的地方，立马启动优化。对于 to B 类型的项目，存在这样一种情况，客户要求的时间很紧，项目进度很赶，而流程上也有很多亟待优化的地方，那么就引入更多的人力资源来优化流程上需要改进的地方，不管是从外部招更多的人还是从内部调其他的人来处理。效率是创业团队的生命线，失去了效率也就基本失去与大公司竞争的很大一方面的优势，所以永远要优化流程，当一个低效的流程反复被执行，浪费的不仅是这个流程上所有人的时间，更是对这个流程线上人的主观能动性的脱敏式折磨（这类似于中大型企业虽然有很多常年低效的流程制度，但因为早已形成惯性无人进行优化，员工们也逐渐就不再觉得那是可以被改变或优化的地方，慢慢的越来越多的人开始人浮于事，用打工人的心态各扫门前雪，这往往就是中大型企业开始体制僵化走向衰败的开始）。</p>
</li>
</ol>
<p>差不多暂时能想到的点就这些，如果以后有新的想法可以总结成文也会写一些新的东西。创业是一个十分艰难的过程，三年在创业公司的经历见证了一个小团队的起起伏伏，对于方向和未来的迷茫，感受到真实世界里创业的艰辛和残酷。不禁让人想起十年前左右「大众创新」所引发的在校大学生的创业热潮，大部分都是极其幼稚的（当然不可否认当时成功的创业项目也很多，那个时代有那个时代的红利）。当面对真实的现金流压力的时候，你的所有产品决策和公司走向还能不忘初心吗？无论成败与否，所有的创业者都会需要想明白这个现实的问题，并找到自己的答案。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>产品</tag>
        <tag>创业</tag>
      </tags>
  </entry>
  <entry>
    <title>Elixir 代码性能优化指北</title>
    <url>/2019/12/05/elixir-code-performance-optimization/</url>
    <content><![CDATA[<p>Elixir 作为基于 Erlang&#x2F;OTP 的年轻语言，拥有良好的并发模型设计，在 Web 场景下对于实现能承载高并发的服务毫无问题。有好事者<a href="https://github.com/mroth/phoenix-showdown">对比过包括 Phoenix 在内不同的 Web Framework 的性能</a>，可见如果采用 Phoenix&#x2F;Plug 来实现 Web Server 在性能上不会有太大的问题（代码实现良好的情况下）。所以，本文不会讨论真正的工业生产环境下整个系统的性能状态，因为系统性能受到很多因素的影响，具体编程语言的运行时的执行效率往往不是真正的问题所在，与其考虑编程语言本身的运行时效率，不如探讨系统在具体架构和实现上如何能优化来承载更高的负载来得实际。在生产环境中，我们可以借助 <a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86">APM</a> 服务来监控系统状态和性能指标。</p>
<p>由于 Elixir 本身是基于 Erlang 的更高层次的抽象，所以直觉上我们会觉得 Elixir 在运行性能上应该比 Erlang 本身要差一些。实际情况是不是这样呢？Elixir 相比于 Erlang 而言，为我们提供了一些可以快速调用的高阶函数库，典型的有 <a href="https://hexdocs.pm/elixir/Enum.html"><code>Enum</code></a>、<a href="https://hexdocs.pm/elixir/Stream.html"><code>Stream</code></a>，提高了日常实现需求的开发效率，可以让代码实现得更清晰且更易维护。而更高的抽象又几乎必然意味着底层的实现逻辑需要更通用健壮，从而也会更复杂。更高的抽象程度似乎天然与更高的运行效率有着内在的矛盾。本文的焦点在 Elixir 代码的运行性能，即对于实现同样的功能，用哪样的 Elixir 实现方式会让代码在运行时跑得更快。</p>
<span id="more"></span>

<p>接下来会拿我在刚接触 Elixir 时实际开发过程中真实写出来的代码来举例如何进行优化，相信不少 Elixir 新手会跟当时的我一样或多或少犯类似的错误。源代码可以在这里找到：<a href="https://github.com/seniverse/ex_fieldmask">ex_fieldmask - GitHub</a>，通过项目的提交历史也可以看到我的修改过程，整个代码才一百多行，改动也都很简短，非常适合举例。这个库实现的需求是用简单的字符串解析的方式来实现类似 <a href="https://developers.google.com/youtube/v3/getting-started#partial">Google+&#x2F;YouTube API 中的 Partial Responses</a> 的语法和功能。我会以这个代码仓库中的例子来举例能明显改善 Elixir 运行性能的实现改进，其他不会明显改善性能但是也会让代码更优的改动也会稍微提一下。我们从提交历史中从前往后挑选一些值得一提的 commits 来一一解说。</p>
<ul>
<li><p>判断值时，用 <code>case</code> 替换 <code>cond</code>：<a href="https://github.com/seniverse/ex_fieldmask/commit/913be4225298d9ef90f34727108d737ea5d7701c">commit <code>913be42</code></a>。</p>
<p>改动前：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cond</span> <span class="keyword">do</span></span><br><span class="line">  keys === [] -&gt; data</span><br><span class="line">  keys === [<span class="string">&quot;*&quot;</span>] -&gt; ......</span><br><span class="line">  <span class="literal">true</span> -&gt; ......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>改动后：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> keys <span class="keyword">do</span></span><br><span class="line">  [] -&gt; data</span><br><span class="line">  [<span class="string">&quot;*&quot;</span>] -&gt; ......</span><br><span class="line">  _ -&gt; ......</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：能用 <code>case</code>（或函数子句）的就不要用 <code>cond</code>。<code>cond</code> 适用于多个独立的表达式求值判断真假的情况，它需要从上至下对每个表达式求值直到遇到第一个值为「真」的分支。在这里，我们全部是关于 <code>keys</code> 的简单比较，显然用 <code>case</code> 直接模式匹配会是更优的实现。<code>cond</code> 里的 <code>true</code> 的 fallback 分支在 <code>case</code> 里可以用 <code>_left</code> 来对应变更用于匹配任意项。</p>
</li>
<li><p>函数用一个完整的 Pipeline 串联来提升可读性：<a href="https://github.com/seniverse/ex_fieldmask/commit/3e610d80b69be0015e376273806df9711427e701">commit <code>3e610d8</code></a>，其他类似的改动还有 <a href="https://github.com/seniverse/ex_fieldmask/commit/fa039386be8b953e8ec927408a880301fc5283cb">commit fa03938</a>。</p>
<p>改动前：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reveal</span></span>(tree, data) <span class="keyword">when</span> is_map(tree) <span class="keyword">do</span></span><br><span class="line">  keys = <span class="title class_">Map</span>.keys(tree)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> keys <span class="keyword">do</span></span><br><span class="line">    [] -&gt; data</span><br><span class="line">    [<span class="string">&quot;*&quot;</span>] -&gt; ......</span><br><span class="line">    _ -&gt; ......</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>改动后：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reveal</span></span>(tree, data) <span class="keyword">when</span> is_map(tree) <span class="keyword">do</span></span><br><span class="line">  tree</span><br><span class="line">  |&gt; <span class="title class_">Map</span>.keys()</span><br><span class="line">  |&gt;(<span class="keyword">fn</span></span><br><span class="line">    [] -&gt; data</span><br><span class="line">    [<span class="string">&quot;*&quot;</span>] -&gt; ......</span><br><span class="line">    _ -&gt; ......</span><br><span class="line">  <span class="keyword">end</span>).()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：最后的匿名函数中的参数匹配跟 <code>case</code> 一样也是模式匹配，同样优于 <code>cond</code>，原代码中把 <code>case</code> 改成匿名函数的形式是为了让整个 <code>reveal</code> 函数是一个完整的用 <code>|&gt;</code> 串联起来的 Pieline 而又不失简洁，但性能上并不会明显更优。这样的改动更多是把命令式的代码风格改成函数式的代码风格，Pipeline 的每个部分都是独立无状态的，可读性和可维护性都会有所提升。</p>
</li>
<li><p>List&#x2F;Tuple 直接用模式匹配取值：<a href="https://github.com/seniverse/ex_fieldmask/commit/801ff47c93f4b682bbd2f2997ee23ea7e98b6b6c">commit <code>801ff47</code></a>。</p>
<p>改动前：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">chars = elem(item, <span class="number">0</span>)</span><br><span class="line">delimiter = elem(item, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>改动后：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">&#123;chars, delimiter&#125; = item</span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：同样也是用模式匹配替代使用函数来取值，不仅让代码可以一行解决，而且还会提升性能。如果 List&#x2F;Tuple 很长，而我们只需要提取前面一部分的片段，则又可以使用 <code>_tail</code> 来匹配我们不关心的尾部区域。</p>
</li>
<li><p>匿名函数用 <code>&amp;</code> 改写：<a href="https://github.com/seniverse/ex_fieldmask/commit/c19d49fed10e026b0ccd3cd27a77af8e4b7fa87d">commit <code>c19d49f</code></a>。</p>
<p>改动前：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Enum</span>.filter(<span class="keyword">fn</span> str -&gt; str !== <span class="literal">nil</span> <span class="keyword">and</span> str !== <span class="string">&quot;&quot;</span> <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p>改动后：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Enum</span>.filter(&amp;(&amp;<span class="number">1</span> !== <span class="literal">nil</span> <span class="keyword">and</span> &amp;<span class="number">1</span> !== <span class="string">&quot;&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：无他，就是代码更简洁了，而且我们不再需要想如何给函数参数命名。<a href="https://martinfowler.com/bliki/TwoHardThings.html">众所周知，命名在编程里是一件很难的事情……</a>（当然，只有在这种函数很简单的情况下值得这样做）</p>
</li>
<li><p>在函数参数中直接匹配复杂数据结构内部的值：<a href="https://github.com/seniverse/ex_fieldmask/commit/9af5145731aacfeac0e6e3826ee4c854c8550d6a">commit <code>9af5145</code></a> 和 <a href="https://github.com/seniverse/ex_fieldmask/commit/456d3d4c4f26919055c18a7d2ff233437530f553">commit <code>456d3d4</code></a>，其他相同原因的改动还有 <a href="https://github.com/seniverse/ex_fieldmask/commit/21b1fee30f439628139f307157341812b52a237d">commit <code>21b1fee</code></a>。</p>
<p>改动前：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Enum</span>.reduce(&#123;%&#123;&#125;, [], [], <span class="literal">nil</span>&#125;, <span class="keyword">fn</span> token, acc -&gt;</span><br><span class="line">  &#123;tree, path, stack, last_token&#125; = acc</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> token <span class="keyword">do</span></span><br><span class="line">    <span class="string">&quot;,&quot;</span> -&gt;</span><br><span class="line">      <span class="keyword">if</span> <span class="title class_">List</span>.first(stack) === <span class="string">&quot;/&quot;</span> <span class="keyword">do</span></span><br><span class="line">        &#123;tree, tl(path), tl(stack), token&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        acc</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;/&quot;</span> -&gt;</span><br><span class="line">      &#123;tree, [last_token | path], [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;(&quot;</span> -&gt;</span><br><span class="line">      &#123;tree, [last_token | path], [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;)&quot;</span> -&gt;</span><br><span class="line">      &#123;tree, tl(path), [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">    _ -&gt;</span><br><span class="line">      &#123;put_in(tree, <span class="title class_">Enum</span>.reverse([token | path]), %&#123;&#125;), path, stack, token&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p>改动后：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Enum</span>.reduce(&#123;%&#123;&#125;, [], [], <span class="literal">nil</span>&#125;, <span class="keyword">fn</span></span><br><span class="line">  <span class="string">&quot;,&quot;</span> = token, &#123;tree, path, stack, last_token&#125; -&gt;</span><br><span class="line">    <span class="keyword">if</span> <span class="title class_">List</span>.first(stack) === <span class="string">&quot;/&quot;</span> <span class="keyword">do</span></span><br><span class="line">      &#123;tree, tl(path), tl(stack), token&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;tree, path, stack, last_token&#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;/&quot;</span> = token, &#123;tree, path, stack, last_token&#125; -&gt;</span><br><span class="line">    &#123;tree, [last_token | path], [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;(&quot;</span> = token, &#123;tree, path, stack, last_token&#125; -&gt;</span><br><span class="line">    &#123;tree, [last_token | path], [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;)&quot;</span> = token, &#123;tree, path, stack, _&#125; -&gt;</span><br><span class="line">    &#123;tree, tl(path), [token | stack], token&#125;</span><br><span class="line"></span><br><span class="line">  token, &#123;tree, path, stack, _&#125; -&gt;</span><br><span class="line">    &#123;put_in(tree, <span class="title class_">Enum</span>.reverse([token | path]), %&#123;&#125;), path, stack, token&#125;</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：改动前的写法更多的还是在用其他无模式匹配特性的编程语言的思维在写代码，在 Elixir 里，我们可以直接在函数参数中使用模式匹配，不仅简化了步骤让代码变得更简洁，而且也简化了变量个数、少了命名需求。在分支的匹配过程中我们还可以给匹配到的字符串同样用模式匹配 <code>&quot;/&quot; = token</code> 的方式来命名。为什么已经确定的匹配还要用一个新的变量来匹配呢？原因是在分支内部需要多次重复引用 <code>&quot;/&quot;</code>，我们直接用 <code>token</code> 来统一引用即可，小小改动却充分体现了 <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don’t repeat yourself</a> 的原则。</p>
</li>
<li><p>用 <a href="https://elixir-lang.org/getting-started/comprehensions.html">List Comprehensions</a> 替换高阶函数的使用：<a href="https://github.com/seniverse/ex_fieldmask/commit/8de1abf59a18829e8e19a33a625f58424e577e3b">commit <code>8de1abf</code></a>，其他类似的改动还有 <a href="https://github.com/seniverse/ex_fieldmask/commit/48afae9357515afbd2111bd412ac4d4cd09f2229">commit <code>48afae9</code></a>。</p>
<p>改动前：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span></span><br><span class="line">  [] -&gt;</span><br><span class="line">    data</span><br><span class="line"></span><br><span class="line">  [<span class="string">&quot;*&quot;</span>] -&gt;</span><br><span class="line">    data</span><br><span class="line">    |&gt; <span class="title class_">Map</span>.keys()</span><br><span class="line">    |&gt; <span class="title class_">Enum</span>.map(&amp;[&amp;<span class="number">1</span>, reveal(tree[<span class="string">&quot;*&quot;</span>], data[&amp;<span class="number">1</span>])])</span><br><span class="line">    |&gt; <span class="title class_">Map</span>.new(<span class="keyword">fn</span> pair -&gt; <span class="title class_">List</span>.to_tuple(pair) <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">  keys -&gt;</span><br><span class="line">    <span class="keyword">case</span> data <span class="keyword">do</span></span><br><span class="line">      data <span class="keyword">when</span> is_list(data) -&gt;</span><br><span class="line">        <span class="title class_">Enum</span>.map(data, &amp;reveal(tree, &amp;<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">      data <span class="keyword">when</span> is_map(data) -&gt;</span><br><span class="line">        keys</span><br><span class="line">        |&gt; <span class="title class_">Enum</span>.map(&amp;[&amp;<span class="number">1</span>, reveal(tree[&amp;<span class="number">1</span>], data[&amp;<span class="number">1</span>])])</span><br><span class="line">        |&gt; <span class="title class_">Map</span>.new(<span class="keyword">fn</span> pair -&gt; <span class="title class_">List</span>.to_tuple(pair) <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>改动后：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span></span><br><span class="line">  [] -&gt;</span><br><span class="line">    data</span><br><span class="line"></span><br><span class="line">  [<span class="string">&quot;*&quot;</span>] -&gt;</span><br><span class="line">    data</span><br><span class="line">    |&gt; <span class="title class_">Map</span>.keys()</span><br><span class="line">    |&gt; (<span class="keyword">fn</span> keys -&gt;</span><br><span class="line">      <span class="keyword">for</span> key &lt;- keys, <span class="symbol">into:</span> %&#123;&#125; <span class="keyword">do</span></span><br><span class="line">        &#123;key, reveal(tree[<span class="string">&quot;*&quot;</span>], data[key])&#125;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>).()</span><br><span class="line"></span><br><span class="line">  keys -&gt;</span><br><span class="line">    <span class="keyword">case</span> data <span class="keyword">do</span></span><br><span class="line">      data <span class="keyword">when</span> is_list(data) -&gt;</span><br><span class="line">        <span class="keyword">for</span> item &lt;- data <span class="keyword">do</span></span><br><span class="line">          reveal(tree, item)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">      data <span class="keyword">when</span> is_map(data) -&gt;</span><br><span class="line">        keys</span><br><span class="line">        |&gt; (<span class="keyword">fn</span> keys -&gt;</span><br><span class="line">          <span class="keyword">for</span> key &lt;- keys, <span class="symbol">into:</span> %&#123;&#125; <span class="keyword">do</span></span><br><span class="line">            &#123;key, reveal(tree[key], data[key])&#125;</span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>).()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><strong>解读</strong>：这里性能上是不是真的有优化可能不那么明显。在 Elixir 1.9.1 中我使用 <a href="https://github.com/bencheeorg/benchee">Benchee</a> 做 benchmark 发现 List Comprehensions 确实要比使用 Elixir 提供的高阶函数要快。没有看 Elixir 的具体的实现，但大致揣测 List Comprehensions 在底层是用简单的递归函数实现的，而高阶函数应该做了更多复杂的事情，从逻辑上可以想到的是 <code>Enum/Stream</code> 库需要先处理传入数据结构的 <code>Enumerable</code> 协议的相关要求再用不同数据类型对应的不同逻辑来处理，自然会复杂一些。</p>
</li>
</ul>
<p>总结上来，简单的明显可以改善代码性能的写法其实只有两类：尽可能用模式匹配、用 List Comprehensions 替换高阶函数，其他的只是从其他角度考虑的代码层面的优化。最终我们线上没有使用这个库，因为 <a href="https://github.com/seniverse/fieldmask_benchmark">benchmark</a> 发现直接定义 Partial Responses 的语法，然后用 Erlang 的 <a href="http://erlang.org/doc/man/leex.html"><code>leex</code></a> 做词法分析，再用 <a href="http://erlang.org/doc/man/leex.html"><code>yecc</code></a> 做语法分析生成 <a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">AST</a>，最后遍历 AST 就可以得到做了 mask 的结果，即我们要的 Partial Response。代码同样开源在 GitHub：<a href="https://github.com/seniverse/fieldmask">fieldmask - GitHub</a>，也是一个绝妙的学习 Erlang <code>leex</code> 和 <code>yecc</code> 的例子。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>Erlang</tag>
        <tag>性能调优</tag>
        <tag>Elixir</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 年书单</title>
    <url>/2021/12/31/2021-booklist/</url>
    <content><![CDATA[<h3 id="关于书单"><a href="#关于书单" class="headerlink" title="关于书单"></a>关于书单</h3><p>直奔主题：</p>
<ol>
<li><p><a href="https://book.douban.com/subject/35275524/">晚婚</a>：★★★★</p>
<p> 人物描写十分细节，情绪表达非常细腻，如果没有一定的人生阅历和生活体悟，很难相信作者能把书中的某些人情世故和人物动机描写得如此让人感同身受，这是某种源于生活的真切（而且很现代），但故事的戏剧性又提醒着读者小说创作高于生活的存在。</p>
<p> 相比于《新婚之夜》少了很多推理和悬疑的要素，但依然还是有很多伏笔在前后呼应。整个故事的基调是压抑的，给人无力感，的确是一部「漠然记」。还是很喜欢辽京的写故事风格。</p>
</li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p><a href="https://book.douban.com/subject/35250412/">候场</a>：★★★★</p>
<p> 第一次看李诞的书，我也是边喝着凉凉的啤酒边看着新一季的《吐槽大会》边看完这本书的，文字跟他说的话一样个人风格非常强烈。</p>
<p> 李诞整本所谓的「小说」都在写一个叫李诞的人的愁苦和自我厌恶，如果他是真的「诚实」的话。任何能称之为作品的东西，比如电影或小说，都不是绝对的真实，因为生活本身其实是麻木混乱无趣、极少有戏剧点、不值得被看的。这还是我看大鹏的《吉祥如意》的一点想法。</p>
<p> 会自我怀疑的人，一是自恋矫情，二是值得做朋友。这个世界已经有太多的成年人被规训得有着过于明确清晰的自我意志，每一个动作的目的性都如此强烈，以致于世界才会像现在这样无趣。不过我不是在说那种冠冕堂皇自欺欺人的假的「自我怀疑」。这本书讲的我前面所指的真的「自我怀疑」。</p>
</li>
<li><p><a href="https://arxiv.org/ftp/arxiv/papers/1702/1702.01715.pdf">Software Engineering at Google</a>：★★★★★</p>
<p> Google 在 Web 领域深耕多年，对于做 Web 产品的软件工程经验积累颇深。随着战略转变和软件系统的逐渐庞大，微软也在多年前就意识到了内部工程化的重要性。虽然这是一篇写 Google 的文章，却可以从中看到很多微软内部在践行的实践，说明微软也在快速补齐 Web 软件工程化方面的短板，1ES 策略在内部践行多年，很多开发上的体验都大有改善，这对提高开发者开发效率、产品质量和稳定性都是极为重要的一部分，尤其是对这种动辄已经迭代了一二十年的产品的庞大代码库以及如今的全球用户基数而言。</p>
<p> 比较而言，微软在工程化上还是有两点跟 Google 有比较大的不同：<br>1. Google 几乎所有的代码在一个大的 repo 里，不是 git 管理的；<br>2. 他们经常重写代码。</p>
</li>
<li><p><a href="https://book.douban.com/subject/35339729/">微信背后的产品观</a>：★★★★☆</p>
<p> 「需求只来自你对用户的了解，这里非常想强调几点：第一，需求不来自调研；第二，需求不来自分析；第三，需求不来自讨论；第四，需求不来自竞争对手。」</p>
<p> 太赞了！张小龙是典型的原教旨主义产品经理，这一领域的另一个知名代表是乔布斯。而与这一派相对的国内的字节系大概可以代表。我是从来都不相信用数据来决定一个产品的方向的，这种做法本质上是在跟人类历史好不容易构建的人文主义作斗争，是在剥夺人之所以为人的本质，甚至可能在将来导致人类的灭亡。</p>
<p> 产品经理永远要保持对自己主导的产品的人文温度，这样世界才能越来越好。</p>
</li>
<li><p><a href="https://read.douban.com/column/59545797/">我们消失的那一年</a>：★★★☆</p>
<p> 「像是终于找到了线头，慢慢地提起来，一些原本散落在记忆深处的珠子都串到一起了」。多线多时空叙事慢慢串起来好评，悬疑感十足，让人很想继续读下去。部分地方文笔和遣词造句还可以再斟酌斟酌。</p>
</li>
<li><p><a href="https://book.douban.com/subject/35552655/">李诞脱口秀工作手册</a>：★★★☆</p>
<p> 这本书（工作手册）首先是写给内容创作者的现实的工作经验和方法，不是什么复杂的理论，全是从个人感受和实际出发，追求一种长期持续的专业内容生产；其次有些命题也是很终极的，是可以面向普罗大众的，当然同样也是很实用主义倾向的，所以非从业者也可以看看，或许能从窥探脱口秀行业的工作方式中获得一些启发（比如第二节工作和生活是否应该分开的问题、第十七节如何给别人 pitch 你的想法）；另外，了解他们在这个新兴行业摸索同时尝试总结出一些规律的思考过程是有趣的。</p>
<p> 问题就是太短，不够系统，很多地方也是点到即止，有的地方模棱两可不可言尽，还有些地方可能也不是完全没有异议的。不过作为一个指导作用的给从业者工作手册是不错的。</p>
</li>
<li><p><a href="https://book.douban.com/subject/35295592/">小狗钱钱</a>：★★★★★</p>
<p> 我每次看这种经典的投资入门类型的书都会觉得：Damn! 为什么我十岁的时候没有看过这书。哈哈哈有点夸张，合适的时候看到比更早的看到要有意义得多，尤其是在这几年的所有关于钱的实践之后，很多点已经是心领神会。几乎你人生中所有与钱相关的选择和决定都可以在这一类书中找到明确的答案。</p>
<p> 讲故事的方式提高了这本书所要说明的道理的可读性，后记部分提到的企业家精神与如今以培养社畜为目的的教育模式的冲突尤其令人深思。虽然很短但是绝对是今年看完的最值得的一本书。</p>
</li>
</ol>
<h3 id="关于摄影"><a href="#关于摄影" class="headerlink" title="关于摄影"></a>关于摄影</h3><p>还称不上摄影吧，顶多就是拍拍照片。</p>
<p>「读万卷书，行万里路」，「身体和灵魂总要有一个在路上」，不看书的时候出门拍拍照是一个很好的跟自己独处的方式。当你能够专注的沉浸在如何拍到一张好照片的状态中时，很容易进入那种「心流」状态。专注于写代码也能达到这种状态。本质上，这都是一种利用自己沉淀的技术、品味和灵感进行创作的行为。</p>
<p>摄影圈目前是有一些不好的风气和迷思的，我很庆幸我从一开始就树立比较正确的摄影价值观，就跟我接触其他我本不了解的领域（比如投资）一样，这样比较不容易被网络上各种各样的言论带偏。跑题的结论是，学习新东西最开始重要的不是快速掌握技术，而是树立正确的看待这个事情的观念。</p>
<p>转回来，很多真正能让自己满意的好照片可能都诞生于不经意的一瞬间，而这样的时刻往往你的手边并没有相机。对于初学者而言，有一个能让你愿意经常带出去拍照的相机比去学习什么艰涩难懂的摄影理论和培养艺术品味要重要得多。希望明年仍然有机会会拍到很多不期而遇的好照片。</p>
<h3 id="关于投资"><a href="#关于投资" class="headerlink" title="关于投资"></a>关于投资</h3><p><a href="https://maples7.com/2019/12/31/2019-booklist/">前年的「书单」</a>说过，我在几年前一个很偶然的机会开始接触投资。依然非常幸运的是，我从一开始就树立了比较正确的投资理念。这基本上是近几年我最大的收获之一，也很可能是我这一生很重要的收获之一。</p>
<p>投资其实是一个早就有前人公开最优解法的领域，但大多数人要么懒于学习、要么惧于尝试。它其实一点都不难，基本原理甚至相当简单。甚至于说，对于投资，大道至简才是最终的归途。当然，更多已经开始投资的人莽莽撞撞全凭一时的感觉来操作，运气好是可以短时间获得不错的收益，但很可能不是长久之计。这是一件非常考验人的耐心和毅力的一件事，但不同的人可能有不一样的适合自己的投资策略，一旦认定一种策略，剩下的就是绝不轻易放弃的不断「滚雪球」。</p>
<h3 id="关于疫情"><a href="#关于疫情" class="headerlink" title="关于疫情"></a>关于疫情</h3><p>这两三年的头条自然是新冠疫情，疫情对人的异化作用远比大多数人想象的要深刻，甚至你现在看到电影里人多的场景都可能潜意识里感到不适。这几天有不少专业人士预言疫情会在 2022 年结束，我远没有这么乐观。对于国内的普通人来说，疫情什么时候结束已经不是最重要的事，重要的是如何减少疫情对自身的人生规划产生的影响。世界已经安定这么多年，没理由一直这样期待下去。这个道理对于投资同样也很重要。</p>
<h3 id="关于预测"><a href="#关于预测" class="headerlink" title="关于预测"></a>关于预测</h3><p>我不敢说明年，我觉得三年内会有一场金融危机，或者是比金融危机更严重得多的危机。没什么 solid 的依据，就是一种直觉，当然，这不是这一天两天的直觉。当年，危机只是危机，即便它比任何一次危机还要严重，也不会是末日。危机过后，世界还会继续。当然，末日也总有一天会来，但应该不会这么早。</p>
<h3 id="关于人生"><a href="#关于人生" class="headerlink" title="关于人生"></a>关于人生</h3><p>我一直试图在人生的所有事情上成为一个纯粹的理想主义者，这当然不是一件简单的事情，但却值得为之付出所有的努力。但是，保持理想主义的同时，我开始意识到一些我值得改变的地方。</p>
<p>以前我对竞争是不屑的，我总是会抱着一些提升自己远比这一两次直接的竞争来得重要的心态，而从小父母的言传身教家庭教育也让我骨子里养成了谦让的习惯，如果有人明确的说喜欢什么东西，不管我是不是喜欢或者讨厌这个人，我大概率是会让给对方的。这当然不是一个坏的品质，但却值得重新审视。本质上，理想主义者愿意为这个世界变得更美好而付出自己的努力，但一味的谦让有时候让出去的却是未来对世界的掌控权和话语权，这并不是一个理想主义者愿意看到的，因为真正的理想主义者实在不多。所以以后希望自己能更敢于直接竞争，不要把这个世界拱手让给我们讨厌的那些人。</p>
<p>另外，希望自己能更有行动力，我今年无疑是想得比做得多很多，这其实很不好。虽然在很多事情上需要细火慢煨、想清楚了再行动，但有些不那么重要的事情上早行动会带来更多切实的好处，至少实践也会加深自己对事物本身的理解。运用 72 小时法则 —— 一件事情如果 72 小时内没有开始，那你很可能永远不会开始。我经常有一些不错的主意，但很多时候没有好好完成使得并没有充分利用好这样的灵感和机会，这是很可惜的。</p>
<p>最后，希望自己能更有专注力吧。看到一种说法是专注力是一种稀缺资源，用完了就没有了。我将信将疑。但我打心底里认为，用强迫自己的方式做自己本身不认同或不喜欢的事情是难以为继的，从这个角度来说，专注力的确是一种用完了就没有的稀缺资源。另一方面，能否专注其实反映的还是自己内心的安定程度，希望新的一年自己的心态能更安定，意志力能更强。</p>
<p>Hope for the best and prepare for the worst. Always!</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
        <tag>人生</tag>
        <tag>投资</tag>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title>如何开始稳健投资</title>
    <url>/2022/03/13/how-to-start-investing-soundly/</url>
    <content><![CDATA[<p>如何开始稳健投资？作为一个不单单以赚钱为目的十分业余投资者，想凭借自己四年左右的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E7%BA%A7%E5%B8%82%E5%9C%BA">二级市场</a>摸爬滚打的粗浅经验，用不断拆解标题的方式来浅显易懂的回答一下这个问题。</p>
<h2 id="「投资」"><a href="#「投资」" class="headerlink" title="「投资」"></a>「投资」</h2><h3 id="正确的金钱观"><a href="#正确的金钱观" class="headerlink" title="正确的金钱观"></a>正确的金钱观</h3><p>首先，我们的行为是「投资」，不管你的目的如何 —— 虽然我相信绝大部分人的首要目的就是实现财富增值，这很好，相当好 —— 但如果你天生或者后天养成了对金钱和财富的潜意识仇视或厌恶（这并不少见，古语有「贫贱不能移」，中华文化传统就有清贫审美观，普遍认为钱是俗物，商贾之人自古以来社会地位就不高），建议你尽早改变这个观念，先对金钱有一个正确的认识，再继续读下去。我不想在这篇博客里本末倒置做过多赘述，有这方面问题的朋友推荐看<a href="https://book.douban.com/subject/35295592/">《小狗钱钱》</a>和<a href="https://book.douban.com/subject/25816940/">《富爸爸·穷爸爸》</a>来解决这方面的认知问题。</p>
<p>另外，如果你想快速暴富，直接点「返回」或者关闭页面，谢谢。</p>
<span id="more"></span>

<h3 id="本金从哪里来"><a href="#本金从哪里来" class="headerlink" title="本金从哪里来"></a>本金从哪里来</h3><p>投资首先需要有本金。本金从哪里来？这个问题对于开启投资行为而言可太关键了，本金是一切活水的源头。</p>
<p>资本增值首先得有资本。我所知道的很多相对年轻或有名或无名的实现财务自由的人生故事里，他们大多早早通过创业、自媒体、家庭资助等方式获得了值得用来投资的第一桶金，再通过这样的本金在资本市场实现巨幅财富增值。不管是通过什么样的方式，如果你很幸运有比较快速的方式积累到你的第一桶金，那你已经超越了绝大多数投资者了，因为第一桶金往往是难度最大且最费时间精力的。这就像滚雪球，不同的人通过不同的方式获得的初始雪球的大小不一，雪球越大在固定时间内能沾起来的雪花越多，而且是呈指数级增长。</p>
<p>当然，对于我们大多数普通「打工人」而言，只有每个月或每年固定的薪水用来投资。我一直认为拿去投资的钱不能影响正常的生活，不能降低原有的生活品质，所以如果你的工资扣除你的开销已经所剩无几，那也先暂时不必考虑投资了，收藏本文，努力提高自己的基础固定收入，等每月结余足够可观之后再开始吧。这不仅仅是赚多赚少的问题，如果你的现金流不够充裕，你就会很容易在资本投资行为中作出不理智的决策，那时候股市不仅不是你用来实现财富增值的手段，反而会成为你好不容易积攒的本金的坟墓。当然，每个人的具体情况不同，开销的绝对量和占收入的比重（相对量）差别很大，很难给出定量的标准。</p>
<p>总结来说，拥有足够量的本金对于开始投资非常重要，不管你是有足够的存量资金，还是可预期的稳定持续的未来的现金流。如果达不到条件，不开始比开始更好。</p>
<h2 id="「稳健」"><a href="#「稳健」" class="headerlink" title="「稳健」"></a>「稳健」</h2><p>什么是稳健？其实我上面的段落已经稍微体现出了我对于稳健投资的基本准则，我觉得开始投资前首先要给自己定以下几个绝对不能打破的「红线」原则：</p>
<ol>
<li>「不会死」永远是最重要的、永远值得首先考虑。这不是指你生命的消逝（当然身体健康比投资要更重要、重要、重要得多！），而是说任何时候你都要保证你的本金在 99.9999% 的情况下不会变成 0。风险是客观存在的，但很多方式可以让你的本金不会浮亏到 0 甚至是负数（想想 2020 年的原油宝事件），这首先意味着你永远不要<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E9%87%91%E6%A7%93%E6%A1%BF">上杠杆</a>或者进行<a href="https://zh.wikipedia.org/wiki/%E6%9C%9F%E8%B4%A7">期货</a>投资（更不用说投资币圈、P2P、各种没有资质的伪装成投资的诈骗盘了）。</li>
<li>在不能完全依靠投资自给自足的阶段，投资不能影响自己的主业。也就是不能太占用自己的时间和精力。</li>
<li>投资不能降低自己的生活品质。</li>
<li>即便损失掉所有用于投资的本金也不会使自己的资产大幅缩水难以翻身。当然，不同的人在不同的人生阶段能承受的风险水平不同，相对而言，越年轻的时候可以适当承担更高一点的风险。比如刚毕业一两年的年轻人，本身拥有的资金量很有限，即便损失掉所有的存款也相对可控（因为处在工资能快速增长的阶段，两三年后可能工资就能翻倍，损失的绝对量相对小），所以即便把 70% - 80% 左右的存款用于投资都是可以考虑的。这实际上是个人资产配置的范畴，投资策略与资产配置策略息息相关。</li>
<li>投资的品种在 99.99% 的情况下不会跌到 0。</li>
<li>得用至少三到五年肯定用不到的闲钱用来长线投资。这是为了保证在整个投资阶段的任何时候不会因为市场以外的个人原因做出赎回（卖出）的操作。</li>
<li>投资行为要让自己感到舒服。如果做一件事不会让你感到舒服，你不可能长久的进行下去。如果在投资行为过程中的任何时刻让你觉得不舒服了（仓位低了或者高了、被深套了、存量资金不足了等等），都意味着你的策略或者心态出现了问题，都会导致你做出不理智的操作，这时候需要反思你的投资策略问题出在哪，并对它进行不断的改进（而不仅仅是针对少数几次操作的调整）。</li>
</ol>
<h2 id="「如何」"><a href="#「如何」" class="headerlink" title="「如何」"></a>「如何」</h2><p>这一部分将讨论在以上原则的指导下，<strong>以 A 股市场特点为基础</strong>，对于投资小白而言的更具体的<strong>长期</strong>投资策略。</p>
<p>首先，<strong>假设</strong>我们先选一个单一的品种进行投资，在第 1 条和第 5 条原则的指导下，个股对于小白而言基本就先不考虑了，因为任何一个个股都有可能跌没。那我们得从基金中选，基金分为<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%8A%A8%E5%9E%8B%E5%9F%BA%E9%87%91/9125882">主动基金</a>和<a href="https://baike.baidu.com/item/%E8%A2%AB%E5%8A%A8%E5%9E%8B%E5%9F%BA%E9%87%91/9125945">被动基金</a>，这其中的选择对于小白而言就各有优劣了，感兴趣的话可以自行去了解。如果你想有一个自己掌控度比较高的策略，那就应该会选择被动基金（指数基金）。指数又可以分为<a href="https://zhuanlan.zhihu.com/p/77980205">宽基指数和行业指数</a>，其中宽基指数基金相对风险更低。对于 A 股而言，以下我们以最典型的追踪<a href="https://zh.wikipedia.org/wiki/%E6%B2%AA%E6%B7%B1300">沪深 300</a> 指数的基金为例来讨论具体的策略。因为这个品种基本只要中国股市不关门，它都会一直存在并且不会死。</p>
<p>选定了投资品种，我们如何开始买入卖出呢？</p>
<p>首先，在开始真正操作之前，你得想好自己的具体策略，考虑到各种各样的可能情况下自己如何应对。这样做是因为市场作为一个复杂混沌系统在现有的技术条件下基本是不可预测的，我们的策略不应该建立在对市场走势预测的基础上，而应该建立在对各种可能情况到来的应对之上。而且「预测市场」是个伪命题，任何对市场本身的预测反过来都会影响未来市场的走势。</p>
<p>其次，基于第 3、4、6 条原则，尤其是第 6 条原则，<strong>充分考虑你的存量资金和未来稳定的现金流下</strong>（注意，稳定的现金流可能短时间看起来「稳定」，但人生无常，不代表这样的资金流不会消失，要充分给自己留足安全垫），一开始就<strong>明确想好</strong>你未来所有会投入市场的<strong>资金总量</strong>。比如你打算投入一百万，之后你甚至可以假想把你的整个资金分为一百份，每份资金一万。这样做是让你在未来进行买入、卖出的操作时对你的可投入资金和单次操作的资金量有一个非常直观和定量的衡量概念。</p>
<p>接下来，在你也许踌躇满志兴致勃勃的准备开始「入坑」的时候，我得泼一盆冷水。因为在大多数 A 股市场起起伏伏普普通通平平凡凡的日子，你都不需要做任何操作，这不仅是长期策略本身的要求，也符合第 2 条指导原则。耐心在资本市场永远是美德。那么什么时候值得操作呢？我不打算在这篇针对投资小白的策略讨论里做任何数学计算，或者引入各种<a href="https://zh.wikipedia.org/wiki/%E8%B5%84%E4%BA%A7%E4%BC%B0%E5%80%BC">资产估值</a>指标的概念。一个可能的非常简单的策略是，如果你发现 A 股因为疯狂连续大幅下跌上了微博热搜、各种微信群里出现各种关于「绿色」的投资段子、很多你的好友开始吐槽自己投资的股票基金的大幅回撤，你就可以考虑买入了。买多少呢？总的原则来说，跌得越重应该买的份数越多。A 股大盘大概跌到了什么位置其实关注股票的人都是可以大概感受到了，大底是不可预测的但是底部区域相对是可以觉察到的。大概给出一个量化的标准是，在 2018 年沪指（<a href="http://quote.eastmoney.com/zs000001.html">上证指数</a>）处于 2500 左右这样的位置的时候（我这里用沪指作为一个小白都更熟悉点位的指标来说明，实际上你更应该看你的投资标的的市场位置，在这个例子里是沪深 300 指数的市场位置），你基本已经可以投入 70% - 80% 的资金量了，也就是你的 100 份资金的 70 - 80 份资金。当然，这样回头看市场再给出操作标准是非常不负责任的，因为你不能期望未来的沪指大底也在 2500 点左右（市场不可预测）。但你永远可以看你的投资标的的历史走势，如果能结合你关注的各种财经博主、公众号对于现在市场的位置综合判断会更好。更具体一点，就当下的市场位置而言，沪指在 3300 点左右，上周 A 股因为连续大跌上了微博热搜，我会开始考虑进行买入，结合一些市场声音对 A 股位置的判断，A 股基本跌到了一个合适的黄金坑的入口位置，你基本可以把你的仓位控制在 50% 左右（即从零开始已买入 50 份资金，仅举例）。这样做是因为，如果 A 股继续下跌，甚至跌到四年前的 2500 点（这个点位我应该会控制仓位在 70% - 80%），你依然有充足的资金用来补仓抄底；如果 A 股从此止跌开始回升，我觉得 50% 的仓位也会让自己心里比较舒服不会让自己觉得仓位太低。记住，市场永远是经不起预测的，你只能应对。另一个侧面的标准是，你几乎不会让自己处于满仓（100% 仓位）的状态下，或者这样的时候会很短暂（个人而言，我不能允许满仓超过一个月）。在满仓的情况下如果市场还在不断下跌，你的心态会非常不稳定，违背了第 7 条原则，你会很容易产生<a href="https://baike.baidu.com/item/%E6%AD%A2%E6%8D%9F/1683">「割肉止损」</a>的想法。所以宁愿错过一些利润也不要让自己处于一种危险的境地，这也符合原则 1 的要求。当然，如果你真的因为节奏控制不利，早早投完了 100 份资金，那就坚定的控制自己不会有更多的投入，任凭市场风云变化，都坚定地等待市场雨过天晴的那一天。总结来说，对于买入操作，在大部分时候你不需要做任何操作，在真正值得买入的位点，慢慢按个位份数积累仓位，控制仓位比例与市场位置相关，不要让自己轻易满仓，如果不小心满仓了即便继续下跌也停止买入操作。</p>
<p>何时买入的问题基本解决之后，如何卖出呢？对于长期价值投资策略而言，卖出操作往往比买入操作的次数更少、也更难。股民中有一句俗话是「会卖的才是师父」，确实是这样的。针对当下的 A 股特点，这样的卖出策略你或许可以考虑：</p>
<ol>
<li>牛市不来永远不卖，如果牛市来了，当所有人都陷入疯狂的时候（你公司的扫地阿姨都开始谈论股票想要买入的时候），果断清仓；</li>
<li>与买入策略对应，根据当前的市场位置控制仓位对应比例的卖出，比如沪指在下跌过程中 3500 点的时候你的仓位在 30%（举例而已，实际上我觉得 3500 点也许不值得 30% 的仓位），那你可以在沪指经过一轮下跌再上涨到 3500 点的时候把你的仓位卖出到剩 30% - 40% 左右。不过，跟几乎永远不要满仓对应，你也应该留一部分仓位（比如 20% - 30%）作为压舱石，用 1 的策略来卖出，否则你永远赚不到股市疯狂上涨阶段的涨幅。</li>
</ol>
<p>如果你深入思考，你会发现 1 的策略更适合超长期的价值投资，真正意义上的赚取大盘长期上涨的利润，但却丢失了市场反复波动阶段的利润，也付出了时间成本；而 2 的策略则融入了波段的思想，更适合反复波动的市场阶段，但在市场的疯狂上涨阶段，你的仓位已经不是很多了。另外，有一个说法是 A 股已经再也不会有短期牛市疯狂的表现了，所以你应该根据不同时期的不同特点来改进你的策略。为了实现对市场各种不同阶段的利润的收割，一个好的投资<strong>体系</strong>应该是针对短期、中期和长期都<strong>分别</strong>有不同的资金比例和策略应对的，在这篇里不再详述了。当然，以上示例策略只是我写这篇博客时候的拍脑袋的想法，没有经过市场的检验，目的仅仅是为了体现我前面提到的投资原则，你更应该有自己的经过深思熟虑之后的投资策略。</p>
<p>另外，这个示例策略还只是讨论了对单一品种的投资，下一个值得进阶的点是，你应该考虑对<strong>相关性比较低</strong>的多个品种进行投资（包括<a href="https://book.douban.com/subject/26752026/">《聪明的投资者》</a>在内的很多投资大师的著作有类似的观点），并且分配不同的仓位比例，不要让单一品种的仓位占比过高（比如当你的可投品种多了之后，控制每个品种仓位不会超过 20%）。这样做的理由是，相关性低的不同品种可以在市场的各个不同阶段降低你的总仓位的波动和<a href="https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%92%A4%E7%8E%87/3645063">最大回撤率</a>。不要小看这个指标，当浮亏过大时，你的投资心态会受到极大的影响，从而违背了第 7 条原则。而且，这些品种各自会有不同的周期和阶段，你可以更灵活的将某个上涨的品种资金回收用于其他处于低估值阶段的品种（但要注意控制单一品种的仓位比例），或者回收到现金池进行更大范围的资产配置，甚至可以达到一种「东方不亮西方亮」的效果，这是很符合第 7 条原则的。</p>
<h2 id="「开始」"><a href="#「开始」" class="headerlink" title="「开始」"></a>「开始」</h2><p>我为什么在这时候想写这篇博客，很大程度上是因为这个时间点可能会是一个比较好的开始投资的时间点。不像很多投资大 V 所吹嘘的，我从来不认为无脑定投是一个好的投资策略，完全的定投很难在可以接受的时间跨度内实现满意的收益率，而时间成本其实对一个人短暂的一生而言远远比我们以为的要重要很多。所以投入的时机其实很重要，当下的股市状态也许是一个不错的开始的时机，处于下降趋势中但应该还没有完全见底，估值不算特别便宜但是某些品种到了一个可以开始买入的点位，这是开始实践一个完整的投资周期的比较好的时间点。对于小白第一个的投资周期，在你还没有投入很多资金到资本市场的时候，没有亏损很重要，不过，能够在不同的市场阶段充分感受那个当下自己在心态、策略上的优势和不足，体会资本市场和世界运行的特点，不断沉淀出自己的经验和体会，可能会更重要。</p>
<p>我自己是从 2018 年左右正式开始实践股票市场投资的，在一个非常偶然的机会了解到了 <a href="https://weibo.com/u/5687069307">ETF 拯救世界</a>的<a href="https://www.zhihu.com/question/65793376">「长赢指数投资计划」</a>和<a href="https://qieman.com/">且慢</a>，我自己的投资理念、策略方法、心得体会大部分都来自于此，我觉得这至少是一个非常值得参考的策略（利益声明：本人跟 E 大和且慢没有任何除开跟投外的私下利益关系）。巧合的是，2018 年 A 股在我开始投资不久就经历了阶段大底，现在回头看，我觉得我是碰巧在一个比较好的时间点开始了我的投资之旅，那个时间点我感觉跟现在的阶段很类似（很多投资大师之所以能长期实现稳定的收益率，一个可能的原因就是他们不会把幸运归因为是自己的实力，从而能避免因为单次的侥幸而不思改进，很多看似成功的投资个例，其实都仅仅只是幸运而已，运气因素在成功投资中的占比可能比我们认为的要高一些）。当然，即便是做简单跟投，我觉得任何参与资本市场投资的人都应该有自己的独立思考和认知，至少应该要认同你用真金白银做的投资操作和策略，做到知行合一，你才不会在股市的动荡旅程中被中途甩下车。<a href="https://sspai.com/post/62828">「投资是认知的变现」</a>，我是深以为然的。</p>
<p>此外，养成记账的习惯，时刻把握自己的资产配置状态，是开始投资的首要前提。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最后，如果你真的想开始投资或者已经在投资，我觉得任何时刻都需要怀有「敬畏市场」的心，这不是一个有简单线性因果关系或简单相关性的领域，不要试图以你自己道听途说的消息、简单线性的对复杂世界的肤浅理解来进行任何脱离策略和原则的想当然的操作，永远要有「价值、概率、长期和非线性」的投资思维（我在<a href="https://maples7.com/2019/12/31/2019-booklist/">《2019 年书单》</a>最后部分对这四个词有详细阐述），要有怀疑和独立思考的精神。</p>
<p>有时候我觉得投资过程跟探索人生很相似，充满了混沌、未知和不确定，又永远有不期而遇的惊喜，你再强大也只是市场的学徒、浩渺宇宙中的沧海一栗。</p>
]]></content>
      <categories>
        <category>滚雪球</category>
      </categories>
      <tags>
        <tag>投资</tag>
        <tag>理财</tag>
        <tag>基金</tag>
        <tag>ETF</tag>
      </tags>
  </entry>
  <entry>
    <title>一套大概率可行的具体投资策略</title>
    <url>/2022/08/20/a-specific-investment-strategy/</url>
    <content><![CDATA[<p>这一篇是接着上一篇<a href="https://maples7.com/2022/03/13/how-to-start-investing-soundly/">《如何开始稳健投资》</a>的思路，把具体的投资策略细化。在上一篇里，我们解决了一些原则性的思路问题，同时对如何进行稳健投资做了粗略的概括，话题包括为什么要用几乎不会死的指数基金作为投资标的、本金从哪来、大体上如何买入卖出等。再次申明，我所有的这些投资策略的理论、方法和实践经验几乎都来自对<a href="https://weibo.com/u/5687069307">ETF 拯救世界</a>所公开的投资策略的跟投、模仿和实践，绝非本人原创。在这一篇里我想实现的是对这一套体系的整体粗略概括，同时又具体到一些必要的关于资本配置的细节，写下来也许对于我个人的意义更大一些<del>，毕竟谁没有幻想过自己突然哪一天突然失忆了呢</del>。</p>
<p>既然是「具体投资策略」，一定要有必要的细节。但事先声明，这些细节只是我正在实践的细节，并不代表任何人拿去就可以直接套用，比如其中的资金配比、仓位配比等等，都不一定得是我接下来要说的那个比例，因为有一些比例只是根据市场历史得出的实践经验，并没有很 solid 的理论支撑。如果你也要跟着这一套策略实践，请根据自身的实际情况进行相应的调整，只要大致的方向和思路没问题就行。投资，很多时候<a href="http://www.globalhha.com/doclib/index.php?m=Home&c=article&a=viewarticle&id=16">要追求一种「模糊的正确」，而不要「精确的错误」</a>。</p>
<span id="more"></span>

<p>另外，再次设置一个合理的预期，这套策略预计只能做到比 GDP 增长速度高两个点的平均年化水平，或者说跑赢通胀的水平，如果运气好赚到了更多，那纯属运气好。快速暴富的投资策略，也有很多，出门右转即可。</p>
<p>先做一个假设：假设你有一千万的可投资金。这里先需要一点注解：</p>
<ol>
<li>在上一篇讲过「本金从哪里来」，如果你的本金太少，进行二级市场投资对个人的资产增值整体来说意义不大，当然我并不是说你得攒够一千万才能开始，这里只是举个例子，方便后面进行对应比例的计算。实际操作中，按照你的具体可投资金按比例折算即可。</li>
<li>什么是「可投资金」？指的是你可以<strong>随时</strong>（姑且按一周内算）拿出来进行投资的资金，不包括你买的银行定期等任何其他不能马上变现的资产。而且这些钱在可预见的三到五年内都没有需要用到其他地方的计划和打算，比如买房、买车等。所以，也不要把你应急用的备用资金（没有收入的情况下至少一两年的开销）、买保险的资金、可能的用于医疗保健的资金等算在内。</li>
</ol>
<p>回到这一千万的可投资金，我会把它们先分成两部分：</p>
<ul>
<li>第一部分，两百万（20%）购买货币基金、稳健的国债或者合适的信托基金（取决于实际资金量），重点是同样需要保证这两百万的流动性，也就是能随时拿出来用。但是，你对这两百万的心理预期应该是 <strong>99.99%</strong> 的情况下不会真的拿来用。这部分相当于你的可投资金的压舱石，所以你几乎永远都不会处在满仓的状态下。剩下可能会用到这两百万的 0.01% 的情况是：往差了想是你对未来的资金规划考虑不足，在投资以外出现了必须要用钱的场景，那没办法，只能先挪用这部分钱；往好了想是市场真的出现了五年、十年甚至二十年一次的机会，我不会允许自己错过这样的机会，在之后要说的更具体的体系之外，我很可能会用这两百万的一部分进行额外的仓位补充，比如今年（2022 年）上半年出现的中概股从历史最高下跌到几乎 20% 的位置这样的情况，我预计这可能是五年难得一遇的机会，会拿出少部分这两百万进行额外的补仓。同时，这里 callback 到了为什么我们需要买指数基金，因为它们几乎不会死，但是个股在这方面的风险就会高很多，即便是公司的市场竞争力减弱，都很可能造成股价的一蹶不振，从此一路下跌，直至退市，甚至公司倒闭。</li>
<li>第二部分，八百万（80%）用来进行真正的日常指数基金投资。接下来的部分重点针对这八百万如何操作。</li>
</ul>
<p>首先先介绍策略的理念，然后介绍具体买哪些品种，同样资金需要按比例分配到各个不同的子策略和品种上。</p>
<p>我会按 2:3:5 的比例来分配这剩下的八百万资金，也就是 160 万、240 万和 400 万，分别用于短期、中期和长期的投资策略。为什么要这样分？因为这应该是一个全天候的策略。市场的走势是没法预测的，不同的走势需要不同的策略要应对，具体来说短期策略用于市场在中底部不断横盘震荡的时期、中期策略用于有较大周期性波动特点的市场或品种、长期策略则是用真正价值投资的核心理念来收割大周期或宏观经济上涨的红利。其次，一个针对人性弱点的考量：为了让你在经历各种市场风浪手痒时不至于经常操作长期策略，可以用短期和中期策略来获得对市场的参与感。这三种子策略的理念分别是这样的：</p>
<p>短期策略 —— 完全按<strong>场内基金</strong>的<strong>网格</strong>策略来交易操作，这里我必须得直接贴上 E 大写过的系列文章，已经非常详细的把这个子策略如何操作的写得清清楚楚了，而且根据具体的实践这个子策略还在不断完善和进化中，我不必再赘述了（另外，文中提到的「留利润」的操作并不适合我，所以我并没有这样做，我自己会严格区分短期、中期、长期各个策略的界限，不期望用分配给短期的资金来赚取长期的利润，否则会让我自己的心态受到影响从而容易做出不理智的操作）：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/s/uxktt5ZpNo03FpQQX-aG7g">波段策略.网格之一：写在前面、体系以及策略</a></li>
<li><a href="https://mp.weixin.qq.com/s/-czfqGvxkDcay_tSI1jv5g">波段策略.网格之二：网格策略基础&#x2F;1.0版</a></li>
<li><a href="https://mp.weixin.qq.com/s/8pRKsjiQSZzrmH-uWCkRLQ">波段策略.网格之三：网格策略进阶&#x2F;2.0版</a></li>
</ol>
<p>中期策略和长期策略 —— 这两个子策略都用<strong>场外基金</strong>操作即可，因为它们都不会需要频繁的进行交易。中期策略和长期策略不同的是，中期策略会根据当时当下的市场状态和各个品种的估值分位进行买入卖出，对于各个品种的相互占比没有那么严格，目的是为了赚取雷达内的品种半年以上波动的利润；而长期策略则会严格考虑各个品种的配比，是按至少三年以上为一个完整的买入卖出周期的预期来衡量的，目的是赚取市场真正价值上涨的利润。</p>
<p>接下来讨论买哪些品种，注意，上述的三个子策略对于品种的选择方式都是一致的，只是长期策略需要更多的考虑品种的相对配比。可以这样来理解，长期策略占用了我们最多的用来投资的资金，作为压舱石，我们期望它是足够稳健和健康的，不会因为偏重于单一品种而使得这个策略有很大的波动和回撤。但是不同的品种在某一时期可能会处在各自不同的走势阶段，作为一个全天候策略，中期策略和短期策略此时就可以因地制宜灵活的对这一部分的需求进行补足。</p>
<p>要买的品种大致包含两大部分 —— 宽基指数和行业指数。先说一个有用的结论：买相关性低的品种能降低整个策略的风险，平滑整体收益曲线的波动。所以后面说的品种都是指的相关性低的大类，不会到具体的某个基金。另外，任何一个不可再分的大类品种仓位比例都不要超过 20%，同样是为了降低整个策略的风险 —— 即便投错也不至于错得太离谱。话不多说，结合前面所有的内容，直接上一个按比例配置的思维导图：</p>
<img data-src="/uploads/investment-strategy.png" class="" title="投资品种比例思维导图" alt="图片显示错误">

<p>必须再一次说明的是，图片中的比例和上文中的所有比例都不是一层不变的，需要根据个体情况和当前市场情况进行调整，但大的相对比例关系和基本的原则是不会轻易改变的。其次，图片中的某个品种的仓位比例是指<strong>仓位上限</strong>，不是每时每刻都要买满的，而且很多大类品种在不同的时期可能有更多的选择，比如 A 股的行业部分、海外成熟市场、商品等，都不局限于图上列出的那几种。另外如前所述，投资部分 80% 的资金会按 2:3:5 的大致比例分配到短期、中期和长期的子策略上。</p>
<p>最后还需要解决一个大问题：什么时候买、什么时候卖。这是最难的部分，我也还在不断的摸索之中，但你最好也能在真金白银买入之前就想好自己的具体买入卖出策略。</p>
<p>总体上还是按估值的原则来决定什么时候开始买，当某个品种开始进入低估区域的时候短期、中期和长期策略都可以开始买。<strong>假设</strong>一个品种从历史最高点跌了 50% 进入低估区域，跌到 20% 分位是可能的大底，那你的买入区域就应该分布在从最高点往下跌 50% ~ 80% 的区域。你可以提前把所有需要买入这个品种的资金分成很多份，从跌 50% 开始买第一份，到跌 80% 的时候可以把所有提前分配的资金份数买满，包括短期、中期和长期策略中的资金。至于如何判断一个品种是否开始低估，可以<strong>参考</strong>各种投资机构和市场大 V 出的市场温度表，或者自己计算。另外必须强调的一点是，<strong>一定要控制买入的节奏</strong>，如果一个品种到了低估区域，<strong>一般</strong>也要控制自己的中期和长期策略一个月最多买一到两份资金（网格买入取决于波动情况）。</p>
<p>如何卖出？短期（网格）策略一份资金的买入已经决定了这份资金的卖出条件，无需赘述。中期策略的卖出介于短期策略和长期策略之间，算是一个比较大的波段策略，当某份资金买入过了半年以上，收益率在 15% 以上且结合一些趋势分析判断可以考虑进行卖出。长期策略则卖出操作要少很多，你可以选择牛市不来坚决不卖，或者某份资金买入经过了三年且在趋势或基本面真正发生变化之际选择卖出这一份资金。如何卖出比如何买入更难，你需要根据每个子策略的基本原则和特点提前约定好你自己的具体卖出策略。这可以是综合价值投资、趋势投资和技术投资思想的综合分析。</p>
<p>最后，这套策略应当是在具体实践中根据经验不断完善改进的。注意的是，需要改进的是策略，而不是把某一次操作十分主观的归入某种例外。不断修正体系用来应对任何的市场情况，才会是一套可以复制和长期运行的全天候市场策略。</p>
<p>下一篇<a href="https://maples7.com/categories/%E6%BB%9A%E9%9B%AA%E7%90%83/">「滚雪球」</a>我大概率会讲讲个人如何记账，因为记账是投资入门的首要前提，这样才能在投资过程中随时了解自己的资金情况和分配于各个投资策略之间的资金比例关系。</p>
<p>P.S. 我本人不看好近两年世界宏观经济形势，股市有风险，入市需谨慎。</p>
]]></content>
      <categories>
        <category>滚雪球</category>
      </categories>
      <tags>
        <tag>投资</tag>
        <tag>指数基金</tag>
        <tag>资产配置</tag>
      </tags>
  </entry>
  <entry>
    <title>这一年多我都拍了些什么图</title>
    <url>/2022/09/06/what-i-shoot-this-year/</url>
    <content><![CDATA[<div class="group-picture"><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://slides.maples7.com/resource/img/2022-8/photo1.JPG"></div><div class="group-picture-column"><img data-src="https://slides.maples7.com/resource/img/2022-8/photo2.JPG"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://slides.maples7.com/resource/img/2022-8/photo4.JPG"></div><div class="group-picture-column"><img data-src="https://slides.maples7.com/resource/img/2022-8/photo5.JPG"></div><div class="group-picture-column"><img data-src="https://slides.maples7.com/resource/img/2022-8/photo6.JPG"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://slides.maples7.com/resource/img/2022-8/photo3.JPG"></div><div class="group-picture-column"><img data-src="https://slides.maples7.com/resource/img/2022-8/photo10.JPG"></div></div><div class="group-picture-row"><div class="group-picture-column"><img data-src="https://slides.maples7.com/resource/img/2022-8/photo7.JPG"></div><div class="group-picture-column"><img data-src="https://slides.maples7.com/resource/img/2022-8/photo8.JPG"></div><div class="group-picture-column"><img data-src="https://slides.maples7.com/resource/img/2022-8/photo9.JPG"></div></div></div>
]]></content>
      <categories>
        <category>视觉动物</category>
      </categories>
      <tags>
        <tag>FUJIFILM X-S10</tag>
        <tag>DJI mini 2</tag>
        <tag>千岛湖</tag>
        <tag>泉州</tag>
        <tag>苏州</tag>
        <tag>乌镇</tag>
      </tags>
  </entry>
  <entry>
    <title>尘埃落定，为什么我依然要力挺《二舅》</title>
    <url>/2022/09/04/why-i-support-erjiu/</url>
    <content><![CDATA[<p>这事儿都已经过去这么久了，热度也降下来了，应该没有人会指责我写这篇博客是为了蹭热度了吧？同样地，我也想问那些指责《二舅》视频作者创作动机的人，创作动机对作品本身呈现出的意义而言重要吗？带价值输出的作品的创作者必须是完美人设吗？</p>
<p>提前声明，本文仅针对原视频本身所呈现出来的内容讨论，不包括视频火了之后任何的讨论、解读、采访，更不必说一些空穴来风的臆断歪曲。</p>
<p>我为什么要力挺《二舅》，主要还是因为现在市场上对底层人民生活的记录和创作实在太少，几乎没有。对这些底层人民来说，你们这些生活稍微好一点的人觉得那是苦难的世界，其实也就只是他们的普通生活。任何有一定电影鉴赏能力的人看过了原视频都不会觉得作者创作这个视频是为了所谓的「赞美苦难」，与此同时，那些城市中产、掌握了互联网最大声量的那群中青年所认为是苦难的生活，在互联网、在媒体上几乎看不到任何的记录和讨论。这件事就像是房间里的大象，大家都不说，似乎也就不存在了。然而生活就是生活，真实就是真实。存在的就是存在，第一个说出来的人非但无罪反而理当得到赞扬。</p>
<span id="more"></span>

<p>有人指责《二舅》没有触及造成二舅人生悲剧的根本。如果你认真看了原视频，你可能只是故意忽视了一些什么，或者理解水平欠佳。任何中国人也都知道那条表达的红线是不是存在，你不去指责造成这个视频不能点名道姓触及根本的根本原因，反而来指责视频内容没有触及根本，你是不是也在这装外宾装大尾巴狼对房间里的大象视而不见呢？不是蠢就是坏，柿子不能专门捡软的捏吧。</p>
<p>还有人指责《二舅》里对二舅本人的人生经历造假。首先根据无罪推论原则，你先提供造假的证据而不是你们众口铄金的臆断再继续往下的讨论。其次，是不是造假对于 B 站 UP 主的视频创作而言重要吗？《活着》《平凡的世界》是造假吗？J.K.罗琳看到了一个戴圆形眼镜的小朋友就写出的《哈利•波特》是造假吗？普通人是不配进行文学创作吗？再次回到视频本身，任何有基本电影鉴赏水平的人都知道原视频的 BGM 和叙述节奏是想让视频呈现出怎样的影视风格，你总不会觉得这是一部纪录片风格的中视频吧？是创作就一定是主观的，就一定带有创作者本人的价值输出和主观表达，我们应该尊重任何人表达自己价值观的自由，二舅只是一个为了表达而借用的具体途径而已。最后，我推断至少作者没有做完全颠倒黑白说东道西的内容表达，这已经是在创作的底线之上。**在现在这样的社会环境下，敢表达、能表达就已经有其意义。**有些人不仅自己喜欢站在道德制高点上纲上线，还要求能站上原告席的一定得是个没有任何道德瑕疵的完美人。</p>
<p>也有人说《二舅》这种在农村很多啊，有什么稀奇的。有很多你也去拍啊，你要能创作成这样你也能火，我就不恶意揣测你纯纯的嫉妒心了。如果很多的话至于现在市场上这类的表达少之又少、越来越少吗？甚至都没有人敢讨论为什么这一类表达如此之少，我只能说，站着说话不腰疼，你行你上吧。站在一旁指手画脚确实是比弄脏自己的手要轻松得多。</p>
<p>文化产业一定是一个需要开放包容的土壤才能繁荣起来的产业。最近正在上映的电影<a href="https://movie.douban.com/subject/35131346/">《隐入尘烟》</a>的导演李睿珺说了这样一段话：</p>
<blockquote>
<p>一个电影市场，它应该是各种各样的电影都有才是正常的，<strong>一个市场的健康最重要是多元</strong>，比如超市就是有多种物品，可以让不同的受众去选择。方便面，有一块的，有五块的，甚至你有钱可以买十块的。但是假如说这个超市只卖一种方便面了，这是专卖店，不是超市，那它就不是个市场，那个市场其实就萎缩、死亡了。</p>
</blockquote>
<p>我只想对希望能继续看到好作品的观众说，创作环境已经这么不容易了，少一点对创作动机的讨论，多把注意力关注在作品本身吧。对于能填补市场空白的创作和表达，我认为这个行为本身就已经有其值得被肯定的意义。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>苦难</tag>
        <tag>创作</tag>
        <tag>电影</tag>
        <tag>文化产业</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 年书单</title>
    <url>/2022/12/31/2022-booklist/</url>
    <content><![CDATA[<p>Time flies，时间不等人，简直是一眨眼 2022 年又过去了。今年太难了，远比疫情刚开始的 2020 年还要难。</p>
<p>2022 是如何拥有一个「梦幻」一般的开头的：</p>
<ul>
<li><p>我记得我刚在老家过完农历新年回苏州才几天，苏州疫情正式爆发，等苏州疫情差不多控制住没几天，上海疫情开始爆发且远比之前苏州的情况更严重。作为上海的毗邻地区，苏州的管控变得比之前更加严格，我还记得整个 2、3 月我出小区的天数加起来应该都不超过 7 天。倒并不是我不能出门，而是我从来都尽量不愿意将自己置于可能的风险之中，或许天生如此，又或许是这几年投资的经历愈发培养了自己这方面的思维习惯。</p>
</li>
<li><p>除了与每一个个体息息相关的疫情，北京冬奥会之后的俄乌战争更是给全世界上空笼罩了一层庞大的乌云。我从来不认为战争离我们每一个人有多遥不可及，二战以来建立的国际秩序可能只是世界大战之后相对于漫长的人类历史而言的短暂的和平期，并没有我们想象的那么牢不可破。虽如此，这一次的事件也给了我们每一个人对于可能到来的世界战争更真实的体感，甚至可能是又一个普通的人类动乱年代阶段的开始。更让我感到担忧的是，一旦有一个国家开始打破国与国之间这种岌岌可危的互相牵制的平衡，后面大家都会不断突破这种下限。典型的国际局势的破窗效应，这种可能出现的危机成了萦绕在每一个地球人头上的达摩克利斯之剑。我对此比较悲观，虽然我不希望看到这种局面，但我觉得后面还会有比今年更大规模的战争发生，时间早晚问题，我们每一个个体应该对此早做思想准备和心理建设，或者其他可能的减少这种风险危害的措施。蝴蝶已经煽动了翅膀，世界已经已经进入到了一个高度不确定的时代，正如所谓的「百年前所未有之大变局」。</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>然后就是 3 月份的股市大跌，尤其是中概和恒生的板块，已经跌到了一个十年左右一次的底部区域。如果你了解我的投资理念，我当然会认为这是又一次十年一遇的难得的投资机会，并为此感到兴奋，而且也确实真金白银的抄了底。但当危机真正来临，市场信心不足时，每个人都难免会心生担忧，尤其是放到当时疫情、战争、世界经济复苏乏力、国际冲突、政策导向、油价高企、通货膨胀等各种各样看起来都对市场非常不利的因素之下。人类永远都会高估眼前的事情所带来的影响，即便你知道这一点，你也很难完全做到对正在发生的这一切心如止水。而且，世界真的会变好吗？不见得。一个更差的世界会让市场从此一蹶不振吗？很难说。当然，我已经用真金白银投出了我所认为的答案，但你没法拉动时间的进度条，这种对于未知的恐惧感，对于这一切危机如何消弭、持续多久的不确定性，没人能给出安慰和答案。</p>
</li>
<li><p>另外还有 3.21 东航 MU5735 空难事件，完全打破了大多数中国人过去一二十年的生活经验。在此之前，很难想象一个如此惨痛的空难真切的发生在大陆，而飞机在普遍认知里一直被认为是最安全的交通方式，尤其是在今年 2 月 19 日，中国民航运输航空持续安全飞行时间刚突破 1 亿小时、137 个月，创造了中国民航历史上最好的安全业绩，也创造了世界民航历史上最好的持续安全飞行纪录。一个月后，我们国家就发生了这种特大空难事件，太让人悲伤了。虽然，完全客观理性地说，小概率事件概率再小也终有会发生的那一刻，但感情上你还是很难相信这种事情就这么突如其来的真实发生了，同理心强的人很难不产生或多或少的替代性心理创伤。为所有遇难同胞默哀。而且，这件事的发生客观上无疑给在疫情下已经步履维艰的航空业又一记沉重的打击，可以说是「屋漏偏逢连夜雨」。</p>
</li>
</ul>
<p>2022 上半年发生的很多事情都已经仿若隔世，而后大半年同样充满了无奈、遗憾和巨大的不确定性：动荡的国际局势、难以控制的疫情而又越来越严格的防疫措施，让人们对未来没有任何稳定的预期，大家的心理底线被一个个离奇又魔幻的公众事件不断突破。不过，我个人觉得就年末的这些众所周知的变化来看，2023 年已经能够看到曙光，或者至少能够看到更后面的明确的希望。但是，能让世界变得更差的危险因素同样存在：主要的就是世界范围内各个阶层明显高涨的民族主义情绪，一不小心就有可能点燃一个巨大的「火盆」，致使人类踏入一个产生质变的更坏的大范围战争时期；其次就是可能出现的更致命的病毒毒株变异，或者全新的高致病传染性疫情，虽然短期内概率不大。当然也还有其他能够影响普通人日常生活的一些风险因素，但不适合在这里展开了。</p>
<p>还是照常给出今年的书单：</p>
<ol>
<li><p><a href="https://book.douban.com/subject/25899841/">The Swift Programming Language</a>：★★★★★</p>
<p> 作为 Stanford CS193p 的 Reading Assignment 一起看完的，课和书的质量都极其高。这种体验跟读 The Python Tutorial 的体验类似，都是官方出品的对编程语言方方面面准确、简洁、结构合理的入门读物。</p>
<p> Swift 结合基于 MVVM 模型的 SwiftUI，采用 Protocol-Oriented 的编程方式可以写出极富表现力的简洁的代码，这自然是很适合作为表现 UI 界面的语言的。当语言的表现力足够强时，对开发者绝对是最大的利好，是真正可以让开发者专注于问题的逻辑本身，减少在具体实现上耗费的时间。如果 Apple 官方能在 Swift 开源社区多下点功夫，将 Swift 带到更多的开发领域（比如后端，虽然已经有不少 Swift 的后端框架但非常小众），对苹果和开发者将会是双赢的事情。</p>
</li>
<li><p><a href="https://book.douban.com/subject/27608239/">原则</a>：★★★☆</p>
<p> 第一章关于作者的个人经历的半个人传记式的讲述很有意思，也对我很有启发。相对而言后面两章的内容就略显枯燥了，更像是那种看完就忘的正确的废话，而且很多原则已经被无意识的运用在了生活和投资之中，不过有这样系统的理论总结也还行吧。也准备看看《原则2》。</p>
</li>
<li><p><a href="https://book.douban.com/subject/10767124/">乡村教师</a>：★★★★</p>
<p> 依旧是有大刘强烈个人风格的作品，虽然很早期但是已经可以看出一些《三体》中某些概念的影子。这些作品总是以极度理性冷峻的视角，来述说极具人文关怀的关于生命和文明的未来史诗，也处处透露着大刘个性化的对地球文明的思考和反思。无所谓科幻的「软」和「硬」，都是理科生的极致浪漫。</p>
</li>
<li><p><a href="https://book.douban.com/subject/6798611/">史蒂夫·乔布斯传</a>：★★★★☆</p>
<p> 我很庆幸我没有在前十年这本书火热的时候跟风看，才得以在这样一个人类社会迷茫又即将迈入新的历史低潮期的时候从前一代变革者身上看到一些鼓舞人心的特质和行为，就类似我每次看电影《社交网络》的感觉一样，又能重新找回一点点初心和热血，同时也更坚定和印证了我最近在琢磨的一些想法。</p>
<p> 抛开乔布斯本人的生平来说，这本书写得是真不错，读起来有读小说的快感，而且草蛇灰线，甚至在人物传记的内容上也有不错的伏笔和反转。当然，乔布斯本人独特的性格和传奇的一生给了作者很好的创作素材。</p>
<p> 另外，不得不捎带提一嘴，这本书前半部分的笔记评论区的三观太不正了，几乎是乌合之众的典型，书里客观的记录了这样一个独特的人的各种性格缺点甚至是道德缺陷，这些潜意识里慕强的人却开始找各种理由从缺点中都要看出「伟人」的「鸡汤」，习惯性神化杰出人物，如果被乔布斯本人看到，绝对要骂这些人是一堆从众没有想法与创新绝缘的狗屎。这些人就像是那一群看意林长大的人。</p>
</li>
<li><p><a href="https://book.douban.com/subject/26418524/">万历十五年</a>：★★★☆</p>
<p> 再一次从历史中看到了非常多与现实的联系和相似之处。历史不会简单重复，但可能会押韵。如今社会的种种问题和现象，本质上又并不新鲜。官僚体制和官员队伍的风格深刻的影响着一个民族和国家的命运和前途，确需有好的与时俱进的体制保证其活力和执政水平。任何一个时代，都需要海瑞这样的理想主义者坚守信念和底线，什么时候人们实事求是的不再以海瑞为奇，那就是真正的天下大同之日。当然，其因循守旧、过分偏执、脱离实际的个人特质也自有其历史局限性。</p>
<p> 本书作者在书中有一些超越历史局限的主观评述，有过分上帝视角而缺少实据之嫌。</p>
</li>
<li><p><a href="https://book.douban.com/subject/36021722/">带上她的眼睛</a>：★★★★</p>
<p> 这几个短篇都带有强烈的大刘个人风格，而且都很有人文色彩，从这种角度来说，刘慈欣和乔布斯一样，也站在了科幻世界里技术和人文的十字路口。</p>
</li>
</ol>
<p>今年看完的书依然很少，明年我能看完的书肯定能更多。在一个混乱的时代背景下，你的注意力被一个个切实影响个人生活的事件所割裂，相信今年会让所有人更切实的感受到一个稳定可预期的社会环境对每个人正常可持续的生产生活的重要性。在社会生活里，我今年最切实的感受和呼吁就是，每个成年人都应该为自己所期待的理想世界和理想社会发挥自己力所能及的作用，不同的人生经历和经验让每个人的思想和观念都与众不同，不管你抱有怎样的社会理想和期许，你都应该积极的表达自己的观点，让世界往自己认为更美好的方向发展，尤其是那些本身受到了良好的教育、能辩证理智的看待问题、崇尚科学、实事求是、求真务实的人来说，你更应该尽自己所能，这个世界需要你的力量来朝更好的方向前进，社会生活需要你的声音来左右它的趋势。虽然真实的社会永远不会达到某个个体所期待的完美状态（历史经验表明，这种社会状态也挺可怕的，它很可能是让大多数人感到噩梦般的存在），愿人文精神和科学精神在这个世界上永存。</p>
<p>今年的糟糕是全民性的，我在<a href="https://maples7.com/2021/12/31/2021-booklist/">去年的书单</a>总结里说 “prepare for the worst”，一语成谶。不过，无论是我的主观愿望还是理性分析，最坏的时刻很可能已经过去，不管是短期的回光返照还是新的向上趋势的开始，2023 年都值得期待！</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
        <tag>社会生活</tag>
      </tags>
  </entry>
  <entry>
    <title>热情、工作与理想主义｜为什么我要离开微软</title>
    <url>/2023/07/25/why-i-leave-microsoft/</url>
    <content><![CDATA[<p>没错，经过长时间反复的考量，我终于还是从微软主动离职了。</p>
<p>我知道，在现在这个经济下行的周期阶段，从一个相对稳定、福利待遇又还不错的全球顶尖公司离职是一件很需要勇气的事情，尤其主动离职也没有任何补偿，甚至都不能申请失业金，但目前我依然认为我做出了一个大胆但正确的选择。暂且先卖个关子，我把我为什么从微软离职的直接原因先放一边，我想先在这篇博客说说什么是我理解的「热情、工作与理想主义」。其实，即便不离职我也已经想写这个话题很久了，但离职正好给了我一个更好的契机来谈论这个话题。</p>
<h2 id="理想主义"><a href="#理想主义" class="headerlink" title="理想主义"></a>理想主义</h2><p>我知道在这个年轻人解构一切的时代，「理想主义」在社交媒体的诸多语境下甚至都成了一个贬义词，但近几年我还是越来越自诩为<a href="https://twitter.com/Maples67">「坚定的理想主义者」</a>。一句话概括的话，我认为「理想主义」就是<strong>任何事情都要首先从其本质或普世价值上思考并行动</strong>。从本质和本源上开始思考，才能明辨是非、分清主次关系、把握逻辑重点。把这样的「理想主义」应用到工作上，就是要有热情的去做尽可能有意义的事情，而不是所谓的「工作就理所应当的仅仅只是一份工作」而已。</p>
<span id="more"></span>

<h2 id="热情"><a href="#热情" class="headerlink" title="热情"></a>热情</h2><p>什么是对一件事情有热情？</p>
<p>能让你有热情去做的事情，常常是能让你茶不思饭不想、睡不着觉脑子里都要想着去做的事情，而且从结果看，你往往能把这种能充分发挥主观能动性去做的事情做得超越一般水平。比如：写这篇博客，我就充满了热情，以至于我深夜睡不着觉到三四点也在构思我应该怎样清晰、准确、简练地表达出我真实的所思所想，并且都不会感到困倦。这也类似于我一直所追求的<a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E6%B5%81%E7%90%86%E8%AB%96">「心流」状态</a>。</p>
<p>目前可以让我产生原始热情的兴趣包括但不限于：写高质量的代码、做纯粹的 C 端产品、投资、摄影。</p>
<ul>
<li>「写高质量的代码」自不必多说，从高中开始编程以来我就觉得这个事情充满了魔力。</li>
<li>「做纯粹的 C 端产品」是我工作以来才意识到的能让我充满热情的事情，可能是大学时期曾经有过一段纯粹且不用考虑盈利地做互联网产品的经历，使得工作后的我格外怀念那个时期自由、纯粹、充满激情实现自己各种天马行空的想法的感觉。当然，这样的人生阶段可遇不可求，也与所处的环境有关，所以我也不会强求。</li>
<li>「投资」是这几年才开始的事情，投资固然是一个能够赚钱<del>（或者亏钱）</del>的事情，但我从这件事情上得到的纯粹的乐趣远比资产增值得到的乐趣更多，这有点类似于玩模拟经营类游戏的乐趣，而且是用自己的真金白银去玩。</li>
<li>「摄影」作为纯粹的业余爱好，是取悦自己的一种方式。取景器、快门声、构图、光线，来捕捉自己喜欢的画面，是一个能让自我愉悦的修行方式。目前我还只能把这件事作为纯粹的爱好去做，我猜想如果摄影变成了职业也许就没那么有趣了。</li>
</ul>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>每次我听到别人有「工作嘛，赚钱就行了，其他不重要」、「职业化的去工作」、「不要指望能在工作中去做自我提升」这类论断时，我其实都想在心里回一句：Bullshit! 当然这些论断都有其各自的合理性，这个时代百花齐放也各有各的活法，但却不是我认为的我应该找到的那份理想工作。</p>
<p>从上文就可知，以赚钱为首要目的的工作已经违背了我「理想主义」的本心，可是<strong>为什么「职业化」的工作也不行</strong>？这里的「不要职业化」当然不是说不要遵守各种职业原则和公司规范，而是当你过分的强调「职业化」的去做这件事情的时候，你的「工作」可能就沦为了一种看似非常专业的处理各种事情但其实并不真正用心的「上班」的事情。我承认，其实很多人（尤其是有多年工作经验的职场「老油条」们）追求的就是这种「职业化」的状态，但这是我想在我自己身上极力避免的。而关于要不要在工作中进行纯粹的无关商业的自我提升的部分，我认为这是理想工作所应该提供给职业者的一个最基本的条件，而不是一个可有可无的条件。理想的工作应该是个人和公司相互匹配、互相成就的，每个工作者都应该有从工作中提升自我、获得认同的权利，如果你的工作不能保证这样的机会和时间，那么这就不是一个理想的能与你双向匹配的工作。</p>
<p>让每一个人都能有热情的做有意义、有价值的事情，依然是我想不断追寻或创造的职业理想。有些公司的某些阶段是可以达到这种状态的，但想长期保持并让每一个员工都能时刻认同这一点非常困难，甚至有可能是达不到的。</p>
<h2 id="为什么从微软离职"><a href="#为什么从微软离职" class="headerlink" title="为什么从微软离职"></a>为什么从微软离职</h2><p>说了这么多形而上的「虚头巴脑」的东西，回到大家可能更关心的本文的主题，为什么我要从微软离职？如果用一句话来回答，那可以归结为我不愿意再浪费时间和生命在一个二十年的代码屎山上绣花。</p>
<p>首先还要做一个免责声明，微软是一个庞大的跨国公司，不同国家、不同部门、不同团队、不同产品、不同项目、不同人都可能产生截然不同甚至相反的体验和感受，所以我这里说的只能代表我个人，并不代表微软的普遍情况。但以我所了解的信息来看，我这样类似的感受也并不是个例，甚至很有代表性。</p>
<p>微软有其适合的员工类型，我前面所说的「职业化」的工作者在这样的大公司里应该会很适应并如鱼得水，但依我看微软不适合任何有创业心态的创造者。微软的大部分成熟项目和绝大多数岗位都非常适合职业化的工作者，最好还是不挑活儿的那种。如果你致力于用职业化的工作心态在微软干到退休，这将会是一个非常友好的平台。而于我而言，恰恰不能忍受的就是这个所谓的「职业化」。能够无差别的处理各种各样的任务和难题，这当然是一项非常厉害且被各种企业所追捧的职业打工人的能力，然而却是很难让像我这样的人学会的，我觉得这是因为我已经养成了时常需要质疑每个任务和工作的意义和价值的习惯。如果这个工作在我看来对产品很有价值（这个价值可能也并不是短期内商业上的价值），我会非常有热情的把它做得尽量完美，反之对于意义不大我打心底不认同的工作则会难以说服自己投入时间和精力去做到足够好。</p>
<p>另外，作为微软的一线开发，话语权是相当有限的，尤其是微软中国相对于美国总部的话语权。这也无可厚非，毕竟微软从根源上还是一家美国公司。在微软中国这边，一线项目开发的很多想法其实是没有机会去实践的，尽管我们有各种 hackathon week、FHL (fix, hack, learn) week，但大多数项目都是为了 hackathon 而 hackathon，有时候你明知道自己的主项目里有更本质更重要的问题亟待解决，但因为各种非本质的困难（往往是因为所涉团队甚广而无人可以协调），这些问题成为了房间里的大象，大家都选择性的视而不见或无人跟进处理。因为各种各样团队利益、个人利益的原因，人们都会愿意首先解决那些看似容易却很可能不本质的问题，而不去解决那些看似难却很可能更本质的问题。这并不是微软独有的问题，而很可能是大公司的通病。在这样的大公司，很多创意是无法面世的，一线员工可能是最了解某项业务的人，但他们所产生的想法需要层层往上 review，而任何一个 no 都有可能让这样的想法没法被支持，久而久之，大家都已经默契的知道哪些存在已久的问题是不用再提出来的了，因为他们都知道这样的问题提出来也暂时无人能去解决，除非有一个级别足够高、话语权足够重的人重新提出这样的问题，而这样的人往往也脱离一线开发太久，难以体会真实项目中遇到的痛点和难点。这种一线开发对自身项目和产品的失控感和无力感是让人感到很沮丧的。这也是我觉得微软这样的大公司不适合任何有创业者心态的人的原因。作为一个 Geek，通常需要烦恼的是经常性的创意不足，而在微软这样一个大公司里，最好不要有太离经叛道的创意，用最稳妥的方式拧好你的那一颗螺丝，这可能是公司或者更准确说是中间层领导对每个员工最真实的期待。这当然已经违背了我前面所说的「理想主义」原则。</p>
<p>最近正好在看<a href="https://book.douban.com/subject/26929955/">《腾讯传》</a>，我标记了这样一段话，我感觉放到微软这样的大公司身上同样合适：</p>
<blockquote>
<p>在马化腾看来，比自己对公司的控制力的丧失更可怕的，是公司自我生长、自我创新能力的丧失。用成熟的流程来管控公司，似乎避免了内部的冲突和纷争，但企业运行机制的官僚化日益明显，产品、研发按部就班，员工与部门有可能只对流程负责，而不对结果负责。这样的话，企业的创新能力必定下滑，自发的、原生态的创新能力将日渐萎缩。</p>
</blockquote>
<p>这也是为什么这个世界上总是不断在发生创业公司在某个领域打败垄断大公司的原因之一。</p>
<p>但不可否认，微软近些年在商业上堪称成功，从我粗浅的观察来看，我愿意将其归因于 CEO Satya 所领导的管理团队对科技发展趋势的准确把握，很多关键选择上押对了赛道、投资了关键的公司，使其在一波又一波的科技浪潮中始终保持着领先的地位。但依然，这并不代表微软就是一个理想的工作平台，尤其是对于那些有创业者心态的人来说。</p>
<h2 id="未来的打算"><a href="#未来的打算" class="headerlink" title="未来的打算"></a>未来的打算</h2><p>未来一段时间，我打算先去尝试做一些我一直想做但没有时间和机会去做的东西，学一些一直想学但没有时间系统学习的技术的和非技术的知识，跟技术社区建立更紧密的联系并做一些输入与输出。**不破不立，跟随本心。**所以我暂时也不会着急去找一份全职工作，但也不排除突然发现有很合适的工作机会并参与的可能。</p>
<p>我自认为我有比大多数同龄人更强的能去广泛接纳各种信息、认清形势和趋势并果断下注的能力，这也是我这些年从投资上认识和体会到的。在这个时代背景下，要做成一件事情，我一直认为<strong>选择的重要性已经越来越大于努力的重要性</strong>，好在我还比较擅长于接纳新鲜事物并做出限制条件下相对更优的选择。这并不是说要投机取巧，而是要清晰客观的认知自我、认知环境，做出最佳选择。当然，必要的努力同样重要，但正如我前面所试图论证的，找到真正有热情从事的工作，努力是自然而然的事情。</p>
]]></content>
      <categories>
        <category>一只代码狗的自我修养</category>
      </categories>
      <tags>
        <tag>理想主义</tag>
        <tag>工作</tag>
        <tag>热情</tag>
        <tag>微软</tag>
        <tag>离职</tag>
      </tags>
  </entry>
  <entry>
    <title>Maples7 个人开源计划（1）</title>
    <url>/2024/11/08/open-source-maples7-1/</url>
    <content><![CDATA[<h2 id="📑-前序"><a href="#📑-前序" class="headerlink" title="📑 前序"></a>📑 前序</h2><p>从微软离职以来已经有一年多了（原因和感受详见：<a href="https://maples7.com/2023/07/25/why-i-leave-microsoft/">热情、工作与理想主义｜为什么我要离开微软</a>），离职后的前半年基本在休养生息，顺便学习了一些 Apple 开发相关的东西，后半年开始写我几年来一直想写的一个财务类的工具 App，算是正式开始了我的全职独立开发之路。</p>
<p>不用上班之后我感受到了前所未有的自由，一种大学期间时常沸腾全身的创造力似乎正在回归。不上班不意味着不工作，上班经常是消磨热情和创造力的，而工作却可以是由热情和创造力来自我驱动的。可预见的未来一段时间，我感觉我都会非常享受现在的这种状态。</p>
<p>正是因为我开始有大把的时间能真正投入到自己的兴趣和热情所在，独立开发的过程基本也开始变得常态化，我决定开启一个全新的个人企划 —— 《Maples7 个人开源计划》。在这个计划里，我会尽可能定期地（周 or 月，取决于可分享的内容的多少）分享最近一段时间在工作（独立开发为主）、生活和投资领域的个人进展、所见所闻和个人感悟，并持续记录自己的资产动态变化。既为备忘自己未来独立开发一路的历程，也作为一个跟外界交流沟通的窗口（未来如果有谁好奇我最近一段时间又在鼓捣些什么玩意儿，我可以直接甩个链接了哈哈 &gt;_&lt;）。随着个人的变化和发展，也会动态变化记录的内容。总之，在这个纷乱的时代里，主打一个机动灵活。另外，人是复杂的有机系统，任何一个侧面都不足以概括一个个体的丰富性，但我力求能在这里涉及到所有我所关注的个人领域。</p>
<span id="more"></span>

<p>以下是第一期的《Maples7 个人开源计划》的内容。</p>
<h2 id="🧑‍💻-工作"><a href="#🧑‍💻-工作" class="headerlink" title="🧑‍💻 工作"></a>🧑‍💻 工作</h2><ul>
<li><p>正在写的<strong>财务类工具 App</strong> 第一版功能基本接近尾声，正在添加一些跟会员体系有关的功能，已经注册订阅了 Apple Developer Program，也准备研究一下是否需要注册一个一人公司来作为 App 的上架实体，相关的也会看看苹果 App Store 具体的上架流程。接下来准备继续完善功能，然后开始注册商标、软件著作权注册、备案等工作，之后就会开始进行内测、准备上架。</p>
</li>
<li><p>我目前的工作设备是 MacBook Pro 投屏到 Vision Pro 里面用大屏，已经这样使用了很长一段时间，这也是我有欲望购买 Vision Pro 的主要原因之一。解决了 Vision Pro 的佩戴舒适性问题之后，它的显示效果和无限制的屏幕空间是很能提升体验和效率的。最近正好 beta 系统版本带来了之前发布会演示的 Mac 投屏到 Vision Pro 里面的超宽屏，体验非常棒！Coding 体验进一步提升！相当于拥有了一个超大超宽的 4k 带鱼屏，我觉得这个就已经值回 Vision Pro 的票价了。</p>
</li>
<li><p>参与了 Swift 6.0 文档的中文翻译（SwiftGG 翻译小组）工作，相对贡献了比较多的工作量，找到了一些类似于以前 JS 社区的参与感。这个翻译成果不久后应该就会上线了。</p>
</li>
</ul>
<h2 id="🎲-滚雪球"><a href="#🎲-滚雪球" class="headerlink" title="🎲 滚雪球"></a>🎲 滚雪球</h2><p>最新资产配置比例的桑吉图：</p>
<p><img data-src="https://s2.loli.net/2024/11/08/CQgmSMzv24aHBVo.jpg" alt="此资产配置图使用我正在紧密开发的财务工具 App 生成"><center><small>(此资产配置图使用我正在紧密开发的财务工具 App 生成)</small></center></p>
<p>基于隐私的原因，我只会分享我的具体资产配置的各部分比例，以及在两次分享期间的资产增减值，而不会给出具体的总额绝对值（但根据两次的 delta 量其实已经可以大致推算出来了）。</p>
<p>神奇的是，虽然已经离职了一年多没有收入，我的总资产却还是增长的，这应该要归功于最近二级市场的不错表现了。</p>
<p>关于我的投资和资产配置体系，推荐阅读我曾写过的关于投资的<a href="https://maples7.com/categories/%E6%BB%9A%E9%9B%AA%E7%90%83/">「滚雪球」分类</a>下的两篇博客：</p>
<ul>
<li><a href="https://maples7.com/2022/03/13/how-to-start-investing-soundly/">《如何开始稳健投资》</a></li>
<li><a href="https://maples7.com/2022/08/20/a-specific-investment-strategy/">《一套大概率可行的具体投资策略》</a></li>
</ul>
<h2 id="♨️-生活"><a href="#♨️-生活" class="headerlink" title="♨️ 生活"></a>♨️ 生活</h2><ul>
<li>跟女朋友都分别一起过了难忘的生日（生日日期太接近），求婚大作战成功！❤️</li>
<li>最近在家做饭多了起来（homemade 小炒黄牛肉大成功！），虽然我还是不觉得在家做饭是一项「收益大于支出」的活动，但确实能提供不少家庭生活的情绪价值。</li>
<li>最近开始每天早上在太湖边慢跑快走半小时，可以保持一天的身心舒畅。</li>
<li>最近分别去了北京环球影城（第二次）、乌镇戏剧节（乌镇第三次，戏剧节头一回）玩，体验都很不错，尤其是跟家人朋友们一起出游，很棒！</li>
<li>推荐正在追的芒果 TV 综艺《再见爱人4》，目前看来每一期都大呼精彩！对婚姻关系和人性的解剖，算是少有的国内情感类综艺的精品之作。一起来做爱人文学家！😶‍🌫️</li>
<li>打算有空随意再看看《哈利·波特》的原著和电影，虽然作为多年哈迷已经对情节熟悉得不行了，但直到现在依然会对罗琳原著里的精彩描述吸引。</li>
<li>花最多时间在看的书是《货币战争》全集，虽然这本书一直争议很大，但是书中的论点却对当今世界政治经济的格局分析和走向预测很有参考价值。另外还在看一本网文《我在废土世界捡垃圾》，剧情也很精彩，确实是网文中以女性视角展开的精品。</li>
<li>虽然气温逐渐变冷对身体健康不是很好，但是很喜欢秋冬季节这种逐渐弥漫的节日氛围，总是能带来一种想要回顾传统和经典、与家人朋友一起慢慢度过的温暖的感觉。词穷了，很难准确形容这种感觉。</li>
</ul>
<p>2024-11-07<br>苏州</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>资产配置</tag>
        <tag>Maples7 个人开源计划</tag>
        <tag>独立开发</tag>
      </tags>
  </entry>
  <entry>
    <title>2023 年书单</title>
    <url>/2023/12/31/2023-booklist/</url>
    <content><![CDATA[<p>一转眼又是一年过去了，2023 年算是个人生活变化比较大的一年。长达三年的疫情生活终于过去，个人生活逐渐回归正常，也开始继续遵循本心勇敢做自己、追寻自己真正热爱的事情。从书单就可以看出这种变化。</p>
<ol>
<li><p><a href="https://book.douban.com/subject/35546622/">置身事内：中国政府与经济发展</a>：★★★★★</p>
<p> 一本论述非常精彩的适合普通人阅读的通俗入门中国特色政治经济学著作。关于央地关系、土地财政、地方债务、官员腐败、城市化、高房价、阶层固化、发展不平衡等热点话题的讨论很有吸引力。普通人应该读这本书来了解国家政策背后的层层决策逻辑和当下面临的社会问题；体制内的做具体实务的人更应该读这本书来培养自己在固有约束下系统化全面解决社会问题的思维和能力。</p>
<p> 很少有经济学书籍能让人看得津津有味欲罢不能，一是这本书探讨的都是当下政治经济学领域最紧迫热点的一些问题，二是作者的论述深入浅出而又一针见血丝毫不拖泥带水，这是长期积累深入调研后的结果。</p>
<p> 另外这本书通篇都在潜移默化的告诉读者一个老生常谈的道理：任何理论都要结合具体的社会实践才能发挥作用并获得打磨，实事求是，实践出真知。</p>
<p> 作者对未来中国的经济是偏乐观态度的，虽有争议但无伤大雅。</p>
</li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p><a href="https://book.douban.com/subject/26929955/">腾讯传1998-2016：中国互联网公司进化论</a>：★★★☆</p>
<p> 书本身写得差强人意，不过补足了一些我自己对腾讯早期发展历程的了解。</p>
<p> 从长期来看，我认为腾讯依然是目前中国唯一一家有可能媲美、超越那几家世界顶尖科技互联网公司的中国公司。我并不是说中国公司现在一定比不上世界一流公司，而是说一家公司能否保持长盛不衰依然需要时间的检验。但腾讯目前依然是最有这个可能性的，这是公司基因和领导人团队所决定的，能让它不至于成为像我们已经见得多的某个时期的昙花一现的原因，成为世界科技互联网公司常青树之一。</p>
</li>
<li><p><a href="https://book.douban.com/subject/36357804/">为什么伟大不能被计划：对创意、创新和创造的自由探索</a>：★★★★</p>
<p> 几乎每一句话我都想划线。虽然作者的论述不是那么的简洁有力、论证逻辑也不是那么的 solid，但本书所产生的结论我完全赞同，这更多可能是基于我对人类社会、自然世界观察和思考的直觉所产生的。</p>
<p> 概率思维和偶然性的重要性在这个极度内卷、功利、目标导向的时代被极度弱化，最终会导向一个没有活力、创新力孱弱的市场和社会。用贪心算法获得的局部最优解并不一定是全局最优解，这时候我们需要站在全局视角进行动态规划，但人类并没有预测未来的上帝视角和能力。所以，唯一的解法应该是让更多的人能自由地探索自己、探索社会、探索宇宙，这应该成为一种理想主义人类共识。</p>
<p> 本书所阐述的思想有利于人们认知现实世界的真相，对投资领域的大道也有贯通之感。而且，人类通过研究人工智能同时也对人类智能有了更深刻的认知。这本书对从事创新、创造领域的人的启发性，可能堪比《人月神话》对软件开发从业者的启发性。另外，这本书在读者评价上的分化与争议，正好与本书的理论自洽，真正的「寻宝者」会认同本书的观点。</p>
</li>
<li><p><a href="https://book.douban.com/subject/5437113/">窗边的小豆豆</a>：★★★★★</p>
<p> 东亚文化圈有很多内在的东西其实都是相通的，在这样一个功利浮华的时代，这本书应该给了很多有理想的人一个践行理想主义教育的英雄主义梦想。</p>
</li>
<li><p><a href="https://book.douban.com/subject/3674537/">明朝那些事儿（1-9）</a>：★★★★</p>
<p> 这本书的语言风格，上承百家讲坛网文小说、下接短视频解说影视剧，难怪这么脍炙人口、引人入胜（畅销）。</p>
<p> 读史明智，现实中也能时常看到历史的影子。沧海桑田、斗转星移，中国历史上不乏小人，更不乏舍身取义的英雄人物，人性善恶推动着历史不断向前，而兜兜转转，历史自有其公道。国家兴亡，匹夫有责。</p>
</li>
<li><p><a href="https://book.douban.com/subject/25899841/">The Swift Programming Language</a>：★★★★★</p>
<p> 跟 <a href="https://cs193p.sites.stanford.edu/">Stanford CS93p</a> 一起，全部重刷了一遍，算是对苹果这一套生态开发的入门，依然还是感叹于官方的文档写得真的完美。<a href="https://maples7.com/2022/12/31/2022-booklist/">去年也已经评价过</a>，这次就不多说了。开始入坑苹果生态开发，一方面是这个生态对独立开发比较友好，另一方面是我对 Vision Pro 这个全新的「空间计算」平台非常看好，我相信这个平台会给世界的下一个十年带来巨大的变革和机会。</p>
</li>
</ol>
<p>今年总体看过的书数量并不多，但我觉得看的每本书的质量都非常高，而且有大部头《明朝那些事儿（1-9）》全集，其实阅读量比前两年更多。<a href="https://maples7.com/2023/07/25/why-i-leave-microsoft/">我在七月底从微软离职</a>，没有了上班的烦恼，从而有更多的时间和精力来自由涉猎更多自己真正感兴趣的内容。从今年的书单可以看出我所关注的东西的变化，可能是随着年纪的增大和心智的成熟，也可以说是少了年轻的冲劲和对未来的憧憬，我明显开始更多的对现实主义的题材和话题更感兴趣，一方面这与个人的心智成长有关系，也跟社会大环境的快速变化有关系。</p>
<p>去年年底，大部分人都预期随着疫情的过去，2023 年百废待兴、万物复苏。现在 2023 年已经过去，实际情况可能低于很多人的预期。不过我依然认为，2023 年总体上看还是要比疫情期间要好。只是当现实情况低于大多数人的预期时，市场情绪会放大这样的趋势效应。2023 有两大亮点会深刻影响未来世界的发展：一是 AI 技术的爆发，这次很可能会带来质的突破，而不是像前几次一样的技术泡沫；二是由 Apple 带来的「空间计算」设备 <a href="https://www.apple.com/apple-vision-pro/">Vision Pro</a>，会带来全新的人机交互方式和极致的消费电子体验。这两个科技新事物都会带来全新的机会和变革，我相信会在未来十年左右的时间里深刻影响人类社会的发展。另外，有很多新技术趋势也让人感到兴奋和惊喜，我不会轻易说现在已经在发生第三次工业革命了，但这样的趋势很可能已经在进行中。科技的发展将解决人类社会面临的很多问题，但也会带来全新的命题，这是不可避免的，但我相信人类社会会在这样的变革中不断进步。</p>
<p>今年算是个人职业道路的重要转折之年，同时我也认为现在这个社会发展趋势阶段值得每一个人深刻思考自己能在未来的世界发展中扮演什么样的角色。主流叙事说现在是「百年未有之变局」，我觉得这个判断是非常正确的。在这个巨大的转折和变化面前，每个人都需要思考以前所积累的知识、经验、认知和思维方式是否还适用于未来的世界，如果不适用，又应该如何去适应和改变。我觉得这是每个人都需要思考的问题，也是每个人都应该思考的问题。</p>
<p>从我个人而言，我希望能在微软离职之后，能充分遵循本心，在变化和混乱的时代发展阶段中，找到自己的真正价值所在，做真正自己想成为的人。具体来说，我会从独立开发出发，丢掉一切历史包袱，从零开始探索一条全新的职业道路，希望能积累到一些这方面经验。同时，我也会继续关注科技领域的发展，尤其是 Vision Pro 能带来的机会和变革。因为在上一篇博客<a href="https://maples7.com/2023/07/25/why-i-leave-microsoft/">《热情、工作与理想主义｜为什么我要离开微软》</a>中提到过，我对「做纯粹的 C 端产品」是有热情的，苹果的新计算平台很可能会带来新的产品发现。</p>
<p>最后，我希望每个人都能在这个变化和混乱的时代找到自己的价值所在，做真正自己想成为的人。</p>
<p>2024 年，对世界、对人生，我同样充满期待！</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
        <tag>未来</tag>
        <tag>科技</tag>
        <tag>趋势</tag>
        <tag>职业发展</tag>
      </tags>
  </entry>
  <entry>
    <title>Maples7 个人开源计划（2）</title>
    <url>/2024/11/16/open-source-maples7-2/</url>
    <content><![CDATA[<p>因为公众号发的上一篇<a href="https://maples7.com/2023/07/25/why-i-leave-microsoft/">《热情、工作与理想主义｜为什么我要离开微软》</a>引发了一些讨论，所以这一期想聊的话题有点多。为了不让某一期的内容太长，所以尽管距离<a href="https://maples7.com/2024/11/08/open-source-maples7-1/">上一篇《开源计划》</a>才一周时间，工作量并不多，但也还是更新一期吧。</p>
<p>与前几篇文章相关的更多话题讨论在本文最后两部分，最后部分有回答网友的一些提问。</p>
<h2 id="🧑🏻‍💻-工作"><a href="#🧑🏻‍💻-工作" class="headerlink" title="🧑🏻‍💻 工作"></a>🧑🏻‍💻 工作</h2><ul>
<li>完成了 Apple Developer Program 的订阅注册，个人经验是：<ol>
<li>要耐心按照提示和邮件内容完成每一步的操作，该认证的认证，该实名的实名，遇到不明确的问题及时联系客服解决。</li>
<li>付费后账户不是立马就能用订阅后才能使用的开发者相关的功能，我是等了几个小时后收到邮件才开通成功。</li>
<li>可以使用 App Store 的余额进行开发者账号的订阅，而每年夏天腾讯基本都有 App Store 充值 900 送 100 的福利活动，相当于变相让订阅年费优惠一些。</li>
<li>订阅后可以<strong>马上申请注册 App Store Small Business Program</strong>，注册成功后以后靠 App 盈利可以少被 Apple 分走一部分「过路费」。🤧</li>
</ol>
</li>
</ul>
<span id="more"></span>

<ul>
<li>财务类工具 App 的新进展：<ul>
<li>得益于 Apple Developer Program 的成功订阅，加入了 iCloud 数据同步功能。是的，要实现这个功能必须通过订阅账户添加 iCloud capability 来实现。</li>
<li>相应的调整了一些 SwiftData 相关的代码以兼容 iCloud data syncing。不得不说，SwiftData 框架目前还相当不成熟，鲁棒性不强，有很多莫名其妙的问题，支持的功能也比较少，更缺乏一套官方推荐的标准工程化实践和开发模式，简直继承了 Xcode 的垃圾。只能希望 Apple 官方团队尽量多投入资源大力优化一下开发体验，工具链太差积重难返还不如推倒重来。</li>
</ul>
</li>
</ul>
<h2 id="🎲-滚雪球"><a href="#🎲-滚雪球" class="headerlink" title="🎲 滚雪球"></a>🎲 滚雪球</h2><p>最新的资产配置比例的桑吉图：</p>
<p><img data-src="https://s2.loli.net/2024/11/16/T1RbgtHE2GvyZ5r.png" alt="此资产配置图使用我正在紧密开发的财务工具 App 生成"><center><small>(此资产配置图使用我正在紧密开发的财务工具 App 生成)</small></center></p>
<p>从上一次分享到这一次的过程期间（2024-11-07 ~ 2024-11-16），资产净值<strong>减少 ¥42300</strong>（<del>居然正好是个整百数，很神奇</del>），原因主要来自于二级市场的自然涨跌。执行的投资操作有跟随长赢计划卖出金融地产、证券保险、信息技术相关 ETF 部分份额。</p>
<p>因为这次内容比较长，下次有机会我再介绍一下我的投资类目下的各个资产大类分别是什么。</p>
<p>关于我的具体投资策略，可以查看<a href="https://maples7.com/categories/%E6%BB%9A%E9%9B%AA%E7%90%83/">「滚雪球」合集</a>下的文章。</p>
<h2 id="♨️-生活"><a href="#♨️-生活" class="headerlink" title="♨️ 生活"></a>♨️ 生活</h2><ul>
<li>前一篇忘了说，国庆去北京还看了郑钦文中网现场的比赛，很幸运还近距离看了她的训练现场，她个人网球在今年的大突破，也是中国网球的一次飞跃。而且神奇的是，她似乎能吸收每一个跟她交手过的对手的能力，这一点从奥运会看尤其明显。我私底下都说她练的是吸星大法，进步神速。虽然看得出还有需要再练习的方面，但感觉按这个势头拿下大满贯只是早晚的问题。而且她强大稳定、不骄不躁的比赛气质和内核，以及采访中得体流畅、思路清晰的谈吐，很让人钦佩。👍</li>
<li>换了新的眼镜🤓，从戴了好多年的 <a href="https://www.tapole.cn/">Tapole</a> 经典的 3&#x2F;4 款（李诞同款，或者说哈利·波特同款？）换成了 Matrix 款，本来是想换 3&#x2F;4 最新款的 3&#x2F;4s 的，但去线下试戴了之后发现似乎 Matrix 更适合我。</li>
<li>去上海配镜验光顺便跟朋友去了一次久违的 KTV，找到了一些美好大学时光的感觉。😊</li>
<li>断断续续看完了<a href="https://movie.douban.com/subject/28427782/">《我的天才女友》电视剧的第一季</a>，可能是因为性别视角的原因，没感受到太多细腻的情感共鸣，或许直接看原著会更好一点，这个碎片化的情节和细腻入微的情愫我感觉是不太适合影视化表达。👀</li>
</ul>
<h2 id="💡-一些近期的感悟"><a href="#💡-一些近期的感悟" class="headerlink" title="💡 一些近期的感悟"></a>💡 一些近期的感悟</h2><h3 id="为什么我越来越把「知行合一」挂在嘴边？"><a href="#为什么我越来越把「知行合一」挂在嘴边？" class="headerlink" title="为什么我越来越把「知行合一」挂在嘴边？"></a>为什么我越来越把「知行合一」挂在嘴边？</h3><p>估计跟很多人一样，除了历史书里的王阳明，更深入生动地了解王阳明的事迹是通过<a href="https://book.douban.com/subject/3674537/">《明朝那些事儿》</a>这本书，在这本书里也可以看出作者对王阳明的崇拜，绘声绘色地讲述了王阳明的事迹，仿佛天神下凡。</p>
<p>看过这本书的都知道，「知行合一」绝不仅仅是字面意义上容易理解的道德标准，<strong>更是一种处理事情的方法论的核心理念</strong>。</p>
<p>用我自己的理解来高度概括的话，就是在自己认知和行动的达成一致的情况下，通过这种一致性来面对和处理遇到的问题。但它不是迂腐教条的照本宣科（比如王阳明之前的一些唯心哲学）或没有底线的胡作非为，而是在对世界和现实情况的准确认知下，用创造性的方法解决问题，并且这种方法要在不逾矩的过程下最终达到目的和胜利。<strong>既讲究解决问题过程中的合规合理和理想主义，也强调脚踏实地对是否达成期望结果的在意。<strong>而不是像更多他之前的清高唯心学派所推崇的：只在乎过程，不在意结果。唯有真正的「知行合一」才能做到这一点，这是真正的</strong>既抬头看星空，也要脚踏实地</strong>。</p>
<p>我觉得这跟我常说的「<strong>理想主义</strong>」、马斯克的「<strong>第一性原理</strong>」的内核思想都是相通的。或者说这是一种「实事求是」的「理想主义」：「理想主义」的点在于主观上对真理的执着，「实事求是」的点在于在解决具体问题的路径和方法上着眼实际情况地因地制宜。</p>
<p>再高度凝练一下，或许可以概括成<strong>既「求真」又「务实」</strong>。</p>
<h3 id="人为什么需要了解历史？"><a href="#人为什么需要了解历史？" class="headerlink" title="人为什么需要了解历史？"></a>人为什么需要了解历史？</h3><p>以前对历史不感兴趣，大概是枯燥的历史课本带来的不好体验（可见好的学习方式对人的成长和开化有多重要），现在越来越体会到「读史使人明智」的真义，引用正在看<a href="https://book.douban.com/subject/27111654/">《货币战争》</a>中的这段话可以很好的回答「为什么要读史」的这个问题：</p>
<blockquote>
<p>研究历史的重要性，体现在为今天的困境梳理出清晰的脉络。尽管历史不会是简单的重复，但在历史中不断反复的人性本质，却有着惊人的相似之处。毕竟，经济史和货币史就是人类在有限资源的制约下，不断求取财富极大值并试图控制财富分配权力的历史。</p>
</blockquote>
<p>其实真实的历史远比历史教材中高度凝练概括毫无人性的冷漠句子更有趣，至少我觉得从马伯庸的一些基于史实的历史小说入手，大部分人应该都能发现真实历史的乐趣。另外，畅销多年的<a href="https://book.douban.com/subject/3674537/">《明朝那些事儿》</a>也很推荐，搭配<a href="https://movie.douban.com/subject/2210001/">电视剧《大明王朝1566》</a>服用效果更佳。</p>
<h3 id="热情、工作、价值创造"><a href="#热情、工作、价值创造" class="headerlink" title="热情、工作、价值创造"></a>热情、工作、价值创造</h3><p>最近也在<a href="https://book.douban.com/subject/27111654/">《货币战争》</a>里看到作者在序言里写的这样的话：</p>
<blockquote>
<p>当一个人在从事自己最有天赋的事情时，不吃不喝不睡也不会觉得痛苦，因为他正在努力为社会创造性地贡献价值。事实上，世界上的每一个人都与生俱来地拥有某种天赋，一个人最大的幸福就是能够尽早地发现自己的天赋。而大多数人的悲哀就在于不知道，或者放弃了自己的天赋。在我看来，教育、读书、工作和生活的全部目的，就在于找到自己的天赋，它是与生俱来的，它是不可改变的，探索并发现它将是一生的重任。</p>
</blockquote>
<blockquote>
<p>我一直有一种信念：一个人的价值，不体现在与别人相同的东西上，而体现在与别人不同的东西上。</p>
</blockquote>
<p>跟我开启这个<a href="https://maples7.com/2024/11/08/open-source-maples7-1/">个人开源计划的前序里（上一篇）</a>写的内容不谋而合，也是我一直信奉的工作理念 —— 因为热爱而工作才能发挥个人最大的创造潜能并创造社会价值。也是我在<a href="https://maples7.com/2023/07/25/why-i-leave-microsoft/">《热情、工作与理想主义｜为什么我要离开微软》</a>中所表达的意思。</p>
<h2 id="🎙️-回答网友的提问"><a href="#🎙️-回答网友的提问" class="headerlink" title="🎙️ 回答网友的提问"></a>🎙️ 回答网友的提问</h2><h3 id="是不是自身家庭条件不错（才能支撑你离职一年多的自由探索和鼓捣）？（注：括号中的内容是本人根据上下文补充）"><a href="#是不是自身家庭条件不错（才能支撑你离职一年多的自由探索和鼓捣）？（注：括号中的内容是本人根据上下文补充）" class="headerlink" title="是不是自身家庭条件不错（才能支撑你离职一年多的自由探索和鼓捣）？（注：括号中的内容是本人根据上下文补充）"></a>是不是自身家庭条件不错（才能支撑你离职一年多的自由探索和鼓捣）？（注：括号中的内容是本人根据上下文补充）</h3><p>在<a href="https://maples7.com/2024/11/08/open-source-maples7-1/">上一篇《开源计划》</a>的公众号评论区，有网友好奇是不是因为我自身的家庭条件不错才有勇气离职一年多不工作。刚看到这个问题我是觉得好笑的，但转念换位思考一下有这样的好奇和联想在现在这样一个财富和阶级分化愈发严重的时代背景下也可以理解。「他&#x2F;她就是因为有钱才能怎样怎样」、「他&#x2F;她就是因为有关系才能怎样怎样」，这样的说法在近年互联网上也屡见不鲜，普通人在这个社会达尔文体系下可以以此在个体比较上获得一些道德上的安慰感，也确实有很多人是主要依赖外部资源才能做到某些普通人难以做到的事情。</p>
<p>回到问题本身，<strong>我个人肯定不会认同这个判断</strong>。直接回答这个问题就是我自认为我家庭条件很普通，父母都不需要交个人所得税，这样的家庭条件在物质上至少应该谈不上有多好吧。（不过，我依然很感恩父母尽他们所能从小到大给我提供的一切物质和非物质的条件和资源，尤其是那些非物质性的、潜移默化的有关做人的宝贵品格和精神财富的影响，塑造着我的三观，影响着我现在做出的每一项人生选择。）</p>
<p>首先：</p>
<ol>
<li>离职一年多不工作没收入不是一件多么了不起、代价多高的成就，不需要有多殷实的家底作为支撑。工作这么多年所积累的物质资源就足以让我不止一年地继续自由探索下去。</li>
<li>利用合理的投资和资产配置策略，正如上一篇所说，相比于刚离职时，我的个人总资产非但没减少，而且还有增加。**什么是「财务自由」？**不同的人答案不同，但一个最朴素的定义就是「<strong>长期稳定的被动收入大于支出</strong>」。**表面的自由（比如表面上的不上班）不是自由，财务自由才是真正的自由，因为财务自由意味着一个人有物质能力做到时间分配上的自由。**为了达到真正的自由，我依然在努力的过程中，我可能依然会需要出卖我的时间换取一般等价物，上班或者不上班都只是为了实现这个目标的不同途径和选择。请尽量不要因为一个表面上的状态或标签就轻易做出价值判断。</li>
<li>我同样也是一个需要面对诸多生活压力、困难和挑战的平凡普通人，普遍性的问题我同样也会有，但面对这些问题，个体不同的应对处理方式和做出的选择会让最后的结果大相径庭。我自信我认真思考权衡后做出的人生选择和行为是适合我的、会让我舒服的。</li>
</ol>
<p>其次，这个问题的潜台词是「家庭条件好的人拥有更多自由选择的机会」。从统计学的意义上，我肯定不否认这样的论断，人生选择的机会成本对于不同家境的人来说肯定不一样。但我同样不否认个体的主观能动性所能带来的巨大影响。我不把这种主观能动性与所谓的「努力」划等号，因为这种主观能动性除了必要的努力，还包括智慧、认知、机遇、<strong>甚至是个人的运气</strong>等等。**「世界上只有一种真正的英雄主义，那就是在认清生活真相之后依然热爱生活」，在琐碎的日常生活中「入世」、在丰富的精神世界里「出世」，学习先贤苏轼和王阳明，做一个乐观的悲观主义者，这是我的人生态度。**如果你觉得是家庭条件限制了你勇敢迈出那一步的勇气，不妨想想你自己又为着那个目标做出了哪些主观能动性呢？</p>
<p>最后，<strong>人生是旷野不是轨道，少一点优绩主义和功利主义所带来的束缚，专注于自我内在价值的提升和成长，人生会更加开阔和从容一些</strong>。你我都不是需要在福布斯富豪榜上争雄的人物，何不豁达一些，多赚一点少赚一点又有什么本质上的差别呢？</p>
<h3 id="如何平衡物质条件与无稳定收入的自由职业？如何找寻自己热情和感兴趣的方向？"><a href="#如何平衡物质条件与无稳定收入的自由职业？如何找寻自己热情和感兴趣的方向？" class="headerlink" title="如何平衡物质条件与无稳定收入的自由职业？如何找寻自己热情和感兴趣的方向？"></a>如何平衡物质条件与无稳定收入的自由职业？如何找寻自己热情和感兴趣的方向？</h3><p>有网友加微信咨询这方面的建议。这里应用前文所述的王阳明「知行合一」的方法论来说明这个问题。我是不太赞同忽视现实的物质条件情况一厢情愿地去盲目逐梦的。我一直觉得做事情首先要让自己觉得舒服，无论是物质上还是精神上，自己舒服的情况下才能做好事情、才能做出有创造力有灵气的产品。</p>
<p>所以如果你暂时还上着一份无聊又不自由的班，可是又没有明确自己自由职业的方向，我建议先慢慢积累物质上的条件，先看看有没有什么不依赖上班的工资也能覆盖自己日常支出的办法，同时也不断尝试自己感兴趣的事业和方向，学习相关的技能，等到物质条件上基本成熟，自己又比较明确方向之后再做下一步的人生选择。</p>
<p>而积累物质条件和探索自己的事业方向也可以是相辅相成的，做自己热情和感兴趣的事业，如果能为更多人提供有价值的产品和服务，可能比那些「只是上班打工的人」更容易也给自己带来物质上的回报。这是我目前觉得比较理想的职业情况，但每个人情况不同，这个还是得靠自己去慢慢探索。</p>
<p>这也是我要在<a href="https://maples7.com/tags/Maples7-%E4%B8%AA%E4%BA%BA%E5%BC%80%E6%BA%90%E8%AE%A1%E5%88%92/">这个《开源计划》</a>持续更新我的资产变化的原因之一。时刻了解自己资产配置和变化情况可能对一个有稳定收入的上班族还不是很重要（我认为其实也很重要），而对一个自由职业者来说就尤为重要了。<strong>脱离了物质基础的空想理想主义只是空中楼阁</strong>，每一个有机系统都是各个模块互相作用、互相影响的有机整体，只有尽量完整的描摹这个系统的每一个侧面才足以反映这个有机系统的真实情况。<a href="https://maples7.com/tags/Maples7-%E4%B8%AA%E4%BA%BA%E5%BC%80%E6%BA%90%E8%AE%A1%E5%88%92/">我的《开源计划》</a>所试图描摹的就是这样一个独立开发者的有机系统。<a href="https://buildinpublic.xyz/what-is-build-in-public">「Build in Public」</a>，一起精益独立开发！</p>
<p>而所谓「知行合一」的哲学在这一点上的应用，就是要既「求」有价值、有意义、有热情地工作中的「真」，又「务」工作必须得带来物质回报的「实」<del>（一般等价物&#x3D;产品和服务，提供有价值的产品和服务获取一般等价物天经地义。对不起最近看《货币战争》有点多😆。）</del>这就是前文所说的我理解的「知行合一」中体现的「求真」、「务实」的理念。</p>
<h3 id="「知行合一」的人不是应该不再「理想主义」了吗？"><a href="#「知行合一」的人不是应该不再「理想主义」了吗？" class="headerlink" title="「知行合一」的人不是应该不再「理想主义」了吗？"></a>「知行合一」的人不是应该不再「理想主义」了吗？</h3><p>这个疑问来自于<a href="https://maples7.com/2023/07/25/why-i-leave-microsoft/">《热情、工作与理想主义｜为什么我要离开微软》</a>的公众号评论区的网友，有这个疑问可能是因为在这两个概念上与我有着不同的理解。</p>
<p>在我看来，正是因为「理想主义」给我带来的追求工作本源的意义和价值所带来的求真的「知」，才指引我走向主动离职微软探索更有创造力的工作的「行」，这正是我认同的「知行合一」的行为哲学指导下的行动。</p>
<p>**「理想主义」不等于「盲目空想」的凭一腔热血无脑行动、「知行合一」不等于「妥协求全」的改变自己的认知不再求真地向现实情况低头。**这个因果关系不是反向的，不是因为认识到了现实情况已经是如此糟糕了，所以要调整自己的「认知」并强迫自己「行动」上去适应这样糟糕的现实情况，<strong>因为那些真理、那些本源的东西、那些事情背后真正的价值不会因为大多数人所被迫接受妥协后的现实就消失</strong>，这种最基本的「真」不会因为世事变迁而轻易转移。比如，工作天然就应该提供意义和价值，劳动者本应有热情地从事自己的工作。而不是因为在现代这个社会背景下已经很难找到一份达到这样标准的工作了，就强迫自己来适应这样糟糕的社会现实。再比如，道路上的每一个司机开车本应都遵守交通规则，而不是因为违反规则的人多了，就调整自己的认「知」去从众的也在「行」为上违反规则（更具体一点，假设你知道大部分司机变道都不打转向灯的社会现实，这不是说你也要顺应大众也变道不打转向灯，而是自己要遵守变道打转向灯的规则的同时，但也不妨碍你要采取防御性驾驶的行动防范别人不打灯突然变道到你前面而追尾的风险）。</p>
<p><strong>「务实」之前务必先「求真」</strong>，否则可能会轻易丢失原则，甚至误入歧途。**「知」指导「行」，而不是反过来。**这不是说「行」的时候不用考虑现实情况，而是即便在这样的现实情况下，你的「行」也应该是朝着那个最终的「知」的初心而去的，而不是因为现实情况太不理想你的「知」的终点就轻易挪动了位置。当然，前提是你的「知」确实是「真知」，而不是幼稚的一厢情愿。在真实的实践中个人的认知会逐渐调整并趋于完善，但这样的调整绝不是没有原则的随意调整，<strong>认知到这样的社会现实不代表这样的社会现实就是合情合理的「真知」</strong>。还是那句话，有些真理和根源上的东西不以社会现实而转移，正确的认知不应违背这些本质的规律和道理。</p>
<p>还是如前文所述，「理想主义」更像是指引着我「真理」所在方向的北极星，而「知行合一」更像是在「理想主义」的这种真「知」下，提供给了我一套要脚踏实地用创造性的方法实现目标的「行」动方法论。这可能是一条更困难的路，但却是一条很值得我去尝试的路。</p>
<p>希望我有表达清楚自己的理解。</p>
<p>2024-11-16<br>苏州</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>理想主义</tag>
        <tag>Maples7 个人开源计划</tag>
        <tag>知行合一</tag>
        <tag>财务自由</tag>
        <tag>Apple Developer Program</tag>
        <tag>SwiftData</tag>
        <tag>郑钦文</tag>
      </tags>
  </entry>
  <entry>
    <title>Maples7 个人开源计划（3）</title>
    <url>/2024/12/01/open-source-maples7-3/</url>
    <content><![CDATA[<p>在 12 月的第一天，更新一下进展。</p>
<h2 id="🧑🏻‍💻-工作"><a href="#🧑🏻‍💻-工作" class="headerlink" title="🧑🏻‍💻 工作"></a>🧑🏻‍💻 工作</h2><ul>
<li><p>财务类 App 的新进展：</p>
<ul>
<li>增加了搜索的功能，让用户可以搜索自己添加的数据。</li>
<li>增加了用户可以自行控制是否使用 iCloud 进行数据同步的支持。</li>
<li>数据多设备异步云同步开启了一个黑洞，这是一个极易出现错误的功能，之前的数据逻辑都是基于本地单一数据库实现的，在加入这个功能后重新修正了不少兼容数据同步的逻辑。</li>
<li>本来想基于一整套更为抽象和规范统一的底层数据模型，进一步抽象代码中逻辑实体，更改对应的数据结构和逻辑，让处理规则变得更统一。这是一个比较大的工作量，因为所有基于底层数据模型的业务逻辑和 UI 都得相应进行修改，不亚于一次大版本的更新。但最终实践后发现这套更抽象的数据模型依然满足不了一些我想要的细节功能需求，或者说让这些小需求的实现变得更复杂了，所以还是回滚到到了我之前的更符合自然逻辑的版本。<strong>计算机科学的落地应用永远是在找最合适的抽象层级，寻找定制化的用户体验和统一的底层抽象原则之间的平衡</strong>。</li>
<li>优化了一些页面的 UI，解决了一些显示上的 bug。</li>
<li>开始实现会员付费订阅的页面、逻辑和功能。</li>
</ul>
</li>
<li><p>构思和打草稿《普通人如何正确记账》的内容。</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>花了不少时间调查我本地 Xcode 里面突然不能 push 代码到 GitHub，以及不能解析 GitHub 的包依赖的问题，后来解决了，经验是：</p>
<ul>
<li>国区众所周知的网络原因，专门为 git 配置了全局的代理。</li>
<li>根据 Apple 的文档，如果你在 Xcode 里面添加了 GitHub 账户，只有你自己的 repo、你团队的 repo 以及你 star 过的 repo 可以检索到。以前找到了想用的第三方包我都会随手 star 一下，所以之前都能找到，这次有个包一开始怎么都找不到，没想到是还有这个方面的限制。</li>
</ul>
<p>总之，在国区做开发，经常浪费很多时间调查各种网络问题，难度增加 30%；用时不时要出点幺蛾子的 Xcode 工具链做开发，企图用一个不稳定的开发工具做出稳定可靠的产品，难度增加 50%。</p>
</li>
<li><p>我目前的 Vision Pro 佩戴舒适度和移动方案基本上如下：</p>
<ul>
<li>#微信小店:&#x2F;&#x2F;殇小辛小卖部&#x2F;KVWBpsAPVjKSn7w</li>
<li>#微信小店:&#x2F;&#x2F;殇小辛小卖部&#x2F;I3TII8FpkgpRkBb</li>
</ul>
<p>苹果官方 Apple Store 其实也上架了贝尔金的头戴，旅行舱也一直都有，官方的体验想必也很不错。</p>
</li>
</ul>
<h2 id="🎲-滚雪球"><a href="#🎲-滚雪球" class="headerlink" title="🎲 滚雪球"></a>🎲 滚雪球</h2><p>最新的资产配置比例的桑吉图：</p>
<p><img data-src="https://s2.loli.net/2024/12/01/gPHD2ZUsT7tpYRw.png" alt="此资产配置图使用我正在紧密开发的财务工具 App 生成"><center><small>(此资产配置图使用我正在紧密开发的财务工具 App 生成)</small></center></p>
<p>从上一次分享到这一次的过程期间（2024-11-16 ~ 2024-12-01），资产净值<strong>减少 ¥11265.18</strong>，原因主要来自于二级市场的自然涨跌和一些大头的支出项。执行的投资操作有卖出「场外自助补充交易」策略大约 1&#x2F;10 仓位的恒生。主要支出项来自于计划跨年旅行的机票费用、接下来半年的车位费、灵活就业的基本医疗和养老保险，其他都是日常支出。</p>
<p>关于我的具体投资策略，可以查看<a href="https://maples7.com/categories/%E6%BB%9A%E9%9B%AA%E7%90%83/">「滚雪球」合集</a>下的文章。</p>
<h2 id="♨️-生活"><a href="#♨️-生活" class="headerlink" title="♨️ 生活"></a>♨️ 生活</h2><ul>
<li><p>🎬 看了邵艺辉导演的第二部电影《好东西》，又是一部我眼中的今年最佳电影，跟当年的《爱情神话》一样。接连拍出如此有灵气的好作品，邵导简直像是横空出世的天才，不仅拯救了今年如一潭死水般的积弊已久的中国电影市场，也拯救了中国的电影观众，邵导的电影可以让观众更爱电影，也更爱自己的生活。好电影本该如此，传达一种更健康、更人文主义的价值观。还有，邵导太特么酷了！</p>
<p><a href="https://www.douban.com/people/MaplesSeven/">我的观影完第一时间的豆瓣影评</a>如下：</p>
<blockquote>
<p>又一部邵艺辉，又是一部年度最佳！邵导太特么有才了！！！几乎没有什么导演能把女性视角电影拍得如此细腻、生动、充满日常生活的生命力，却又丝毫不说教沉重，但又如此的深刻和先锋，也不避讳任何敏感的话题，继承了《爱情神话》的生动灵巧。在需要搬出哈利波特八部救场的今年的中国电影市场，简直是今年唯一一部值得去电影院看的新片。精心打磨的剧本和幽默，不把观众当傻子，可以让观众重新热爱电影、热爱生活。</p>
</blockquote>
</li>
<li><p>一直在第一时间追《再见爱人》第四季，看得一期比一期生气😤。就像黄执中在节目里说的，这个世界不应该出现好的要向坏的妥协的事情，即便在婚姻关系里，也是存在是非对错的普世价值的，防止劣币驱逐良币的 regression 需要所有人的共同努力。再次强烈建议所有人看看这个综艺，以人为镜，反躬自省。</p>
</li>
<li><p>为了追《白夜破晓》，把《白夜追凶》看完了。第一季（《白夜追凶》）确实是质量还挺不错的类型片，尤其是前十五集的质量很高，但也不至于到封神的地步。第二季（《白夜破晓》）目前来看明显逊色于第一季。</p>
</li>
</ul>
<h2 id="💡-近期感悟"><a href="#💡-近期感悟" class="headerlink" title="💡 近期感悟"></a>💡 近期感悟</h2><h3 id="父权与厌女"><a href="#父权与厌女" class="headerlink" title="父权与厌女"></a>父权与厌女</h3><p>因为最近看的很多文艺作品里（《好东西》、《某种物质》，甚至《再见爱人4》）都有女性视角和女性主义话题，所以想记录一下自己从各种渠道学到的一些提升了我的个人认知的观点，也包括自己的一点思考，同时纠正一些互联网上常见的理解误区。</p>
<p>除了上面提到的作品，最近看到的这两个视频都很有启发，我下述的观点也是出自于它们，只是做了一些简单的概括：</p>
<ol>
<li><a href="https://b23.tv/3JstSpF">女导演拍男凝有罪吗？《某种物质》打脸了谁？-哔哩哔哩</a></li>
<li><a href="https://b23.tv/mlxYayq">从画像事件到熏鸡事变！麦琳发疯的本质是厌女？|《再见爱人4》深度解读01-哔哩哔哩</a></li>
</ol>
<p>这些有意思的观点是：</p>
<ul>
<li><p><strong>父权不是男权</strong>。在父权社会里，任何弱势群体都受到父权的压迫和剥削，无关性别。父权社会的代表人物也不一定是男性，父权只是在现代社会中更多的表现为男权为主体的统治结构（当然这也是现代社会的问题），但一旦女性上位变成统治者，那么她同样代表了父权。例如在格力电器公司环境下的董明珠，就是父权社会下的典型女性代表。父权很容易与资本或政治相结合，无差别的对自己统治下的所有的更弱势群体进行压迫和剥削。</p>
</li>
<li><p><strong>厌女无关性别</strong>。上野千鹤子在《厌女》中所著：男人喜欢在男人世界里的霸权争斗中，让自己的实力得到其他男人的承认、评价和赞赏，女人是作为一种获胜的奖励随之而来，而女性除了在女性群体间竞争，最终还要寻求男性的认可，这就是一个厌女社会的典型运作模式。在这样的社会模式中，男性和女性都可能成为厌女的主体。比如，《再见爱人4》里的麦琳，在「熏鸡事变」中就体现出了自己厌女的一面。在导游安排有限的伙食费问题上，即便她自己本身是女性，非但不能共情、理解和帮助接替她成为导游的葛夕，甚至还要以身入局把自己做导游时经历过的难处再一次强加到同为女性的葛夕身上，以这样的方式试图反向获得其他人对她之前管钱行为的认可，单方面进行无意义的同性比较和竞争。而且让葛夕承担她对葛夕老公刘爽之前花钱买烟的报复行为，在她的潜意识里，妻子是跟丈夫绑定的，葛夕是相对于刘爽的「第二性」，需要为老公的行为买单。还有很多其他的点也可以看出来，在潜意识里，身为女性的麦琳也是有厌女情节的（在这一点上更详细的分析可以参考上面列出的第二个视频），当然，这还并不是她在这个节目中反映出来的的主要问题。再比如，很多电视剧里面呈现的经典的婆婆对儿媳妇的打压和控制，这都是长期父权社会下形成的固化的厌女情节。</p>
</li>
<li><p><strong>男性或许可以理解和共情女性在父权社会下所面临的困境，但不是真正的感同身受</strong>。理解问题离真正的感同身受还有很长的距离，这导致在遇到类似的困境时男性依然无法在潜意识上和女性有同样的反应和思考，这种差别既与客观的性别差异有关，也与长期以来父权社会的结构性问题有关。不管是男性还是女性，都应该客观看待这种差异，也应意识到确实存在这样的社会问题，为追求更平等公正的社会从身边的事情上开始努力。</p>
</li>
</ul>
<p>在我开始了解真正的女性主义的思想（注意：这里指真正的女性主义，而不是互联网上那些田园女权、极端女权）之后，我发现这还并不是一个狭隘的性别议题，也并不会挑动男女对立。即便抛开性别视角，追求一个更平等、更公正的社会是人类社会进步的表现，不管是在性别议题上，还是在阶级议题上。</p>
<p>我并不是想泛化性别议题，我只是在这样越来越尖锐的人权思潮斗争中看到了一些共性。究其根源，我认为还是目前的社会大众还普遍缺乏<strong>人文主义</strong>的教育和修养，个体意识和个体权益在公共事务中都经常得不到尊重，不少人甚至都不会正确看待同为人类的自己和其他人之间的社会关系，要么过度蔑视、要么过度讨好，精神教育水平远远落后于物质发达程度，更宏观和本质一点说，是<strong>生产关系配不上现在的生产力</strong>，这种不匹配程度越尖锐，压迫和剥削就会越来越多，这是目前很多社会问题的症结所在。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>Maples7 个人开源计划</tag>
        <tag>女性主义</tag>
        <tag>Vision Pro</tag>
      </tags>
  </entry>
  <entry>
    <title>男性也可以支持女性主义进步思潮</title>
    <url>/2024/12/11/male-and-feminism/</url>
    <content><![CDATA[<p><a href="https://maples7.com/2024/12/01/open-source-maples7-3/">上一期《开源计划》</a>已经提到了我关于女性主义的一些想法，但为什么还想单写一篇来聊这个话题？</p>
<p>起因是最近确实看了很多涉及所谓女性主义题材的各种文艺作品，包括电影《好东西》、《某种物质》的解说、国内综艺《再见爱人4》及一些 UP 主的解说、韩综《思想验证区域：The Community》及一些 UP 主的解说。本来这些文艺作品看过也就看过了，对自己的认知和看法有一些提升，还不至于到想要到公共话语空间表达些什么的程度。但直到最近小红书越来越频繁的刷到各种对《好东西》电影的差评和豆瓣 9.1 分的质疑，以及这些帖子评论区味儿太冲的各种保守派父权言论之后，我决定还是要单写一篇，多为女性主义发声！</p>
<p>作为互联网的几大粪坑话题之一，公开聊这个是很有风险的，你不知道你的哪句话又惹恼了哪个意见相左的群体，很多网友在网络环境下会失去深度思考和换位思考的能力，经常不分青红皂白就开始骂人吵架，但我会尽力维护这里的理性、克制和包容，不支持任何极端想法和言论，无关性别。理智沟通，多讨论多交流，真理越辩越明！</p>
<span id="more"></span>

<p>提前声明，我当然不是什么女性主义研究专家，实际上我也只知道很碎片化的一些女性主义思想，并未做任何系统研究，但我觉得有些我看到的观点确实提升了我的认知。我更不是《好东西》里讽刺的女权表演艺术家，在真正通过正确的渠道和途径了解到真正正确的女性主义思想之前，我也对偶尔在网络上看到的极端女权和田园女权行为和言论嗤之以鼻。在我以前的朴素观念里，对于这个议题，我自认为我是一个平权主义者，男女或许性别上有客观的生理差异，但主要还是讲究考虑客观生理差异的前提下，在各个领域的权益的公正平等，也不真正了解女性主义的真正诉求到底是什么。我相信依然有很多自认为有进步思想的男性对待女性主义还是这样的看法。</p>
<p>就像我偶然在豆瓣看到的一个男生写的<a href="https://www.douban.com/doubanapp/dispatch?uri=/status/4803315042/&_i=3385289527121cd&dt_dapp=1">这样一个帖子</a>：</p>
<p><img data-src="https://s2.loli.net/2024/12/11/bPGo7hvVtulaOyM.jpg" alt="豆瓣网友关于男性对女性主义的看法"></p>
<p>这个帖子讲述了他在女性主义议题上的心路历程，我觉得很真诚也很有代表性。人天生是没有这些所谓的主义和社会观念的，但「人人生而平等」的良善却是作为人从小就应该追求的基本原则。朴素的有着正常价值观的男性在女性主义议题上很容易经历同样的心路历程。</p>
<p>这是我在这个帖子下有感而发的回复，以及跟网友的「辩论」：</p>
<p><img data-src="https://s2.loli.net/2024/12/11/Gy1HvcdWLzi2rTo.jpg" alt="我在豆瓣的男性对女性主义看法帖子下回复的讨论"></p>
<p>我承认，男性如果要在女性主义上支持女性主义是很有难度的，这会产生表面上身份认同的矛盾，在社区讨论里更是可能落得「里外不是人」两边立场都不讨好的的下场。一方面，由于客观生理差异和长期的社会结构化问题，男性无法真正同女性做到感同身受；另一方面，作为天然的性别特征，在长期固化的社会结构下，男性确实又在很多方面享受着「第一性」带来的优势。但正如我在<a href="https://maples7.com/2024/12/01/open-source-maples7-3/">上一期《开源计划》</a>和上面的回复中所说的，<strong>真正的女性主义思想内核其实是反压迫、反剥削、追求平等公正，这跟其他人权斗争思潮（比如阶级议题）的内核都是一致的</strong>。反父权社会就是在反压迫和反剥削。</p>
<p>我的女性主义思想启蒙除了最初在网上看到的一些社会现象和一些激进的网络言论，更多的还是女朋友给我的。我们会在一些社会议题和文艺作品上讨论女性主义观点，她也会看一点上野千鹤子的书，但我并没有真正看过，只是知道有这样的书和书中提炼出的一些观点。在生活中偶尔讨论到这些话题时，我觉得是女朋友温和的性格和讲道理逻辑的能力让我逐渐抛弃了一些对女权的刻板印象和错误认知（但不否认这样对极端女权和田园女权的刻板印象在网络上依然是真实存在的），我慢慢意识到真正的女性主义思想并没有我认为的那样极端和反智。</p>
<p>最近看到的一些文艺作品让我对真正的女性主义思想的具体观点和诉求有了更清晰的认知，我同样强烈安利给所有人：</p>
<ul>
<li>UP 主陈小姐的十五楼对《某种物质》的拉片（共三集）：<ul>
<li><a href="https://b23.tv/Vmc1Wr7">她是女性却认同父权所定义的女性价值！《某种物质》拉片第一集（共3集）-哔哩哔哩</a></li>
<li><a href="https://b23.tv/ET1q7W2">当代女性困境：既要女人生又要女人死！《某种物质》拉片第二集（共3集）-哔哩哔哩</a></li>
<li><a href="https://b23.tv/Q5IqkBW">父权不是男权！《某种物质》拉片第三集（共3集）-哔哩哔哩</a></li>
</ul>
</li>
<li><a href="https://b23.tv/6UH4cl4">从画像事件到熏鸡事变！麦琳发疯的本质是厌女？|《再见爱人4》深度解读01-哔哩哔哩</a></li>
</ul>
<p>尤其是陈小姐对《某种物质》的拉片分析，先不简单评论观点的对错，至少让我对真正的女性主义观点有了实感和更深入的思考。</p>
<p>我之所以非常喜欢《好东西》，除了电影本身的质量确实就很高以外，我还倾佩于邵艺辉导演在采访中透露出的价值观念和社会认知。她是真正对女性主义的各种话题有过深入思考的，从她的这些思考中诞生了她的两部电影作品，真诚又别致，对敏感和沉重话题的表现手法上又有独具一格、颇具匠心的轻盈灵巧。抛开各种主义，她的两部电影单论电影质量我都很喜欢，甚至有一种想让自己生活在电影中这样美好的社区氛围下的感觉，这是很独特的观影体验。对生活的艺术表现也丝毫不让我觉得悬浮，电影中的事件源于真实生活，也贴近现实生活。</p>
<p>这样真诚又富有沟通技巧的人也能因为点赞了一条微博被「猎巫」到关闭主页和关注，确实很容易让人对当下公共话语空间的舆论氛围感到绝望。但环境再差，我也还是会选择正面表达和发声，因为我「正直、勇敢、有阅读量」。我也认为理智有思考的人要更多的躬身入局、主动发声（虽然他们往往因为更在意自己表达的准确严谨而倾向于谨慎发言），有些话语空间理智的思想不去占领就会被极端言论占领，我依然相信人性中真善美本源的存在。</p>
<p>最后，说说我自己的一些特质：</p>
<p>我喜欢《好东西》和《爱情神话》，也喜欢《教父》、《让子弹飞》这些在这几天网络上很火的所谓的「老登电影」（我理解这个词对「小妞电影」这个词的讽刺意味），都是我认为的值得目前豆瓣评分的作品，《芭比》我觉得还行，但不觉得比《好东西》好；我不是很喜欢《我的天才女友》电视剧，在女朋友的强烈安利下勉强看完了第一季，但没找到什么共鸣；我喜欢《极限挑战》前四季，不认为黄磊在各个综艺里的表现有任何「爹味」问题且对他的才智和能力表示钦佩；我经常看 B 站 UP 主峰哥亡命天涯的视频，偶尔也看一眼他的直播；我喜欢看宠物博主们可爱的猫猫狗狗视频；我会关注军事自媒体账号，了解最新的世界军事动态；我热衷于研究投资和资产配置，喜欢写代码、做产品，偏理工科思维，讲究有逻辑的思考，但也有很多在文艺上偏女性化的审美趣味；作为直男，我也天然的会对美女自发地产生好感；我开车会经常吐槽路上不遵守交规的男女司机的各种行为，有时也感到生气和愤怒；我认同女性主义的价值和诉求，当然我相信我依然有很多所谓不「女性主义」的想法和行为，但我悦纳自己意识和行为上的改变，不为任何主义，只为一个更具进步性的自己；……</p>
<p>我很想问问那些在女性主义议题上站在光谱两个极端上的人，像我这样的一个真实个体，又要被打上哪样的标签，归类于什么成分呢？</p>
<p><a href="http://xhslink.com/a/MUcMi2cj5pq1">邵艺辉导演在采访中对如何避免女性主义走向极端的问题有很精彩的回答</a>：</p>
<blockquote>
<p>大部分人首先是理智的，只有不理智的人才容易落入到不理智的极端。我是比较相信人的理性、控制和平等沟通交流的渴望的，只要我们有这种交流的耐心。</p>
<p>女性主义本来就是一个又解放男人又解放女人的一个共同利好的事儿。</p>
</blockquote>
<p>人是复杂多样的动态有机生物体，人个体的喜好和行为从概率上来看其实是很随机的。人类社会一定是不断螺旋向前发展进步的，但固守成见的人一定意味着个体认知能力和水平的停滞和衰退。</p>
<p>朋友，不管你是男是女，让我们都做一个开放、多元、包容、追求进步的正常个体，让整个社会更理想一点。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>女性主义</tag>
        <tag>《好东西》</tag>
      </tags>
  </entry>
  <entry>
    <title>Maples7 个人开源计划（4）</title>
    <url>/2024/12/21/open-source-maples7-4/</url>
    <content><![CDATA[<p>年底还会发今年的书单以及按照惯例融入其中的简单的总结、展望，所以先更新一篇《开源计划》。</p>
<h2 id="🧑🏻‍💻-工作"><a href="#🧑🏻‍💻-工作" class="headerlink" title="🧑🏻‍💻 工作"></a>🧑🏻‍💻 工作</h2><ul>
<li>之前参与的 Swift 6.0 中文翻译的工作已经上线了：<a href="https://doc.swiftgg.team/documentation/the-swift-programming-language">The Swift Programming Language (6.0) 中文版</a>，也准备长期在 SwiftGG 翻译组给社区做一些贡献。<br><img data-src="https://s2.loli.net/2024/12/21/ZL8fUGnba4YAQiO.jpg" alt="翻译完之后的小礼物，程序员的T恤背包又多一件"></li>
</ul>
<span id="more"></span>
<p>  <img data-src="https://s2.loli.net/2024/12/21/nJIE1KGvURrfi9N.png" alt="此活动已过期，请勿报名"></p>
<ul>
<li>财务类 App 的新进展：<ul>
<li>女朋友帮我设计了一版 App Icon，但可能后面还需要再多设计几个选一个最好的。完成 Icon 之后还要注册商标。</li>
<li>完成了 App 内购介绍页面的设计和整个内购流程，同时支持订阅和买断。</li>
<li>完成了定位功能的实现，用户记录财务数据时可以同时记录位置信息，方便日后根据位置信息进行检索和数据分析。</li>
<li>修改了相当多的事关用户体验的交互逻辑和细节，提升了用户体验的下限。每天改这么些问题就像是绣花，雕琢每一步操作和显示的细节，实现到自己满意的效果后还蛮有成就感的。我现在已经开始主力使用我自己的 App 来记录财务数据了，所以真正<strong>吃自己的狗粮</strong>长期使用下来发现什么问题就能改，<strong>这种正反馈循环（自己用 -&gt; 发现问题 -&gt; 记录在 Trello 项目看板 -&gt; 修改更新代码 -&gt; 更新自己的 App 版本 -&gt; 把 Trello 的条目标记为 Done）是真正用心做产品才能产生的快感</strong>。</li>
</ul>
</li>
</ul>
<h2 id="🎲-滚雪球"><a href="#🎲-滚雪球" class="headerlink" title="🎲 滚雪球"></a>🎲 滚雪球</h2><p>最新的资产配置比例的桑吉图：</p>
<p><img data-src="https://s2.loli.net/2024/12/21/laXwYpf7S3Lbu9M.jpg" alt="此资产配置图使用我正在紧密开发的财务工具 App 生成"><center><small>(此资产配置图使用我正在紧密开发的财务工具 App 生成)</small></center></p>
<p>从上一次分享到这一次的过程期间（2024-12-01 ~ 2024-12-21），资产净值<strong>增加 ¥22764.35</strong>，原因主要来自于二级市场的自然涨跌和对债务记账方式的变更（因为我的 App 可以自动记录未来周期性的债务入账，比如分期付款的数据，所以之前记录的是已经确定产生的包括未来的总债务，现在更改为截止到当前的总债务，这会把未来会产生的债务记录到未来的账单统计中，而不是全算到现在）。执行的投资操作有跟随长赢计划卖出「恒生科技」、「金融地产」的相关 ETF，我自己的「场外自助补充交易」策略也卖出了不到 1&#x2F;10 仓位的「恒生科技」。支出方面都是日常支出，没有太大额的交易，最大额就是每月必交的医疗保险和养老保险了（另一种形式的税）。</p>
<p>为了量化和剥离出债务记账方式变更的影响，我们聚焦到到每一个账户上，这是我的每个账户这段时间的具体收益变动情况：</p>
<p><img data-src="https://s2.loli.net/2024/12/21/dlc2eTqE6Xus7Nj.png" alt="投资收益具体变动情况"></p>
<p>可以看出债务记账方式变动的影响使得我的总资产记账增加了一万多（具体为信用卡账户余额的变动，并且考虑这段时间增加的开支。本质上也就是未来确定会产生的一万多债务在当前记账中去掉了，这些未来债务都是分期账单产生的），剩下的资产增值部分都是投资收益带来的。</p>
<p>我的 App 对目前的财务情况的等级评估：</p>
<p><img data-src="https://s2.loli.net/2024/12/21/eWu7wZU3ql6E2Hb.jpg" alt="财务等级评估"></p>
<p>以上所有数据记录、统计都是由我自己正在紧密开发的 App 完成，基本整个个人财务记录的链路流程都已经打通，这也是我现在能够完全使用自己的 App 吃自己的狗粮不断迭代优化细节的原因。</p>
<h2 id="♨️-生活"><a href="#♨️-生活" class="headerlink" title="♨️ 生活"></a>♨️ 生活</h2><ul>
<li><p>看完了韩国综艺《思想验证区域：The Community》全片，之前就看过一些 UP 主的分析，这样的综艺讨论的社会话题很有意义和价值。韩国一直有媒体推进社会问题改革的传统，跟之前金泰浩、罗英石的综艺相比，这个综艺更上一个台阶，直接用现实议题作为综艺的议程，与时俱进，不避讳任何敏感话题，从这个层面来说，韩综已经是 next 100 levels 了，强烈推荐👍。</p>
</li>
<li><p>看完了《白夜破晓》，在审查制度下，国内的文艺作品质量每况愈下，在有限的创作空间内水平越来越差，甚至劣币驱逐良币，强烈不推荐👎。</p>
</li>
<li><p>看完了《我是刑警》，同是刑侦题材，至少比隔壁《白夜破晓》强🤷。虽然后半段的案子也看得昏昏欲睡，但开头的几个案子还不错。协审之后把方言全变成普通话的配音至少要扣掉一星。</p>
</li>
<li><p>每天在家庭群跟父母大辩论关于结婚、生娃、买房卖房、做饭的各种话题，辩论技巧、自我意志和心智成熟度都直线提升，对付不同的人就要用不同的现实手段达到自己坚定的理想彼岸，不亦乐乎！</p>
</li>
</ul>
<h2 id="💡-近期感悟"><a href="#💡-近期感悟" class="headerlink" title="💡 近期感悟"></a>💡 近期感悟</h2><h3 id="房地产行业与中国经济发展"><a href="#房地产行业与中国经济发展" class="headerlink" title="房地产行业与中国经济发展"></a>房地产行业与中国经济发展</h3><p>其实这个问题是从个人生活的微观层面联想到的宏观话题，总是可以在小红书上看到各种各样的装修案例，但实际上在国内装修可以说是最不标准化的行业之一，整个行业缺乏规范和标准，从业人员素质也堪忧，导致装修对于任何个体而言都是一件费时费心、且费钱都不一定能产生好结果的事情，甚至很多人都需要自学很多装修知识去应对这个非标准化项目，简直是倒反天罡。</p>
<p>房地产行业的蓬勃发展确实是显而易见最容易带动各个丰富的上下游产业链促进经济循环的方式，也是我们过去二十多年常常在经济增速放缓时拿来用的所谓「夜壶」，但其实对这个行业的巨量投资几乎没有带来任何行业生产效率上的提升，二十年前怎么造房子、怎样装修，到现在也还是同样的生产方式，甚至造出的产品质量更差了。但<strong>经济增长本质上只依赖于生产效率的提升</strong>。从这一点上来说，房地产行业的蓬勃发展表面上虽然短期刺激了经济循环，但实际上只是给经济体带来了更多不健康的淤积的「脂肪」，而不是健康的有机体的「肌肉」。</p>
<p>即便最近政府再一次提出接下来要实行适当宽松的货币和财政政策，也就是通俗来说的「大放水」，我也不认为会再一次带来房地产行业的繁荣。饮鸩止渴有时候是无奈之举，但在居民杠杆率超过 60% 的今天，我不认为这依然还会是一把好用的「夜壶」。反过来想，如果这一次的经济刺激依然需要依赖这把「夜壶」，反而会让我对中国未来的经济增长更加悲观和失望，因为这意味着债务泡沫将继续越滚越大，生产效率非但没有提高，实体经济的发展反而越来越受到过高的土地成本的挤压，中长期来看经济发展活力会越来越变成一潭死水，百害而无一益，只会带来未来更大规模的长期大萧条。</p>
<p>货币供应、投资、债务规模如果不与真实的生产效率的提升匹配，那最终都会形成长期对实体经济发展有害的资产泡沫。</p>
<p>还在看的《货币战争》对此有非常精彩的论述：</p>
<blockquote>
<p>经济增长是从率先提高生产率的部门开始向周边行业“扩散”，从而带来社会生产率的普遍提升。在这一过程中，高生产率的部门扮演着“经济火车头”的角色，低生产率的部门则是受其需求刺激而产生增长的动力，然后逐步提高自身的生产率。</p>
<p>猎人如果是“经济增长火车头”，那么制衣和其他行业的发展就是“被拉动”的部门。整个社会生产率普遍提升后，创造出大量的过剩财富，因而产生了“财富窖藏”的需求。在猎人制造弓箭之前，社会并无剩余财富，整个部落的土地并不值钱，如果连肚子都填不饱，谁还会在意土地开发呢？只有当社会出现“财富窖藏”需求后，黄金、财宝、首饰，也包括土地，才起到了盛装财富溢出的容器作用。于是，土地开始升值。越来越富裕的猎人和制衣者们渐渐有了住房需求，房地产开发商被“刺激”起来，他们在建造房屋的过程中，又“刺激”了砖瓦、木料、家具等行业。</p>
<p>在这个产业链上，猎人是需求的源头，动力是弓箭制造。只有生产率的革命，才是财富创造的真正源泉。</p>
<p>靠土地升值和房地产开发来拉动经济链条的整套思路都是值得怀疑的。土地升值和房地产开发，是生产率提高的自然结果，而不是其初始原因。颠倒了这一逻辑，就会产生错乱的经济效果。</p>
<p>如果没有生产率的革命性突破，片面追求土地升值，将会造成实业部门的成本提高。土地和房地产的货币化，导致了货币供应量的增加超过了生产率的提高，结果就是普遍的通货膨胀，土地成本、原材料、能源和人工的抬升，伴随着市场价格的激烈竞争，将挤压尚未取得生产率突破的整个实业部门的利润。其最终的恶果就是，缺乏利润的实业部门，由于没有必要的“储蓄”积累而丧失了改进“弓箭制造”的能力，弱化了生产率提升的潜力。</p>
<p>土地财政刺激着高地价政策，高地价又刺激着房地产暴利，这种畸形发展模式最终将瓦解实业生产率提升的基础，遏制社会财富创造。GDP总量的增长并非是经济发展的真正目的，健康的经济增长必须以提高生产率为最终导向。房地产及其产业链带来的GDP，本该是生产率提升的结果，现在却变成了压制生产率的原因。上亿吨的钢铁、水泥、原材料被冻结在充满投机而空置率奇高的“鬼楼”中，这与20世纪50年代大炼钢铁和70年代的“洋跃进”一样，都是在浪费宝贵的经济资源，这相当于剥夺了猎人用以制造弓箭的积累，而将其置于闲置和浪费的状态之下。</p>
<p>土地和房地产的货币化刺激了信用创造的狂潮，日益贬值的货币购买力扭曲了社会财富的合理分配。它将储蓄者的财富大规模地转移到少数人的口袋里，它树立了一个“快速致富”恶劣样板。在财富流向的巨变中，土地增值轻易超过了实业生产的微薄利润，迅速瓦解了实业家们艰苦创业的意志，动摇了实业持续改进“弓箭制造”的决心。既然买一块地坐等升值比枯燥、痛苦、绞尽脑汁和充满风险的技术创新，来钱更快、赚钱更多的话，谁还愿意继续踏踏实实、勤勤恳恳地做实业呢？这种短视和浮躁的社会氛围，使“中国制造”的根基越来越浅，抗风浪能力变得脆弱。</p>
<p>土地快速升值和房地产业的畸形发展，从物质和精神两个方面同时摧残着实业生产率增长的潜力。它们所创造的GDP，毒素含量高、副作用大、泡沫成分重，属于经济发展中的“高污染”行业。</p>
</blockquote>
<blockquote>
<p>刺激居民花掉银行中的大量存款能够带来经济增长吗？存款是储蓄的货币体现形式，农民的鸡蛋才是真实的储蓄。储蓄的本质是当人们不再从事生产后，能够在社会中继续存活多长时间的度量。存款只是一种延迟的消费，它的本质还是产品交换。在没有生产率提高的情况下，花掉银行存款相当于缩短自己的“社会寿命”，这能够维持经济，但不会带来真正的增长。</p>
<p>当中国消费市场开始出现疲软时，不能够盲目产生刺激消费的念头，尽管这一想法是如此具有诱惑力和煽动性，但绝不是能够根治问题的良药。</p>
<p>政府加大投资力度能够维持经济增长的态势，但如果用在不能提升生产率的领域，或者难以在短期内形成效益的经济部门，那么中国的债务问题将会变得尖锐起来。最终，不可持续的债务只能由货币增发来解决，这将会在经济冷却的困境中，增加通货膨胀的麻烦。通货紧缩和通货膨胀可能同时并存，但将出现在不同的领域。消费市场的价格持续低迷和资产领域的价格不断膨胀，会把中国经济置于冰火两重天的艰难境地。</p>
</blockquote>
<p>希望中国政府这次能真正认清社会现实，尊重经济发展规律，制定对经济和社会长期发展有利的政策体系。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>Maples7 个人开源计划</tag>
        <tag>房地产</tag>
        <tag>中国经济</tag>
      </tags>
  </entry>
  <entry>
    <title>Maples7 个人开源计划（5）</title>
    <url>/2025/02/19/open-source-maples7-5/</url>
    <content><![CDATA[<p>2025 年的第一篇《开源计划》，新的一年，新的开始！</p>
<h2 id="🧑🏻‍💻-工作"><a href="#🧑🏻‍💻-工作" class="headerlink" title="🧑🏻‍💻 工作"></a>🧑🏻‍💻 工作</h2><ul>
<li><p>财务类 App 的新进展：</p>
<ul>
<li>完成了批量生成交易记录和待办事项的功能</li>
<li>交易计划和待办计划支持设置时间范围</li>
<li>首页增加了按天、按月、按年的收支统计图</li>
<li>搜索功能支持显示时间范围的全部交易记录</li>
<li>优化了部分 UI&#x2F;UX，修复了一些 Bugs</li>
</ul>
</li>
<li><p>SwiftGG 翻译组</p>
<ul>
<li>继续翻译了 swift.org 的 <a href="https://doc.swiftgg.team/documentation/the-swift-programming-language-----/aboutswift">About Swift 页面</a>的内容</li>
<li>Review 了其他人的一些翻译</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>收到了不多的一封让我觉得很开心的读者来信，这就是分享的意义之一：<br><img data-src="https://s2.loli.net/2025/02/19/2m6SXpENqDL17Zh.jpg" alt="读者来信"></p>
</li>
<li><p>现在大部分工作日搭配 Vision Pro 和 MacBook Pro 在家附近的一个书店里面办公，效率还不错。<br><img data-src="https://s2.loli.net/2025/02/19/h3sq6zEpde9WoXV.jpg" alt="使用 Vision Pro 搭配 MacBook Pro 在书店办公"></p>
</li>
</ul>
<h2 id="🎲-滚雪球"><a href="#🎲-滚雪球" class="headerlink" title="🎲 滚雪球"></a>🎲 滚雪球</h2><p>最新的资产配置比例的桑吉图：</p>
<p><img data-src="https://s2.loli.net/2025/02/19/XOr6NYBFD5gWTME.jpg" alt="此资产配置图使用我正在紧密开发的财务工具 App 生成"><center><small>(此资产配置图使用我正在紧密开发的财务工具 App 生成)</small></center></p>
<p>从上一次分享到这一次的过程期间（2024-12-21 ~ 2025-02-19），资产净值<strong>增加 ¥74125.59</strong>，主要收支项来自于这一段时间二级市场的自然涨跌和婚礼准备上的社交资金进出、物资购买和婚庆准备。在投资上，随着近期的涨幅，在「多品种网格交易」中按既定网格策略卖出了 3 网恒生科技（剩 1 网）、1 网恒生（剩 2 网）和 2 网传媒（卖完了）；在「场外自助补充交易」策略中逐步卖出了约 1&#x2F;10 的恒生科技、恒生和沪深 300 的仓位，同时为了将仓位统一到一个账户也简单给医疗医药在场外做个 T；同时赎回了一小部分「春华秋实」的仓位，以后随着大盘的上涨预计会进一步降低这一策略的仓位。</p>
<p>随着我使用我自己开发的这个 App 记账了大概三个月的时间，我已经可以清楚地比较各个策略的年化收益率了：</p>
<p><img data-src="https://s2.loli.net/2025/02/19/6smGcL45HItFuOd.jpg" alt="不同投资策略的年化收益率"><center><small>(不同投资策略的年化收益率)</small></center></p>
<p>基本上算是一目了然，记账是为了更好地指导投资和家庭资产配置，我的 App 的功能设计将会不断围绕这个目的而展开。</p>
<p>当然，作为一个信奉长期主义的以价值投资为主的投资者，用如此短期和上涨阶段的年化收益率来比较评价各个不同的投资策略是不合理的，不同策略有不同的特点和要应对的不同阶段的问题，这里仅仅只是作为展示和记录。</p>
<h2 id="♨️-生活"><a href="#♨️-生活" class="headerlink" title="♨️ 生活"></a>♨️ 生活</h2><ul>
<li><p>看了《破·地狱》，好电影，中国版现实主义现代化《入殓师》。充分展现了一个「重男轻女」的东亚现代父权家庭在封建礼教的约束下对个体的压迫，尤其是对女性的压迫。有些结构化的压迫是代代传承下来无人质疑的，但身处其中的人和人的感情又都是复杂的。大多数人都还有最基本的良善的人性底色，可每个个体又都不完美。人生往往是苦涩的，也还是得苦中作乐。从生到死，人的一生都是一场丰富多彩的经历，先人已故，活着的人还是要坚定破除一切束缚和压迫砥砺前行。从来就没有所谓的「先苦后甜」，酸甜苦辣都是时刻交织在一起的。人的伟大之处在于能创造，唯有做一个乐观的悲观主义者，在认清悲观的现实基调的情况下积极向内向外探索求知，才不枉此生。</p>
</li>
<li><p>元旦去西双版纳跨年旅行「避寒」，巴适得板。基诺山雨林徒步（找正规的向导和路线的前提下）很有意思，其他就随便慢慢逛吃逛吃就很惬意了。冬天还真得去热带气候区才有益身心健康。</p>
</li>
<li><p>看了《鱿鱼游戏2》，完全拉了，相比第一季就是一整个索然无味。</p>
</li>
<li><p>过年回老家🧨，虽然中国的城市化速度和规模都进展飞速，但父母这个年纪的社会圈层依然还停留在人情社会的条条框框里无法自拔，依然是一种突然从商业文明回到乡土中国社会的体验，存在巨大的代差。大部分生活在沿海发达地区的年轻人，其实日常都没意识到中国欠发达的广阔腹地还有巨大的发展潜力，未来中国的经济增长点<em>可能可以</em>来源于此。虽然过年的体验是越来越乏味了，但决定今年开始备婚！</p>
</li>
<li><p>春节档电影就看了《哪吒2》和《封神2》（绝不会再让陈思诚赚我一分钱！），论质量前者是吊打春节档其他所有电影。天时、地利、人和，有如今的票房成绩也是无可厚非吧。</p>
</li>
</ul>
<h2 id="💡-近期感悟"><a href="#💡-近期感悟" class="headerlink" title="💡 近期感悟"></a>💡 近期感悟</h2><h3 id="AI-与自由意志"><a href="#AI-与自由意志" class="headerlink" title="AI 与自由意志"></a>AI 与自由意志</h3><p>过年期间，DeepSeek 又带起了一波互联网上关于 AI 的讨论热潮，尤其这还是一个中国量化交易公司推出的大模型（再次论证了为什么「伟大不能被计划」），当然让人振奋。这不禁这又让我来思考这样一个老生常谈但又十分本质的问题：AI 到底有自由意志吗？</p>
<p>在回答 AI 是否有自由意志前，可能更需要回答另一个更为本质的问题：人类到底有自由意志吗？对 AI 的探索可能可以反过来促进我们对这个问题的理解。在 OpenAI 引领的这一波世界范围的 AI 浪潮之前，我们基本都倾向于认为人类存在一个纯粹精神领域的自由意志，觉得没有通过图灵测试的人工智能跟「人工智障」无异，这些弱人工智能背后依然还是科学家和工程师按人类意志撰写的一条条规则束缚着它。虽然目前的 AI 可能依然无法被称为强人工智能，但是人类似乎大概摸到了进入「智能」的边界模糊的样子。正是这样的探索进一步帮助我们可以回答关于「自由意志」的问题。</p>
<p>长时间以来，生物学家和计算机科学家都试图弄明白人类大脑的秘密，人类的「意识」到底从何而来？人类到底有没有所谓的灵魂？至少到目前为止，我们还没有发现任何脱离基本物质的物理反应的纯精神化的世界存在。而 AI 到目前的发展似乎可以从侧面佐证一个真正的纯精神世界，或者说真正纯精神化的人类自由意志，其实并不存在。因为目前的 AI 就是一个基于物质、电子、信息的反应链路，所有的反应虽然不一定可以预测，但都可以被人类训练出来。人类的意识和所谓的自由意志可能并没有比现在 AI 的「思维」和反应原理高明到哪里去。</p>
<p>人类和 AI 都像是一个黑盒反应器，只要给它源源不断的提供原料和能量，它就可以不断对外界的输入和刺激做出反应，可能唯一不同的只是人类有一个具体的物质形体，活在真正的物质世界中，而且是 24 小时不间断地对外部刺激做出反应，同时又不断地从外部刺激的输入中不断训练自己的意识和反应。但从根本上，在这种作为反应黑盒模型的基本原理上，人类和 AI 可能没有本质区别。也就是说，<strong>人类的自由意志也可能只是一组大脑神经元的电子反应，并不存在任何脱离物质的纯精神世界</strong>。</p>
<p>这种认知可以反过来指导如何进行有效的人类教育，或许在「人之初」，其实无所谓「性本善」或「性本恶」，所谓的善恶观念和人类文化、习俗都是后天教育、培养、驯化的结果。成年人生活在社会规则之中，无法在已经发展至今的社会规则之外生活，但也应该清楚地意识到<strong>有些社会观念和意识是后天规训的结果</strong>，这些观念并不一定是天经地义的铁律，有些社会文明强加的束缚和理念如果让你感到痛苦，该打破时就应当打破。很多所谓的人类文明只有在生活在社会里的大多数人都认同的情况下才能称之为文明，而社会是在不断动态发展的，所以文明也是在不断变化的。这同样暗示了对青少年进行正确引导和教育的重要性，<strong>从小建立良好的认知和观念体系是一个人一生都可以依赖的真正宝贵财富</strong>。</p>
<p>诚然，即便真正的自由意志可能是不存在的，唯心主义在哲学层面也并不是完全没有意义。退一步讲，神经元的电子反应也会反过来作用于身体的其他物质器官，保持一个健康舒适的平衡状态 —— 「修身养性」，让自己的精神状况处于一个自洽和谐的状态，同样可以让人类的物质肉体存活得更有质量、也更为长久。</p>
<h3 id="AI、效率提升与失业"><a href="#AI、效率提升与失业" class="headerlink" title="AI、效率提升与失业"></a>AI、效率提升与失业</h3><p>我也经常看到网络上关于 AI 是否会带来更多的失业的争论，很多人会觉得 AI 目前并没有影响到自己的工作岗位，但这些人其实没有看到商业社会事物之间的广泛联系。</p>
<p>如果说 AI 目前已经能给很多工作带来效率上的提升，相信大部分人都会认同。只要效率有所提升，那需要人类参与的工作岗位的数量就会减少，因为原本完成相同工作量所需的人工数，因为效率的提升变得更少了。你可能暂时不是被减少的那个人工，但被减少的人工会导致越来越多的人工竞争越来越少的人工岗位，最终的结果就是，在一个相互充分关联的商业社会里，无论 AI 是否能参与你的具体工作流来提升效率，你的工作机会都会被影响，即便你是看似无法被 AI 取代的外卖员。</p>
<p>但新技术带来的新的商业业态也会带来全新的岗位类别，很难说在数量上是增加的多还是减少的多。但从质量上却几乎可以断言，在商业社会下，真正创造价值、提供创造力的工作能力才会越来越有竞争力。科技的发展一定会进一步消除个体之间的信息差，那些无法真正提供有创造力的产品或有价值的服务的工作将会被科技发展的浪潮所慢慢取代。在遥远的未来，在 AI 的帮助下，生产力极度发达的情况下，可能真的会存在大多数的普通人无需通过工作来赚取一般等价物（作为交易媒介的钱）的程度，如果那时候<strong>生产关系也调整得当</strong>，那便是进入了真正的共产主义大同社会，大体上的贫富差距、阶级和剥削也将不复存在。但到那种程度势必需要一个漫长的发展过程，你我有生之年大概率都不会看到。要想发展到如此高度的文明，<strong>最大的障碍可能还真不是科技发展进步的瓶颈，反而可能是人性的丑恶：贪婪、虚荣和自私等等</strong>。</p>
<p>对于个体来说，让自己的工作更能创造真正的社会价值、提供有意义的独特产品和服务，才会让自己在 AI 浪潮中更具个人竞争力。这也是我倾向于个体要更积极主动地调整自己来拥抱世界的变化的原因。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>工作</tag>
        <tag>Maples7 个人开源计划</tag>
        <tag>Vision Pro</tag>
        <tag>自由意志</tag>
      </tags>
  </entry>
  <entry>
    <title>2024 年书单</title>
    <url>/2024/12/31/2024-booklist/</url>
    <content><![CDATA[<p>对我来说，2024 年在我印象中其实比我预想中的感觉更漫长，年初发生过的很多事情现在回看仿佛都已经过去很久了，这间接说明了在我的时间线里，2024 年是一个发生了很多不一样事情、变化也很大的一年，不论是在生活上还是在工作上。</p>
<p>生活上，因为工作变动去年跟女朋友一起去杭州待了一年今年年中又再一次回到苏州生活；工作上，<a href="https://maples7.com/2023/07/25/why-i-leave-microsoft/">去年从微软离职之后</a>今年全年都在进行独立开发，时间分配上基本都很自由。这些变化带给我了一些全新的人生体验和体悟。我一直认为是「对尚未知世界的好奇心」才能长期提供源源不断的动力驱使人作为个体活在这个世界上，这种好奇心包括对自我内在的探索和求知。从这个角度说，是这些变化让我在今年又进一步提升了我的人生体验，因为我没有固守自己所已经拥有的一切过着一天天重复无聊的生活，并且还摆脱了更多的束缚获得了更大的自由和灵活度。</p>
<p>这种变化同样体现在了我今年的书单上：</p>
<span id="more"></span>

<ol>
<li><p><a href="https://book.douban.com/subject/30414743/">显微镜下的大明</a>：★★★★</p>
<p> 马亲王写历史，非常擅长从卷帙浩繁的史料里抽丝剥茧，整理出以小见大又有趣的真实历史故事。这跟《明朝那些事儿》的写法类似，但是又没有《明朝那些事儿》那么口水话。而且马亲王文笔扎实、比喻到位，读起来赏心悦目，但又能让人对历史上微观的小事唏嘘不已，是我偏爱的文风类型。</p>
<p> 另外，「后之视今，亦犹今之视昔」，读懂明朝的兴衰起伏，就能读懂现在。</p>
</li>
<li><p><a href="https://book.douban.com/subject/36415996/">金钱心理学: 财富、人性和幸福的永恒真相</a>：★★★★</p>
<p> 「时间自由是财富能带给你的最大红利」，这就是追求财富的根本目的。尤其去年从微软离职后感受更深，是因为还有一些积蓄，才让我有勇气裸辞来自由探索自己感兴趣的工作和生活方式。</p>
<p> 很多章节都写得很有道理，对个人财务管理有实际的指导作用。而最后一章最后几段更是格局大开，揭露了历史规律和经济社会发展的本质，也是现在尤其要考虑第三次世界大战风险的原因。</p>
</li>
<li><p><a href="https://book.douban.com/subject/36104107/">长安的荔枝</a>：★★★★☆</p>
<p> 看马亲王的书就像是在看一部电视剧，画面感太强了。最可贵的是，他总能在这些写史的书中进行现代化的表达，古往今来，人性那点事儿、官场那点事儿、百姓那点事儿，莫不如是。本质上，《长安的荔枝》跟《大明王朝1566》，甚至是《庆余年》，讲的都是同样的故事。</p>
<p> 有点期待这部作品在 2025 年的影视化呈现。</p>
</li>
<li><p><a href="https://book.douban.com/subject/36328704/">太白金星有点烦</a>：★★★★★</p>
<p> 马亲王的又一部神作，没想到竟是短短一个月写成的。好一出官场现形记，明线是西游取经记，暗线还埋了五百年前大闹天宫的真相悬疑，最厉害的是把体制内的那些所谓人情世故的官场丑态以最细腻、最微妙、最局内人的视角埋入故事中，一层一层剖析开来，一气呵成、惟妙惟肖。好久没能读到这种构思精巧、浑然天成的小说了。</p>
</li>
<li><p><a href="https://book.douban.com/subject/27111654/">货币战争(百万册升级版共5册)</a>：★★★★☆</p>
<p> 全五册，125 万多字，从年头陆陆续续看到年尾，这套丛书绝对值得当下时期的中国人一读！我尤其推荐第三部和第四部。</p>
<p> 从货币角度看世界发展史，还蛮有道理的。而且书中有些当年的预言和推断正在变成现实，即便预言并不完全准确，书中的对货币金融的预警也对当前混乱的国际局势有深远清晰的指导意义。<strong>甚至书中对当下中国经济的困局都提供了切实可行的解决方案</strong>。不过，书中也有一些因果逻辑和历史解读有作者纯主观推断之嫌，有阴谋论和地摊文学的味道，而从阴谋论的立场再重新阐释一遍一些诸如广义货币等经济学的基本概念和原理，确实是很容易撩拨不明就里的非专业大众的情绪的，这可能是这本书在多年来持续畅销的原因。但瑕不掩瑜，书中想要警示的问题和用到的政治经济原理是有经久不衰的价值的。</p>
<p> 从我国民族主义的角度，确实可以说美西方主导下构建的资本主义现代金融有多么邪恶，如何无情的剥削全世界普罗大众的剩余价值，这点确实没错，也是事实。从另一个角度来说，这套体系也是现代商业文明的基石，是社会经济发展的血液供应，<strong>虽然它显然并不公平也不够科学</strong>。作为个人，只有懂得现代商业体系游戏规则和善于顺势而为的人才能在这套体系中获利；作为政治家，从民族国家的角度，确实应该主动把握货币金融领域的主导权，制定符合国家利益的公平的国际社会游戏规则，才对得起本国国民。</p>
<p> 虽然本书的部分论证逻辑值得商榷，但是想表达的论点和结论却在当前日益混乱的世界局势下变得越来越具有现实参考意义和价值，正如书中所说，<strong>所有历史都是现代史，了解历史是为了找到当下困境的解决办法</strong>，但愿个体、民族和国家在百年未有之大变局面前都能做出对的选择！</p>
</li>
<li><p><a href="https://www.jjwxc.net/onebook.php?novelid=7114433">我在废土世界扫垃圾</a>：★★★★</p>
<p> 也是一部超长篇，大概是我完整看完的第一部网文作品，真是太佩服作者的想象力了，我都不敢想如果这部作品影视化之后能有多精彩。而且这是一部绝对的女性主义作品，作者很擅长描摹女性角色之间的人物关系，尤其是母女关系，故事中有几组母女关系的对照。同时把故事融入到一个庞大统一的末日世界观规则中去，很吸引人。</p>
</li>
</ol>
<p>今年的出版物阅读量并不算低，主要是《货币战争》五册 125 万多字基本是从年头看到年尾，以金融视角看古今世界局势演变，其实挺有现实意义；另外，是去年看的《明朝那些事儿》和马伯庸的书让我从厌恶到喜欢上看不枯燥的历史，以及那些历史映照出的现实议题的表达；《我在废土世界扫垃圾》基本算是我认真看的第一篇网文，让我对网文的质量印象很有改观，虽然文字上还是有很多网络用语不规范的表达，但是故事构建上的想象力和对故事节奏的把握并不比大部分出版物差。</p>
<p>今年久违的让我不觉得时间过得那么快，不像之前每一年年末都感觉这一年又废了，很多事情都还没做的感觉。今年的这种充实感我个人认为来源于对生活的掌控感，从大学毕业以来第一次全年都能如此的自由，你清楚地知道你的大块时间几乎都花在了你想投入的地方，就像我在之前的<a href="https://maples7.com/2024/11/16/open-source-maples7-2/">一篇《开源计划》</a>中所说，<strong>选择的自由，或者说对自己时间分配上的自由，才是真正的自由</strong>。<strong>财富不是人生的目的，而是达到时间分配自由的手段</strong>。而不论周遭的人或事对你输出什么样的观点，只有自己的感受和体验才是最真实的。</p>
<p>少了很多工作和生活上的束缚之后，我感觉自己都少了很多拖延的习惯。当你真正想到什么的时候，在少了很多客观限制的情况下，你只需要真正遵循你的本心，如果这件事情你真正想去做，你大可以立马就行动起来。这种充实感还不同于大学刚毕业时充满对未来充满憧憬、干劲十足的感觉，刚毕业的大学生几乎都缺少对真实世界和社会的洞察，他们的这种对未来的期待是基于自己一厢情愿对真实世界的无知美好想象，这种期待往往是不可持续的，当了解到更多的世界真相之后往往会产生更大的失望，或者更弱者会主动产生各种自欺欺人的想法和情绪。但现在的我却是在充分认识到现实环境的基础上，主动趋利避害，让自己主动身处在一个自己期望的环境中，再去充分发挥自己的潜能、主观能动性和创造力。这种进化，借用<a href="https://www.xiaoyuzhoufm.com/episode/67650ed31e823e72d35acd40">最近听到的一期播客的标题就是：《做理想主义最务实的践行者：不殉道，不吃苦，还能赚钱》</a>。</p>
<p>今年的另一个感受就是，我再一次发现我自己在很多认知上与大部分普罗大众存在不同，这种感觉在我大学期间和大学刚毕业的一两年时间里时常会有，而事后回顾往往能证明我的认知的准确性，这些认知让我一次次做出对自己更有利的选择。我一直认为自己有平均水平以上的认知，有些认知会早于真实世界的趋势和潮流两三年，或者说是我有时候能看到某些趋势正在开始发生，而普罗大众需要两三年才反应过来。比如在 20、21 年回老家我都会力荐父母处理掉多余的房产，虽然基于很多原因他们并没有真正把认知化为行动。不过，前几年我会感觉这种与大众认知不同似乎变得更越来越少了，这可能表明我在前几年一直处于一个过于保守稳定的环境中，正在逐渐失去持续对自己认知进行升级的环境或习惯。其实，更深刻的认知永远来源于信息差、来源于广泛的阅读和涉猎、来源于对各种各样社会现象的观察和思考。而在这样一个「百年未有之大变局」的时代背景下，一个越来越正确的<strong>现实情况</strong>是「<strong>勤劳不能致富，信息差才能致富</strong>」（原话同样来源于上一段所说的播客）（请注意，「<strong>现实情况</strong>」<em>不</em>代表<strong>这是一条正确公平的方向，而仅仅只是现实世界逐步发展到了这种情况</strong>。这<strong>更不代表我主观上认同和满意这种现实情况</strong>，作为影响力不大的个体认不认同并不重要，只有顺势而为才能先更好地生存下来，再谈其他）。如果你也看过《货币战争》你一定会更同意这种看法，这一切可能都基于一个从一开始就建立的错误的（或者说不公平的）的信用本位的现代货币制度，在这种制度下不可避免的趋势是「产业会空心化」、「做实业不如做科技和互联网行业、做互联网行业不如做金融投机」、「欠钱的才是大爷」、「财富会偏爱杠杆率更高的人」、「现金会持续贬值」、「金融世家会掌握世界绝大部分财富和权力」。因为人类的贪婪本性，无根之木、无源之水的信用本位的货币肯定是不断引诱人到一个「不讲信用」的地步，直至哪一天脆弱的金融信用链条从某处断裂，危机随之而来。</p>
<p>话说回来，今年我的的变化让我再一次意识到自己的认知又一次处在跟大众认知有很多背离的时刻，就像没有永远只涨不跌或只跌不涨的资产，在很多年轻人都在追求稳定、有保障和不变化的工作和生活时，我却有恰恰相反的想法。逻辑很简单，不稳定的环境是客观存在的，作为个体只有顺应客观趋势摆出更机动灵活的姿势，才能在危险到来前先锻炼自己野外生存的本领和能力，而在真正的危险到来之时，趋利避害。而不是倒因为果，强行事倍功半逆势努力，自欺欺人往往最大的受害者是自己。当然啦，<strong>认知可能也不重要，真正决定一个人能否获得所谓世俗意义的成就的可能只是运气而已</strong>。</p>
<p>最后，今年另外一个小的感受就是，代表进步、开放、人文、实事求是、客观理性势力的力量要敢于斗争、敢于积极发声、敢于炸粪坑，这早已不是一个靠踏踏实实、低调勤勉、谨言慎行就能得到话语权的时代，要想让世界朝着更进步的一面发展，就要让进步的思想得到传播，让进步的势力产生影响力。</p>
<p>人生在 2024 年迈入最具创造力又很独立自由的新的十年，即便世界的大环境再恶劣，我依然非常期待！</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>书单</tag>
        <tag>人生</tag>
        <tag>财务自由</tag>
        <tag>好奇心</tag>
      </tags>
  </entry>
  <entry>
    <title>Maples7 个人开源计划（6）</title>
    <url>/2025/04/07/open-source-maples7-6/</url>
    <content><![CDATA[<p>中美贸易战大升级，全球金融市场已经巨幅震动，在今天收盘资产更新之前先更新一篇新的《开源计划》，同时更新个人资产比例，作为上一个阶段的结束，想必是很合适的。</p>
<p>看未来，资本市场短期内必将又是一片腥风血雨。</p>
<h2 id="🧑🏻‍💻-工作"><a href="#🧑🏻‍💻-工作" class="headerlink" title="🧑🏻‍💻 工作"></a>🧑🏻‍💻 工作</h2><ul>
<li><p>财务类 App 最新的进展如下：</p>
<ul>
<li>实现了待办任务&#x2F;交易的通知提醒功能</li>
<li>支持了多币种及币种管理 —— 所有涉及具体金额输入输出的地方都进行了改动，借此机会也重新重构了底层数据结构，复用更多重复类似的代码，让代码结构更加清晰、更不易出错了</li>
<li>女朋友帮我重新设计了一版更好的 icon，不出意外会作为第一版正式版的 App Icon</li>
<li>交易支持记录退款操作的逻辑</li>
<li>交易支持绑定某个垂直的发生在一段时间的事件，便于后续回顾分析</li>
<li>投资类账户支持记录在初始化之前已经实现的收益或亏损，用户任何时候开始记账都可以准确记录自己的投资收益</li>
<li>债务类账户支持显示未来债务总额</li>
<li>支持账户页面隐藏具体金额</li>
<li>多项 UI 优化和 bug 修复</li>
</ul>
<p>最近的这些改动都是用于提升用户体验的功能和改进，原本这些功能可能计划不会在第一版推出，但是感觉如果发布后再改动底层数据模型容易造成大面积的问题，所以还是一鼓作气尽量把数据模型构建得更完备一些，具体功能交互可以暂时简陋，这些后期都可以慢慢迭代优化。</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li>Apple Developer 新推出了「Apple 开发者」的微信公众号，会持续提供面向中文开发者社区的最新新闻、公告和活动动态，最近就听了一些中文的线上活动，可以直接在活动中与 Apple 上海开发者中心的员工和讲师沟通，感兴趣的 Apple 开发者可以关注一波。</li>
</ul>
<h2 id="🎲-滚雪球"><a href="#🎲-滚雪球" class="headerlink" title="🎲 滚雪球"></a>🎲 滚雪球</h2><p>最新的资产配置比例的桑吉图：</p>
<p><img data-src="https://s2.loli.net/2025/04/07/ypfXUQzgPewCL8O.jpg" alt="此资产配置图使用我正在紧密开发的财务工具 App 生成"><center><small>(此资产配置图使用我正在紧密开发的财务工具 App 生成)</small></center></p>
<p>此资产比例已经考虑当日（2025-04-07）的场内场外操作，主要是在「多品种网格交易」、「场外自助补充交易」、「长赢计划 150 份」和「长赢计划 S 定投」策略中都分别买回了一些前期高点出掉了一些的品种（做网格和波段）和还依然在低位可以继续加仓的品种（做配置和长投），它们包括恒生科技、恒生、中概和医疗医药、传媒、证券、沪深 300。</p>
<p>从上一次分享到这一次的过程期间（2025-02-19 ~ 2025-04-07），资产净值<strong>增加 ¥173068.7</strong>，主要收支项不来源于二级市场，而是来源于婚礼准备上的社交资金进出、物资购买和婚庆准备。二级市场先涨后跌，如果不考虑今天 A 股和清明假期外围市场的暴跌，基本位置在开始和结束时是持平的，当然我们逢高卖出了小部分，所以用于投资的金融净资产是增加的。在这期间的投资操作比较多，在高位降低了一些「春华秋实」的仓位，「多品种网格交易」、「场外自助补充交易」和长赢的两个计划都是逢高出掉了一些恒生科技、恒生和中概，网格甚至一度卖完了所有持仓。正好，趁这次全球金融市场大跌，又接回来了一些，从上一段中的今日操作中已经体现了这一点。</p>
<p>「高抛低吸」，保证每一个波动过后，市场回到同样的点位，金融净资产都能有所增加，才能在这样梦魇级别难度的金融市场中不断让自己的资产增值。</p>
<h2 id="♨️-生活"><a href="#♨️-生活" class="headerlink" title="♨️ 生活"></a>♨️ 生活</h2><p>生活重心基本都放在备婚上了，各种东西都要准备，周末的时间基本都在看各种相关的东西。没有太多可以分享的内容，但有一些感悟会放在下个部分。</p>
<h2 id="💡-近期感悟"><a href="#💡-近期感悟" class="headerlink" title="💡 近期感悟"></a>💡 近期感悟</h2><h3 id="非标服务业与奢侈品行业"><a href="#非标服务业与奢侈品行业" class="headerlink" title="非标服务业与奢侈品行业"></a>非标服务业与奢侈品行业</h3><p>按<a href="https://zh.wikipedia.org/wiki/%E6%96%B0%E8%87%AA%E7%94%B1%E4%B8%BB%E7%BE%A9">「新自由主义」</a>的观点，市场几乎是万能的，很多涉世未深的学生估计也会持有类似的观点。但最近我越来越意识到这个观点的错误。市场有效论的论点是市场中的参与者提供的产品和服务会随着市场的供需关系调节，最终价格、质量和供需都会达到一种平衡状态，但实际上，市场不总是有效的，这尤其体现在非标服务业和奢侈品行业上。</p>
<p>在备婚过程中这一点体会颇深，有些非标服务业已经处于衰退阶段了，客流量越来越少但单价却反而变高了。如果按市场有效论，市场需求变少，提供产品和服务的参与者会自行降价或提升质量来让自己能在市场上活下来，但现实情况却不尽然。这些客少的非标服务业有时候反而需要提高客单价遇到一单就狠狠宰一笔才能活下来，这个理论同样适用于奢侈品行业，他们提供的产品和服务质量可能略高于标准产品，但消费者却可能需要付出数倍的溢价来获取这一点价值，即便这个行业已经处于衰败期。</p>
<p>市场一定需要有基本的引导、监管和规则，每年的 3.15 晚会也在不断提醒这一点。好的商业社会运转逻辑需要市场监管者维护公平、一致、严格的市场规则和底线，其他市场参与者都在规则框架内进行交易，这样的基本规则最好能引导出自主淘汰落后、低质的产品和服务的特点，这样好的商业社会逻辑也会促进社会各行各业生产力的不断进步，形成正向的飞轮循环。</p>
<p>我最近也研究了几个消费行业的个股，包括中国中免和老铺黄金。这两个公司提供的消费品都多少带一些奢侈品属性了。</p>
<p>跟大多数人以为的不同，奢侈品行业的主要客群其实是中产阶级，当然他们的营销一定会高大上，让拥有者能在别人的眼光中产生自我优越感，但不管它们再怎么营销消费主义观念，奢侈品都是主要面向中产阶级的生意。一方面，真正的上层阶级人数少需求量不够养活庞大的奢侈品行业；另一方面，中产阶级收入的降低显著影响了这些公司的股价，表现为需求萎靡、销量不佳、利润骤减，这反过来佐证了前面的观点。中产阶级的特点是对价格敏感，他们愿意为好的产品和服务付费，即便这东西不便宜，但是他们一定怕自己买贵了，相同的产品和服务质量有更便宜的一定不会愿意买贵的。</p>
<p>中产阶级收入降低、需求减少、世界重新从疫情中恢复连接让中国中免的股价从疫情期间的高点持续向下一蹶不振，而老铺黄金填补了轻奢黄金饰品工艺好看又保值的细分市场空白，不断侵蚀其他老牌传统黄金品牌甚至是其他奢侈品牌在中国的市场份额，所以股价飞涨。当然，影响股价的因素有很多，任何事后的分析都显得像是「事后诸葛亮」，权当是一些思维认知训练了。</p>
<h3 id="投资、概率与人生的底层逻辑"><a href="#投资、概率与人生的底层逻辑" class="headerlink" title="投资、概率与人生的底层逻辑"></a>投资、概率与人生的底层逻辑</h3><p>这个话题在我的博客肯定提到过不止一次，但我还是想用更精炼的语言再聊一遍。</p>
<p>投资虽然没有数学的严谨，甚至有时候精确反而会造成错误，但也绝不是像艺术那样没有一致的标准，它有其颠扑不破的底层逻辑。这种概率游戏很像人生的底层逻辑。没有什么未来是可以被预测的，但基于当下的现实你却可以计算某个具体事件可能发生的概率，投资和人生都是基于这样的底层逻辑。</p>
<p>所以如果你想要在这两个概率游戏里取得成功，你得用概率思维来运作（尤其是抛弃有毒的基于确定性和绝对对错的学生思维）—— 既不用确定性思维对一城一池的得失锱铢必较，也不可陷入虚无主义彻底摆烂放弃对世俗意义的追求。你去观察和总结那些投资大师和真正靠自己打拼成功的企业家的人生轨迹，他们大多都是概率和赔率思维很强、对未来很有预见性并充分行动准备的人。</p>
<h3 id="失业、风险和真正的个人事业"><a href="#失业、风险和真正的个人事业" class="headerlink" title="失业、风险和真正的个人事业"></a>失业、风险和真正的个人事业</h3><p>再一次重申，在这样一个快速变化的世界变局之中，真正的风险是不能勇敢拥抱变化。</p>
<p>正好今天又有一则谣言充斥大公司的员工圈子，说微软要彻底退出中国市场。从贸易战开始，几乎每年都会传出这样的谣言。<a href="https://maples7.com/2023/07/25/why-i-leave-microsoft/">我在大概两年前主动从微软中国离职的时候</a>当然不会提前预料到今天这样的世界局势和哪些事情一定会发生，虽然那时候已经有一些苗头。但每年都会传出的这样的谣言也不完全是空穴来风，上一次撤出的是 AI 相关的团队，这一次裁撤的是 vendor 团队，以后会怎样谁也说不准。总的来说，趋势没有改变甚至在进一步加强，那就是受国际局势影响外企在中国业务量的减少，这种减少同样会影响其他的项目业务和岗位机会。</p>
<p>风起于青萍之末，止于草莽之间。没有什么工作是绝对安全的，每个人唯一能相信的只有自己选择并真正长期投入时间和精力的个人事业。这种长期投入不在于短期的某一份工作、某一个职位，而在于你是否在长期坚持的个人事业生涯中进一步精进和提高。</p>
<p>不得不再次感叹，投资的大道就是人生的大道。在这两个游戏里，投机者不会赢 —— 想要左右逢源、这也沾一点那也碰一点、什么是风口什么赚钱就干啥，并不会让你在长期赛道中精通深入奠定优势和门槛，你的目的会落空；无脑定投者不会赢 —— 只会无脑坚持、只会埋头拉车不会抬头看路者可能会一不小心就会落后于这个快速变动的时代，一不小心就深套在了最高点。在这两个游戏里，只有低买高卖的长期价值投资者最终能赢 —— 你得确立自己的主线任务轻易不改其意，也要对趋势和变化了然于心并加以合理利用，作用于自己的主线目标和最高任务，同时也要利用复利效应长期坚持，只有这样，你才能在个人事业和投资这两个游戏中胜出。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>人生</tag>
        <tag>投资</tag>
        <tag>工作</tag>
        <tag>微软</tag>
        <tag>消费行业</tag>
        <tag>概率思维</tag>
      </tags>
  </entry>
  <entry>
    <title>Maples7 个人开源计划（7）</title>
    <url>/2025/05/27/open-source-maples7-7/</url>
    <content><![CDATA[<p>一个多月没有更新了，这期间主要精力都在备婚并且在老家办了婚礼，也是完结了一件大事，现在终于有时间来更新一篇《开源计划》。</p>
<h2 id="🧑🏻‍💻-工作"><a href="#🧑🏻‍💻-工作" class="headerlink" title="🧑🏻‍💻 工作"></a>🧑🏻‍💻 工作</h2><ul>
<li>财务类 App 最新的进展如下：<ul>
<li>对统计图表页的所有图表和列表进行了全面的重构，让它们更美观和实用</li>
<li>增加了对「交易事件」的统计页面</li>
<li>增加「一键结汇」功能，允许用户用基准货币对历史财务数据进行结汇</li>
<li>增加「数据归集」功能，允许用户将历史数据进行汇总</li>
<li>增加对交易列表过滤「大额交易」的功能</li>
<li>增加了更多搜索功能的可用过滤条件，在其他列表页也相应增加了更多过滤条件</li>
<li>允许用户自定义打开 App 的首页，但同时也支持在不同情况下依然遵循 App 打开时的自然逻辑</li>
<li>实现了 Pro 功能仅对付费会员用户开放的限制逻辑，对会员功能添加了 Pro 标记</li>
<li>修改了使用 iCloud sync data 的逻辑 —— iOS 本身对使用 iCloud 进行数据同步的限制很多且非常不灵活，所以为了 App 的稳定性暂时放弃了一些自定义数据同步逻辑的想法</li>
<li>多项 UI 优化和 bug 修复</li>
<li>使用 LazyView 优化启动 App 时的性能</li>
</ul>
</li>
</ul>
<p>我预想的第一个版本的功能都已经实现了，接下来会专注于 App 备案（难绷 &gt;_&lt;）、注册软件著作权和商标，实现一些平台合规的要求，预计下一次更新《开源计划》之前就会正式发布上架第一个版本！🎉</p>
<span id="more"></span>

<h2 id="🎲-滚雪球"><a href="#🎲-滚雪球" class="headerlink" title="🎲 滚雪球"></a>🎲 滚雪球</h2><p>最新的资产配置比例的桑吉图：</p>
<p><img data-src="https://s2.loli.net/2025/05/27/GyoDLPrKm5UJdV4.jpg" alt="此资产配置图使用我正在紧密开发的财务工具 App 生成"><center><small>(此资产配置图使用我正在紧密开发的财务工具 App 生成)</small></center></p>
<p>从上一次分享到这一次的过程期间（2025-04-07 ～ 2025-05-27），资产净值<strong>增加 ¥640868.41</strong>。资产结构和数量都有不小的变化，主要是因为婚礼后把我们小家庭的其他资产的变化也开始并表纳入这个工具的追踪和统计，方便我们随时能得知家庭总资产的变化（见上图现金类别下新增的「家庭」账户），这是完全新增的部分。其次，婚礼前后也有一些婚礼筹备和家庭资金的进出项。最后是投资账户随二级市场增幅的涨幅。</p>
<p>在这期间，我做过的投资操作有：在多个策略里逢高卖出恒生、恒生科技、医疗等 ETF；网格策略中有出网卖出的有恒生、恒生科技、纳指、传媒等 ETF；「春华秋实」持续逢高减仓，共卖出它的约 1&#x2F;4 ～ 1&#x2F;5 的仓位。</p>
<p>这段时间二级市场涨幅尚可，但后续上涨也显乏力。还是那句话，逢高适当慢慢出货置换到更便宜的筹码、构建更合理的仓位结构，未来无论市场如何变化，我们都能从容应对。</p>
<h2 id="♨️-生活"><a href="#♨️-生活" class="headerlink" title="♨️ 生活"></a>♨️ 生活</h2><ul>
<li><p>最大的事情就是在老家办完了婚礼💒，虽然婚礼的筹备和举办过程相当的累（<del>再也不想干这活儿了，婚礼完一回苏州就猛猛睡觉，但是今年苏州可能还会再来一次朋友的聚会 &gt;_&lt;</del>），但最终的效果都还不错。婚礼是我们自己主持，所有的流程都是按我们自己的想法设计的，去掉一些必要性不是很大、形式大于内容的环节，简化并留下我们觉得必要的环节，让婚礼过程更轻松、更温馨。</p>
<p>最主要的经验就是跟妆和跟拍老师一定要找专业的，最终留下的婚礼回忆都是甜蜜、温馨和美好的。我们的小家也算是正式在亲友的见证和祝福中成立，未来会继续努力，让这个小家更温馨、更幸福。</p>
<p>通过这次婚礼我也更理解一个熟人社会和人情社会是如何具体运作的，长大后很多亲友也是难得一聚，越往后也越只有通过这些重要的人生事件节点来聚一回。另外，环境塑造人和改变人，每个人都有自己要面对的社会学命题，这导致同样的事情在不同人眼里的优先级和重要程度都是不同的，或多或少，人终究是逃不过社会的规训。（我似乎还觉醒了我一直对社会学的兴趣，当然，并不是国内大学教材里那种照本宣科的社会学。）</p>
</li>
<li><p>看了最新一季的《黑镜》，算是还行吧，但也没有更多值得一提的。不知道是因为自己随着年龄和阅历的增长越来越难对新鲜事物感兴趣了，还是因为全世界范围内新出的好内容 —— 不论是电影、电视剧还是书 —— 确实在越来越少。如果后者确实是原因之一，那现阶段大概就是历史周期里衰退阶段的垃圾时间吧。现实世界已经足够魔幻和离奇，大众都开始更关注现实议题、更关注自己的切身生活。</p>
</li>
</ul>
<h2 id="💡-近期感悟"><a href="#💡-近期感悟" class="headerlink" title="💡 近期感悟"></a>💡 近期感悟</h2><h3 id="中国的阶层固化现状（纯主观感受）"><a href="#中国的阶层固化现状（纯主观感受）" class="headerlink" title="中国的阶层固化现状（纯主观感受）"></a>中国的阶层固化现状（纯主观感受）</h3><p>这段时间有两个社会新闻掀起了很大的舆论浪潮，之前的「协和 4+4」事件和最近的「天价耳环」事件，都再一次把中国的阶层固化现状赤裸裸暴露在大众面前。先不管这些人的家族权势和巨量财富是不是通过正常合法的渠道积累来的，这些现象的屡屡曝光都说明了类似的食利阶层在国内已经并不罕见了。</p>
<p>普通人近年来几乎都有这样的感受，就是单靠个人努力已经越来越难实现阶层跨越，这并不是说每个人都应该成功，而是这样的概率在越来越低。这也是「内卷」、「打工牛马」、「996 福报」等词如此持续在互联网上被热议和关注的原因。越辛苦的人似乎越命苦，越会吃苦耐劳的人似乎越得不到应有的回报。一方面，世界处于大的转型和变革阶段，在信息传播如此快速和便捷的今天，信息差也已经越来越少，本来靠这些信息差所带来高回报的工作都在回归自己真正能提供的社会价值，陈旧的职业理念和岗位在 AI 时代里正在慢性死亡，这是「内卷」。另一方面，阶层固化也确实在明显破坏社会进步的公平性，很多行业「潜规则」已经逐渐变成大家心知肚明的「明规则」，生产关系和分配体系如果不能及时做出合理的调整来纠偏，未来的阶层固化将还会越来越严重，也将直接阻碍社会的进步。</p>
<p>在「协和 4+4」事件里，我其实非常好奇为什么当事人家庭会认为医生这样公认又苦又累的工作会被认为是一条好的人生道路。后来想一想也合理，他们家庭的显性或隐性的资源和财富都在医疗行业里，这些资源和财富需要子女进入这个行业镀金来继承。财富、资源、权力的传承或许是全世界所有富一代们都在处心积虑筹谋烦恼的事情。其实不仅仅是权贵，对于普通人，只要稍微有些积累的家庭都是如此，如果父母混得还不错，大多数父母都希望子女继承家业站在自己的肩膀上继续打拼，才会事半功倍。再想想那些福利待遇一直都不错的垄断行业，比如烟草、电力、能源、通信、金融等行业，有多少行业二代们都是被父母安排了一条直通行业的人生道路，人性如此。这些阶层固化的现象每天就发生在我们身边，很多人也是这个固化社会的维护者和获益者。这些并不公平的现象自然会挑动绝大多数毕业即失业的年轻人们的神经。</p>
<p>基于这些想法，我是不是可以进一步推测，其实国内现阶段的阶层固化大多还是某个垂直行业的资源和财富的传承，还没有像欧美老牌资本主义国家那样跨行业全方位垄断型的阶层固化。当然这并不说国内没有真正的跨行业权贵，而是在国内能达到这样程度的家庭确实太有难度，尤其是对于我们的特色体制和文化传统而言，不入仕且走到金字塔顶端是几乎不可能达到的。</p>
<p>以上只是我个人关于这个话题的一些不成熟的臆测和瞎想，仅供参考，切勿对号入座和过度解读。</p>
<h3 id="再谈国内高等教育与科研创新"><a href="#再谈国内高等教育与科研创新" class="headerlink" title="再谈国内高等教育与科研创新"></a>再谈国内高等教育与科研创新</h3><p>在读大学时我就有深刻的感受，国内的高等教育体系其实很有问题，高校的行政化和官僚化几乎是另一个「小官场」，满是利益勾连和人情世故，这样的体系下是诞生不了真正的科研创新的。</p>
<p>把这样的高校体系结合上一个话题中切实发生的阶层固化现象来看，也不难理解了。这样的体系下，教育变成了学阀们维护利益和资源的工具，高校的所谓科研创新大多也只是为了获取更多的科研经费和行政资源，而不是为了真正推动社会进步和科技发展。而医院和医疗行业的人员构成和职级评定更是直接脱胎于高校体系，同样继承了这个体系的所有弊病。从这个角度再看「协和 4+4」事件，是不是这些现象都可以解释得通了。</p>
<p>可以说，高校本该是社会中最具创新和活力的地方，但在现今这样的体系下，它反而变成了最迂腐和保守的地方，变成了学阀们捞取利益资源、维护阶层和等级制度的温床。这样的体系下，真正的科研创新和社会进步是很难实现的。</p>
<h3 id="人的成长，就是逐渐理解之前的不理解"><a href="#人的成长，就是逐渐理解之前的不理解" class="headerlink" title="人的成长，就是逐渐理解之前的不理解"></a>人的成长，就是逐渐理解之前的不理解</h3><p>最近看到一句话，说人的成长就是逐渐理解自己之前的不理解。确实如此，随着年龄的增长和阅历的积累，人的心态大约会变得越来越成熟和豁达，我们会逐渐理解自己年轻时曾经不理解的事情。就像我们看自己曾经的朋友圈和 QQ 空间，会发现我们年轻时的想法和观点其实是很幼稚和片面的。</p>
<p>这并不是说年轻时的想法就一定是错的，而是随着时间的推移，我们会逐渐看到更全面和深刻的真相。很多时候，我们年轻时的反对和不理解，都是因为缺乏足够的经验和视角。这也是为什么很多人会说，年轻时的反叛和不理解其实是成长的一部分。我们需要经历这些反叛和不理解，才能在未来更好地理解自己和世界。</p>
<p>这也让我想起了之前提到的社会学命题，人的成长和社会的规训是密不可分的。我们每个人都在不断地被社会塑造和改变，而这种塑造和改变往往是潜移默化的。随着时间的推移，我们会逐渐理解社会对我们的期望和要求，也会逐渐适应这种期望和要求。</p>
<p>这并不是说我们要完全放弃自己的个性和独立思考，而是要在理解和适应社会的基础上，找到自己的位置和价值。只有这样，我们才会更好地实现个人成长，尽最大努力提供自己的社会价值。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>社会生活</tag>
        <tag>阶层固化</tag>
        <tag>社会学</tag>
        <tag>婚礼</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title>Maples7 个人开源计划（8）</title>
    <url>/2025/06/30/open-source-maples7-8/</url>
    <content><![CDATA[<p>六月的最后一天，也是 2025 年上半年的结束，正好又赶上我的新财务类工具 App —— BeanLedger —— 在大陆地区 App Store 上架第一周，是很适合写一篇新的《开源计划》做一些回顾和总结的。</p>
<h2 id="🧑🏻‍💻-工作"><a href="#🧑🏻‍💻-工作" class="headerlink" title="🧑🏻‍💻 工作"></a>🧑🏻‍💻 工作</h2><ul>
<li>财务类 App <a href="https://apps.apple.com/app/beanledger/id6739036460">BeanLedger</a> 终于上架了！🎉<ul>
<li>其实在其他地区 App Store 已经上架两周了，上架的第一周甚至连发了 5 个新版本解决一些明显的问题和设计错误（不得不再次吐槽，我 debug 的 80%+ 的事件几乎都是在跟 SwiftData 和 iCloud 的数据同步作斗争，虽然已经看过很多文档和教程，但我觉得新手依然还是会该踩的坑全部踩一遍，因为这个框架本身就还远未成熟，有不少明显的缺陷和问题）。在无 ICP 备案的情况下，本来以为审核通过就能全球一起上架，后来发现大陆地区 App Store 无通知直接屏蔽分发了。提起申诉额外花了一些时间，终于在两周后也在大陆地区上架了。</li>
<li>大陆上架后随手<a href="http://xhslink.com/m/4GU8MWltVTB">在小红书发了一篇帖子</a>，没想到还吸引了挺多的关注，一整个大 overwhelming。我深知第一版还挺简陋，很多预想的功能还没有实现，UI&#x2F;UX 也是我完全基于功能性出发直接用 SwiftUI 框架码出来的，并未经过专业的设计和审视，显得非常原始硬核、配色比较杂乱，所以也收到了许多各式各样的争议和反馈，好的坏的都有。根据反馈，有些比较紧急的问题也修复并发布了新版本，也把许多不错的建议和反馈融入了更长期的迭代优化的计划中去。</li>
<li>不少陌生网友仅根据我随手发的一篇帖子就去试用并且给出很长篇的使用体验反馈，蛮让我感动的！也增强了我要不断把它做好的决心。</li>
<li>截止我写这一篇博客的时候，已经有接近 9000 个用户下载了我的 App，其中有 4000 多个成为了会员（虽然很多网友是因为上架首周「终身会员」限免的活动才来的，但我依然非常感谢）。我觉得对于一个刚上架一周的 App 来说，已经是让我受宠若惊了。<span id="more"></span></li>
<li>我做这个 App 的初衷就是想做一个移动端交互也足够方便简单的 Beancount，后来根据我自己的投资习惯添加了辅助做投资决策的统计和洞察功能。未来我依然会围绕这样的原则来设计和开发更多的功能，它不仅仅是一个单纯的记账 App，因为我觉得只是记账其实用处不大，记账只是手段，随时随地能了解自己的资产实况才是这个 App 想要核心解决的问题。记账是投资的首要前提，记账的目的是为了更好地做投资决策。</li>
<li>刚上线就收获不少的关注让我更加意识到一个人精力和力量的有限，很多想法还没有时间研究和实现，一个人开发的同时还是兼任设计、产品、运营、客服等等，但创业（虽然独立开发并不完全是创业，但有类似之处）想要持续活下去的重要一点就是要控制成本，我想我未来也会一直遵循这一点，一直保持对产品的热情、专注和高效，也同时保持团队和产品都达到「小而美」的状态。</li>
<li>一旦你体验到自己打磨自己产品的乐趣，你可能就很难再回去作为企业职工来工作了。</li>
<li>很多陌生人其实会质疑做这个东西的初衷，觉得 iOS 开发三件套市面上已经足够多了，也从功利主义角度出发觉得没什么「钱」景，我唯一想回应的就是，<strong>别人做的锤子的把手弧度我用着不是很满意，所以我乐意自己动手造一把我用着满意的锤子，没人会觉得这个世界上锤子的种类太多了天就要塌了</strong>。如果你是我的投资人，你可以对方向和产品提要求，如果你不是，我只能说我乐意做啥就做啥，也无需以此证明或是想要功利性地获得些什么。<strong>我就只是想纯粹做一把我用着满意的锤子，享受打磨产品的乐趣，仅此而已</strong>。做三件套的同时也不排除我能同时做其他更具创意的产品，亲自动手迈出第一步而不是说着风凉话天天觉得这也不行那也不行，我感觉我就已经超越了过去的自己。Get your hands dirty，只会纸上谈兵的人永远无法理解过程的乐趣，也永远做不出任何落地的产品。我尊重其他人人生的多样性和可能性，也请那些「网络教父」们把自己抑制不住的自以为是和想要教人做人的「爹味」收一收。</li>
<li>之后我还会写一些关于设计思路、使用指南之类的文档，并且分享我觉得普通人应该如何更好地记账的个人经验。</li>
<li>根据用户反馈，未来一段时间的开发和迭代重点会优先放在 UI&#x2F;UX 大改造上，正好适配 iOS 26 的新设计风格，顺便会推出一些适配于新 UI 的便利性功能。</li>
</ul>
</li>
</ul>
<h2 id="🎲-滚雪球"><a href="#🎲-滚雪球" class="headerlink" title="🎲 滚雪球"></a>🎲 滚雪球</h2><p>最新的资产配置比例的桑吉图：</p>
<p><img data-src="https://s2.loli.net/2025/06/30/wekuQ7XTVis2D8l.png" alt="此资产配置图使用我开发的财务工具 App BeanLedger 生成"><center><small>(此资产配置图使用我开发的财务工具 App BeanLedger 生成)</small></center></p>
<p>从上一次分享到这一次的过程期间（2025-05-27 ～ 2025-06-30），资产净值<strong>减少 ¥23527.04</strong>。这段时间的二级市场其实变化不大，有一些小幅的增长，资产净值减少的原因还是来自于筹备蜜月旅行、苏州的小型婚礼的一些预定花费以及最近的搬家花销上。顺带一提，我的财务 App 支持针对某一段时间某个生活事件进行关联记账，这也是我能很快通过我的 App 洞察出具体是什么事情占据了收支大头的原因，比如我能清晰地看到搬家花了多少钱，以及具体花在哪些分类上。</p>
<p>这段时间几乎没有做什么二级市场的操作，仅有的是继续逢高卖出「春华秋实」，今年一整年到现在加起来我已经卖出了一半多接近 2&#x2F;3 的原始仓位 —— 这个策略并不适合我，所以我最终会逢高卖光这个策略的所有仓位；另外就是网格策略自动出网的卖出，包括了证券 ETF 和传媒 ETF。</p>
<p>看上面的资产桑基图，我其实觉得目前的现金比例是有点高了，但是对于长年在二级市场捡垃圾的我们的门派理念来说，相对高位也确实下不去手。未来会更关注寻找一些长期的低位机会做一些与已有仓位相关性不大的配置。</p>
<h2 id="♨️-生活"><a href="#♨️-生活" class="headerlink" title="♨️ 生活"></a>♨️ 生活</h2><ul>
<li>上周 App 上架正好赶上搬家，很多问题和反馈需要修复，刚开始家里的宽带都还没装好，一整个兵荒马乱。目前新家基本已经收拾完毕，比一年前从杭州回苏州随便在网上看好就租了的房子还是要舒适很多，后面可以稍微更有时间专注在自己的工作上了。虽然也还有一些其他的生活琐事。</li>
<li>看了《长安的荔枝》电视剧的前面小半部和《鱿鱼游戏 3》，都可以用「食之无味弃之可惜」来形容。</li>
<li>在补《小巷人家》，看了一小半了，目前感觉还是蛮不错的。</li>
<li>想看《F1：狂飙飞车》。</li>
</ul>
<h2 id="💡-近期感悟"><a href="#💡-近期感悟" class="headerlink" title="💡 近期感悟"></a>💡 近期感悟</h2><h3 id="通缩时代的房价与个体道路选择"><a href="#通缩时代的房价与个体道路选择" class="headerlink" title="通缩时代的房价与个体道路选择"></a>通缩时代的房价与个体道路选择</h3><p>之前我们租住的房子房东一直想要卖房，我们也一直配合中介带看了一段时间，见证了从去年过年前的报价两百多万一路降到现在的一百五十万。不到半年跌去五十万多，多少牛马打工人的年薪都达不到这个数。</p>
<p>照此趋势，我判断房价还是一路下跌下去，直至达到一个合理的租售比水平，趋势和风向才会开始扭转，房价才会相对稳定一些。不管你是刚需自住还是投资需要，面对半年跌去五十多万的资产行情，你可能目前都难以下得去手。</p>
<p>多年的投资经验反复告诉我们「没有只涨不跌、只跌不涨的资产」，福祸相依，周期和趋势中总是孕育着反向的力量，社会发展和人生道路也是如此。</p>
<p>在目前这个时间节点，我们能显性地看到很多行业的衰败迹象，但同时也能洞察出一些新兴产业的行业机会。作为个体，在通缩时代自然是需要好好蛰伏、休养生息、修炼内功，但同时也应该继续谨慎保持敏锐的嗅觉，尝试发现一些不多的机会。在投资和生活的选择里，我总是习惯反潮流而动，在人生道路的选择上，我也往往如此。总之，随大流不是我的性格。</p>
<p>在此可能要说一个暴论，我感觉现在可能来到了一个不错的可以开始重新筹备创业发现机会的时机。虽然现实的趋势并不乐观，但人为的一些因素却可以提供一些便利条件，比如政策、竞争压力、成本、人才、新兴行业机会的萌芽，都在中庸哲学中透露着一些支持性的力量，这就是多空博弈的反转态势（虽然现在还并没有反转）。</p>
<p>还是需要在此声明，我不是在鼓励现阶段创业，我自己短期内也并不会创业，目前保持一个「独立开发」的状态，对我个人来说挺好的。我只是说现在反而可能是一个不错的开始早期筹备、发现创业机会的时机。</p>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>创业</tag>
        <tag>资产配置</tag>
        <tag>BeanLedger</tag>
        <tag>复式记账</tag>
        <tag>通缩</tag>
      </tags>
  </entry>
  <entry>
    <title>Maples7 个人开源计划（9）</title>
    <url>/2025/07/31/open-source-maples7-9/</url>
    <content><![CDATA[<p>又是月末，照例进行更新和复盘。</p>
<h2 id="🧑🏻‍💻-工作"><a href="#🧑🏻‍💻-工作" class="headerlink" title="🧑🏻‍💻 工作"></a>🧑🏻‍💻 工作</h2><ul>
<li>财务类 App <a href="https://apps.apple.com/app/beanledger/id6739036460">BeanLedger</a> 发布 2.0，使用全新 UI 风格！<ul>
<li><a href="https://maples7.com/2025/06/30/open-source-maples7-8/">上一篇《开源计划》</a>已经提到刚在大陆地区上架时<a href="http://xhslink.com/m/6zTbw00dlVy">在小红书随手发了一篇帖子</a>，吸引了不少关注，同时也收到了很多愿意尝试的用户的反馈，虽然也有少数用户很喜欢第一版的 UI，但大多数用户吐槽最多还是第一版的 UI 风格过于硬核，正好我也打算适配 iOS 26 的新的 UI 风格，于是干脆重新写了新的 UI 风格并更新了 2.0 新版。虽然也没有经过专业的设计，但是有了第一版的经验，并从诸多真实的用户交互的反馈中学习，我自认为新版的 UI&#x2F;UX 还是改进了很多的。</li>
<li>2.0 之后会着重在新功能的实现和代码、性能的改进，已经实现了部分了。</li>
<li>功能和界面都比较稳定之后会开始补充设计思路和使用说明的文档。</li>
<li>整个这个月都做了很多改进和修复，代码变动还挺频繁的，大陆地区上线第一周甚至发了 5 个新版本。目前依然有不少值得关注的问题，尤其是跟 SwiftData 相关的，这几乎是造成目前代码中绝大部分问题的源泉，需要找个时间彻底把跟数据交互的代码重构一遍。</li>
<li>为了适配 iOS 17 也花费了不少精力，尤其很多也是跟 SwiftData 相关的问题，因为 Apple 在 iOS 17 上才推出第一版 SwiftData，底层有不少严重错误和 bug，导致我为了适配 iOS 17 不得不绕过这些 bug，但为了绕过这些底层 bug 也都付出一些代价，要么是交互上的、要么是性能上的。第一次这么真切的体会到大前端开发需要适配低版本运行环境时的无奈，梦回大学 IE 时代 😵‍💫。</li>
<li>关于用户需求还蛮有意思的，用户的表述和需求不一定都是清晰或有效的，为了挖掘真实的用户需求，你得不断揣摩他们提出这样的想法的真实动因，同时你也得对自己的产品方向有一些设计原则上的坚持，而不至于让它变得过于臃肿和四不像。就像之前很多「互联网教父」们所不耐烦的 —— 怎么又是 iOS 三大件。我其实无意于在这个赛道去卷，我根本就没把它当作赛道，对于这个产品而言，我只是想做一个我自己用的好工具而已，顺便分享给更多人用，也不图它真的能带来什么回报。但话说回来，我也无意于打造一款跟市面上大多数记账软件雷同的又一个新轮子，如果是这样我会继续用市面上那些已经做得不错的产品了，这样显然在达到我同样目的的成本上性价比更高。<strong>记账其实一个个性化程度很高的事情，不同的人有不同的需求和习惯</strong>，其实很难用一款 App 去满足所有人，这也是为什么市面上林林总总的记账软件这么多的原因之一。跟很多人生的其他事情一样，你无法让所有人都满意。</li>
<li>在这个过程中，我也产生了一些新的想法，包括产品设计、特性、功能具体实现的思路上，这可能会孕育未来我的第二款 App。没错，我的第二款 App 甚至很可能还是记账（吃透记账这件小事 🤣），但会跟现在这个有明显的区别，针对的用户人群也会做明显区分，所以不会影响 BeanLedger 的后续开发和维护计划。我个人应该还是会主要用 BeanLedger 作为我个人的财务软件，还是那句话，只要我自己还在<a href="https://zh.wikipedia.org/wiki/%E5%90%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%8B%97%E7%B2%AE">「吃自己的狗粮」</a>，我就不会停止对它的继续开发和维护，一定会让它变得越来越好用，这同时也是方便我自己使用。</li>
<li>再一次想说，个人时间和精力实在太有限，从上面的工作可以看出来，一个人干了设计师、产品经理、用户调研、程序员、客服、营销的活儿，虽然并不是创业却在体验最真实的创业。不过我目前还是挺喜欢这样的节奏和状态的，我或许也要考虑雇一个 AI 员工帮我写代码了哈哈哈。</li>
</ul>
</li>
</ul>
<h2 id="🎲-滚雪球"><a href="#🎲-滚雪球" class="headerlink" title="🎲 滚雪球"></a>🎲 滚雪球</h2><p>最新的资产配置比例的桑基图：</p>
<p><img data-src="https://s2.loli.net/2025/07/31/1PGs8IElSca2Nin.png" alt="此资产配置图使用我自己开发的财务工具 App BeanLedger 生成"><center><small>(此资产配置图使用我自己开发的财务工具 App BeanLedger 生成)</small></center></p>
<p>从上一次分享到这一次的过程期间（2025-06-30 ~ 2025-07-31），资产净值<strong>增加 ¥123566.83</strong>。有这样的涨幅当然得益于二级市场最近一路上扬的行情，有不少人甚至开始相信这是另一场牛市的开端。你问我怎么看？我们的投资策略不依赖于预测，当然是边吃席边往门口走避免自己成为为盛宴买单的那一个。但如果你要问我对后续行情的真实看法，我反正不像很多人那样乐观，这不，今天大跌就又来了。依然还是那句话，影响股市走势的因素太多了，这个复杂系统中长期本身就是不可预测的。</p>
<p><img data-src="https://s2.loli.net/2025/07/31/CcwJRzb2KGqByES.png" alt="ETF 拯救世界 - 微博"></p>
<p>这段时间做的投资操作有：逢高卖出「春华秋实」，几乎已经等于清仓了；两个「长赢计划」继续跟车，卖出过美元债、全指金融、恒生医疗、创业板，买入一份全球医疗保健。其他的大头部分都还没动，但「现金」的比例也已经创了新高了，甚至会希望未来再跌下来继续把多出来的现金再进行更合理的配置。</p>
<p>即便不上班，资产总额也还一直在创新高的，虽然这仰赖于<strong>有足够的可支配本金、一个好的资产配置和投资的策略和真实的资本市场的具体表现</strong>，但从性价比的角度来说，上班性价比实在是太低了，几乎占据了你每天的全部时间和精力，获得的回报却还很可能比不上资产增值，ROI 低得惊人，即便是在微软这样的外企「养老」。还是如我之前所说，<strong>财务自由不意味着财富绝对值的多少，财务自由的本质是时间自由</strong>。我不是说上班一定是不对的选择，而是人生短短三万天，追求的应该是按自己的意愿过自己想要的生活，用充分的主观能动性来支配自己每一天的时间。</p>
<p><strong>这个世界上几乎没有什么绝对公平的事情，只有时间对每一个人都是公平的，每个人都有责任好好把自己的时间按意愿分配在值得的事情上</strong>。如果你觉得我今天就要睡觉，那就去睡觉；如果要刷剧，那就去刷剧；如果要写代码，那就去写代码；如果你想上班，那就去上班；如果想旅行，那就去旅行。把自己的时间和热情花费在自己想要的事情上，才是对自己人生更大的负责，这是真正的长期主义。</p>
<h2 id="♨️-生活"><a href="#♨️-生活" class="headerlink" title="♨️ 生活"></a>♨️ 生活</h2><ul>
<li>终于看了《F1：狂飙飞车》，太精彩刺激了！拍出了一种黄金年代经济上行的美，重现好莱坞昔日荣光。强烈建议所有人都去看，虽然是一部典型的爆米花套路电影，但我相信很多人都能在这部电影找到对抗自己枯燥乏味生活的勇气。看完电影甚至让我燃起了对真实 F1 赛事的兴趣，正好上周末和这周末都有比赛，虚实结合了！</li>
<li>在 B 站看完了《情感反诈模拟器》（原名：捞女游戏）的主要剧情：<ul>
<li>作为一部影游，相比之下我觉得质量还不错。有的人可能会被它的名字劝退，或者看到名字已经自动脑补了很多关于男女的「政治正确」的批判观点，但真正看过这个游戏剧情和内容的才知道，它所传递出的关于情感的三观基本还是很正确的。特别值得一提的是，男女主角在酒吧十分钟确实贡献了封神的演技！如果代入前因后果去看，会发现他们的表演确实准确又生动，非常打动人。</li>
<li>从这部影游的火爆也可以看出，我国的男性在情感方面的需求其实在很大程度上是没有得到满足的，所以才会有这么多<a href="https://space.bilibili.com/35847683">峰哥</a>口中的「性压抑」群体。正如我之前所说，真正的女性主义运动不仅仅是对女性的解放，也是对男性的解放。男性同样是在一种有性别偏见的东亚传统文化下长大的，它可能会要求你更多的含蓄、包容、忍让、更多的承担、成为别人的依靠、无原则的对别人好，这导致很多男性的情感教育和人际交往知识极度欠缺，情感需求得不到满足，社会层面也几乎没有人会去关心男性内心真正的情感需求，从这部影游得到这么多国内男性的共鸣可以看出来这一点。这其实是一个潜在的巨大市场。</li>
</ul>
</li>
<li>下个月要花更多的时间准备在苏州的小型婚礼聚会了，一个月极限备婚！</li>
</ul>
]]></content>
      <categories>
        <category>浮生散记</category>
      </categories>
      <tags>
        <tag>产品</tag>
        <tag>BeanLedger</tag>
        <tag>F1</tag>
        <tag>捞女游戏</tag>
      </tags>
  </entry>
</search>
